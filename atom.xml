<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>cjwind&#39;s note</title>
  
  <subtitle>要夠努力，但不要太努力</subtitle>
  <link href="http://www.cjwind.idv.tw/atom.xml" rel="self"/>
  
  <link href="http://www.cjwind.idv.tw/"/>
  <updated>2021-03-11T15:12:27.182Z</updated>
  <id>http://www.cjwind.idv.tw/</id>
  
  <author>
    <name>cjwind</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Is High Quality Software Worth the Cost?</title>
    <link href="http://www.cjwind.idv.tw/Is-High-Quality-Software-Worth-the-Cost/"/>
    <id>http://www.cjwind.idv.tw/Is-High-Quality-Software-Worth-the-Cost/</id>
    <published>2021-03-11T15:02:56.000Z</published>
    <updated>2021-03-11T15:12:27.182Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://martinfowler.com/articles/is-quality-worth-cost.html">原文</a></p><p>Mindmap 筆記：</p><p><img src="/images/is-high-quality-software-worth-the-cost.png" alt=""></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://martinfowler.com/articles/is-quality-worth-cost.html&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Mindmap 筆記：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/is-high-quality</summary>
      
    
    
    
    
    <category term="Mindmap" scheme="http://www.cjwind.idv.tw/tags/Mindmap/"/>
    
  </entry>
  
  <entry>
    <title>ch3 個人的有氧與訓練能力指標</title>
    <link href="http://www.cjwind.idv.tw/daniels-running-formula/ch3/"/>
    <id>http://www.cjwind.idv.tw/daniels-running-formula/ch3/</id>
    <published>2021-03-07T08:24:58.000Z</published>
    <updated>2021-03-07T08:25:51.608Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/daniels-running-formula/ch3-mindmap.png" alt=""></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;/images/daniels-running-formula/ch3-mindmap.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
</summary>
      
    
    
    
    <category term="丹尼爾博士跑步方程式" scheme="http://www.cjwind.idv.tw/categories/%E4%B8%B9%E5%B0%BC%E7%88%BE%E5%8D%9A%E5%A3%AB%E8%B7%91%E6%AD%A5%E6%96%B9%E7%A8%8B%E5%BC%8F/"/>
    
    
    <category term="Reading" scheme="http://www.cjwind.idv.tw/tags/Reading/"/>
    
    <category term="Mindmap" scheme="http://www.cjwind.idv.tw/tags/Mindmap/"/>
    
    <category term="Running" scheme="http://www.cjwind.idv.tw/tags/Running/"/>
    
  </entry>
  
  <entry>
    <title>ch2 跑步原則與跑步的技術</title>
    <link href="http://www.cjwind.idv.tw/daniels-running-formula/ch2/"/>
    <id>http://www.cjwind.idv.tw/daniels-running-formula/ch2/</id>
    <published>2021-03-07T07:54:23.000Z</published>
    <updated>2021-03-07T07:55:43.929Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/daniels-running-formula/ch2-mindmap.png" alt=""></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;/images/daniels-running-formula/ch2-mindmap.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
</summary>
      
    
    
    
    <category term="丹尼爾博士跑步方程式" scheme="http://www.cjwind.idv.tw/categories/%E4%B8%B9%E5%B0%BC%E7%88%BE%E5%8D%9A%E5%A3%AB%E8%B7%91%E6%AD%A5%E6%96%B9%E7%A8%8B%E5%BC%8F/"/>
    
    
    <category term="Reading" scheme="http://www.cjwind.idv.tw/tags/Reading/"/>
    
    <category term="Mindmap" scheme="http://www.cjwind.idv.tw/tags/Mindmap/"/>
    
    <category term="Running" scheme="http://www.cjwind.idv.tw/tags/Running/"/>
    
  </entry>
  
  <entry>
    <title>ch1 跑者成功的要素</title>
    <link href="http://www.cjwind.idv.tw/daniels-running-formula/ch1/"/>
    <id>http://www.cjwind.idv.tw/daniels-running-formula/ch1/</id>
    <published>2021-03-07T07:45:41.000Z</published>
    <updated>2021-03-07T07:52:50.353Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/daniels-running-formula/ch1-mindmap.png" alt=""></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;/images/daniels-running-formula/ch1-mindmap.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
</summary>
      
    
    
    
    <category term="丹尼爾博士跑步方程式" scheme="http://www.cjwind.idv.tw/categories/%E4%B8%B9%E5%B0%BC%E7%88%BE%E5%8D%9A%E5%A3%AB%E8%B7%91%E6%AD%A5%E6%96%B9%E7%A8%8B%E5%BC%8F/"/>
    
    
    <category term="Reading" scheme="http://www.cjwind.idv.tw/tags/Reading/"/>
    
    <category term="Mindmap" scheme="http://www.cjwind.idv.tw/tags/Mindmap/"/>
    
    <category term="Running" scheme="http://www.cjwind.idv.tw/tags/Running/"/>
    
  </entry>
  
  <entry>
    <title>ch2 API Paradigms</title>
    <link href="http://www.cjwind.idv.tw/Designing-Web-APIs/Designing-Web-APIs-ch2/"/>
    <id>http://www.cjwind.idv.tw/Designing-Web-APIs/Designing-Web-APIs-ch2/</id>
    <published>2021-02-27T10:27:28.000Z</published>
    <updated>2021-02-27T10:28:46.252Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>An API paradigmdefines the interface exposing backend data of a service to otherapplications.</p></blockquote><h2 id="Request-Response-API"><a href="#Request-Response-API" class="headerlink" title="Request-Response API"></a>Request-Response API</h2><p>Request-Response API 通常透過 HTTP web server 來公開 interface。</p><p>這種 API 會定義一些 endpoints，client 對這些 endpoints 發出 HTTP request 來索取資料，server 則給予 response。response 通常是 JSON 或 XML 格式。</p><p>Request-Response API 有三種：</p><ul><li>REST</li><li>RPC</li><li>GraphQL</li></ul><h3 id="REST-Representational-State-Transfer"><a href="#REST-Representational-State-Transfer" class="headerlink" title="REST (Representational State Transfer)"></a>REST (Representational State Transfer)</h3><blockquote><p>REST is all about <em>resource</em>.</p></blockquote><p>resource 是可以在 web 上被 identify、named、addressed 或 handled 的 entity。</p><p>REST API 將資料當成 resource 來 expose 出去，並使用 standard HTTP method 表示 CRUD 的動作。</p><p>REST API 遵循的一般規則：</p><ul><li>resource 是 URL 的一部分，例如 <code>/users</code></li><li>每個 resource 通常有兩個 URL。一個表示 collection，例如 <code>/users</code>。一個表示特定元素，例如 <code>/users/U123</code>。</li><li>resource 使用名詞而非動詞，例如用 <code>/users/U123</code>，而不是 <code>/getUserInfo/U123</code>。</li><li>用 <code>GET</code>、<code>POST</code>、<code>UPDATE</code> 跟 <code>DELETE</code> 等 HTTP method 來告訴 server 要執行的動作。<ul><li>Create<ul><li>用 <code>POST</code> 建立新 resource</li></ul></li><li>Read<ul><li>用 <code>GET</code> 讀取 resource</li><li><code>GET</code> request 永遠不會改變 resource 的狀態，不會有 side effect</li><li><code>GET</code> method 有 read-only 的意思</li><li><code>GET</code> 是 idempotent</li></ul></li><li>Update<ul><li>用 <code>PUT</code> 來 replace resource。</li><li>用 <code>PATCH</code> 來對現有 resource 做部份 update。<a href="http://tools.ietf.org/html/rfc5789">RFC 5789</a></li></ul></li><li>Delete<ul><li>以 <code>DELETE</code> 來刪除現有 resource。</li></ul></li></ul></li><li>server 回傳標準的 HTTP response status code 來表示成功或失敗<ul><li>2XX 代表成功</li><li>3XX 代表 resource 已被移除</li><li>4XX 代表 client 端錯誤</li><li>5XX 代表 server 端錯誤</li></ul></li><li>REST API 可回傳 JSON 或 XML 格式</li></ul><h4 id="Showing-relationships"><a href="#Showing-relationships" class="headerlink" title="Showing relationships"></a>Showing relationships</h4><p>盡量用 subresource 表示只屬於其他 resource 的 resource，不要用 top-level resource 表示它，這樣可以讓使用 API 的 developer 知道它們之間的關係。</p><p>例如 Github 的 API：<code>POST /repos/:owner/:repo/issues</code> 是在某個人的某個 repository 底下建立一個 issue。</p><h4 id="非-CRUD-操作"><a href="#非-CRUD-操作" class="headerlink" title="非 CRUD 操作"></a>非 CRUD 操作</h4><p>有時候 REST API 需要表示非 CRUD 的操作，常見作法如下：</p><ul><li>以 resource 的部份欄位來表示動作（action）<ul><li>例如 Github 要把 repository archive 起來是用 entry <code>PATCH /repos/:owner/:repo</code> 然後 data body 是 <code>&#123;&quot;archived&quot;: true&#125;</code>。因為 <code>PATCH</code> entry 的 request  data body 是 resource 要被更新的欄位，所以才說是以「resource 的部份欄位」來表示動作。</li></ul></li><li>將操作視為 subresource<ul><li>例如 Github 的 lock issue 是 <code>PUT /repos/:owner/:repo/issues/:number/lock</code></li></ul></li><li>有些操作難以用 REST 模式，例如搜尋，這時候通常會在 API URL 直接使用操作的動詞。<ul><li>例如在 Github 中尋找符合 query 的檔案：<code>GET /search/code?q=:query:</code>。</li></ul></li></ul><h3 id="Remote-Procedure-Call-RPC"><a href="#Remote-Procedure-Call-RPC" class="headerlink" title="Remote Procedure Call (RPC)"></a>Remote Procedure Call (RPC)</h3><p>REST 跟 resource 有關，RPC 則跟動作（action）有關。</p><p>RPC 的 client 會在 server 上執行一段 code。client 通常會傳 method name 跟 argument 給 server，然後得到 JSON 或 XML。</p><p>RPC API 通常遵循兩個規則：</p><ul><li>endpoint 含有準備執行的 action 的名稱</li><li>API call 是用最適合的 HTTP verb 來執行：<code>GET</code> 是 read-only request，<code>POST</code> 則是其他。</li></ul><blockquote><p>當 API 公開的動作比 CRUD 封裝的還要細膩且複雜，或是存在與眼前的「資源」無關的 side effect 時，很適合使用 RPC。RPC style 的 API 也可以配合複雜的 resource model，或針對多種類型的 resource 執行的動作。</p></blockquote><p>RPC style 的 API 除了用 HTTP 外也可以用其他 protocol，包括 <a href="https://thrift.apache.org">Apache Thrift</a> 跟 <a href="https://grpc.io/docs/guides/index.html">gRPC</a>。</p><h3 id="GraphQL"><a href="#GraphQL" class="headerlink" title="GraphQL"></a>GraphQL</h3><p><a href="https://graphql.org">https://graphql.org</a></p><p>GraphQL 可以讓 client 端定義需要的 data structure，讓 server 以那個 structure 回傳資料。例如以下是送給 Github API 的 GraphQL query 及其 response：</p><figure class="highlight clojure"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    user(<span class="name">login:</span> <span class="string">&quot;saurabhsahni&quot;</span>) &#123;</span><br><span class="line">        id</span><br><span class="line">        name</span><br><span class="line">        company</span><br><span class="line">        createdAt</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>response：</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;data&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;user&quot;</span>: &#123;</span><br><span class="line">            <span class="attr">&quot;id&quot;</span>: <span class="string">&quot;MDQ6VXNlcjY1MDIS&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;Saurabh Sahni&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;company&quot;</span>: <span class="string">&quot;Slack&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;createdAt&quot;</span>: <span class="string">&quot;2009-03-19T21:00:06Z&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>GraphQL 只需要一個 URL endpoint，而且不需要用不同的 HTTP verb 描述操作，只要在 JSON 內容中寫要做的動作就可以了。</p><h4 id="GraphQL-的優點"><a href="#GraphQL-的優點" class="headerlink" title="GraphQL 的優點"></a>GraphQL 的優點</h4><p>跟 REST 及 RPC 比起來，GraphQL 的優點：</p><ul><li>節省多次 round trip<ul><li>client 可以用 nested query 以一個 request 從多個 resource 取得資料</li><li>以 REST 來說，要取得多個 resource 資料可能需要很多個 request</li></ul></li><li>不需要 versioning<ul><li>在 GraphQL API 增加新的欄位跟 type 不會影響既有的 query</li><li>要 deprecate 一個欄位也很容易：可以用 log 分析 client 用了哪些欄位，在工具中隱藏某些欄位，並且在沒人用的時候移除它們。</li></ul></li><li>較小的 payload<ul><li>因為 client 可以明確指定要什麼資料，所以 payload 可以比較小。</li><li>REST 跟 RPC 常常回傳 client 永遠用不到的資料。</li></ul></li><li>Strongly typed<ul><li>GraphQL 是 strongly typed，它的 type checking 會確保 query 的語法是正確且有效的。</li></ul></li><li>Introspection<ul><li><a href="https://github.com/graphql/graphiql">GraphiQL</a> 這個瀏覽器 IDE 可以寫 GraphQL query 來試驗跟了解 GraphQL API <em>（就是可以直接玩 API 啦）</em></li></ul></li></ul><h4 id="GraphQL-的缺點"><a href="#GraphQL-的缺點" class="headerlink" title="GraphQL 的缺點"></a>GraphQL 的缺點</h4><p>對提供 GraphQL API 的提供者來說，GraphQL 增加了複雜性，server 需要做額外的工作來解析複雜的 query 跟驗證參數。最佳化 GraphQL query 的效能也很麻煩。</p><h3 id="REST-vs-RPC-vs-GraphQL"><a href="#REST-vs-RPC-vs-GraphQL" class="headerlink" title="REST vs RPC vs GraphQL"></a>REST vs RPC vs GraphQL</h3><img src="/images/designing-web-apis/ch2-1.jpg" class="" width="620"><img src="/images/designing-web-apis/ch2-2.jpg" class="" width="620"><h2 id="Event-Driven-API"><a href="#Event-Driven-API" class="headerlink" title="Event-Driven API"></a>Event-Driven API</h2><p>如果 service 的資料常常會改變，用 request-response API 的作法 response 很快會過時，這時候使用 API 的 developer 通常會以 polling 來確保得到最新的資料。但如果 polling 頻率太低，可能會在需要即時更新的狀況下無法即時更新 。而 polling 頻率太高則會浪費資源，因為大部分 request 都不會有新資料。</p><p>要即時分享 event 資料，有三種方式：WebHook、WebSocket 跟 HTTP Streaming。</p><h3 id="WebHook"><a href="#WebHook" class="headerlink" title="WebHook"></a>WebHook</h3><p><strong>WebHook 是個接收 HTTP POST（或 GET、PUT 或 DELETE）的 URL。</strong> 實作 WebHook 的 API provider 會在某些事情發生時 POST 一個訊息給使用者設置好的 URL，例如信用卡授權的 postback。</p><p>提供 WebHook 會引入的複雜性：</p><ul><li>Failures and retries：為了確保資訊成功 deliver，須建立發生錯誤時的 retry 機制。</li><li>Security：使用 WebHook 時，API 使用者要驗證從 WebHook 收到的資料，以確保資料是合法的。</li><li>Firewall：在防火牆後的 app 很難用 WebHook 收資料，得在防火牆上打洞。</li><li>Noise 雜訊：通常一個 WebHook call 都代表一個 event。如果有成千上萬個 event 在短時間內發生而且必須透過單一 WebHook 來傳送，可能會產生雜訊。</li></ul><h3 id="WebSocket"><a href="#WebSocket" class="headerlink" title="WebSocket"></a>WebSocket</h3><blockquote><p>WebSocket is a protocol used to establish a two-way streaming communication channel over a single Transport Control Protocol (TCP) connection.</p></blockquote><p>WebSocket 這個 protocol 通常用在 web client 跟 server 間，有時也會被用來做 server 對 server 的通訊。WebSocket 可以在比較低的 overhead 的情況下開啟 full-duplex 通訊（server 跟 client 可以同時跟對方通訊）。</p><p>WebSocket 是運作在 port 80 或 443 上，所以不用在防火牆上另外開 port 來進行連線與通訊。而且使用 WebSocket 也不像 WebHook 得對 internet 打開一個 HTTP endpoint 來接收 event，相對來說比較安全。</p><p>WebSocket 適合快速、live 的 streaming 以及長時間（long-lived）的 connection。但不見得適合用在行動裝置或者網路不穩定的地方，因為 client 必須有能力維持 connection，connection 斷了 client 就得重新啟動它。</p><h3 id="HTTP-Streaming"><a href="#HTTP-Streaming" class="headerlink" title="HTTP Streaming"></a>HTTP Streaming</h3><p>在 request-response 形式的 HTTP API 裡，client 送出 request 後，會收到一包有限長度的 response。而使用 HTTP Streaming，server 可以透過 client 開啟的 long-lived connection 來持續推送新資料。</p><img src="/images/designing-web-apis/ch2-3.png" class="" width="620"><blockquote><p>To  transmit  data  over  a  persistent  connection  from  server  to  client, there  are  two  options.  The  first  option  is  for  the  server  to  set  the Transfer-Encoding header to chunked. This indicates to clients that data will be arriving in chunks of newline-delimited strings. For typ‐ical application developers, this is easy to parse.<br>Another  option  is  to  stream  data  via  server-sent  events  (SSE).  This option  is  great  for  clients  consuming  these  events  in  a  browser because they can use the standardized EventSource API.</p></blockquote><blockquote><p>HTTP  Streaming  is  easy  to  consume.  However,  one  of  the  issues with  it  is  related  to  buffering.  Clients  and  proxies  often  have  bufferlimits. They might not start rendering data to the application until a threshold is met. Also, if clients want to frequently change what kind of events they listen to, HTTP Streaming might not be ideal because it requires reconnections.</p></blockquote><h3 id="Event-Driven-API-的比較"><a href="#Event-Driven-API-的比較" class="headerlink" title="Event-Driven API 的比較"></a>Event-Driven API 的比較</h3><img src="/images/designing-web-apis/ch2-4.png" class="" width="620"><img src="/images/designing-web-apis/ch2-5.png" class="" width="620"><h2 id="總結"><a href="#總結" class="headerlink" title="總結"></a>總結</h2><p>沒有一體適用的 API paradigm。每種 API paradigm 只適合特定類型的 use case，所以在實際狀況下有可能需要支援多種 paradigm。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;An API paradigmdefines the interface exposing backend data of a service to otherapplications.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;Requ</summary>
      
    
    
    
    <category term="Designing Web Apis" scheme="http://www.cjwind.idv.tw/categories/Designing-Web-Apis/"/>
    
    
    <category term="Reading" scheme="http://www.cjwind.idv.tw/tags/Reading/"/>
    
  </entry>
  
  <entry>
    <title>《原子習慣》</title>
    <link href="http://www.cjwind.idv.tw/Atomic-Habits/"/>
    <id>http://www.cjwind.idv.tw/Atomic-Habits/</id>
    <published>2021-02-16T10:01:51.000Z</published>
    <updated>2021-02-26T01:18:35.776Z</updated>
    
    <content type="html"><![CDATA[<h2 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h2><p><img src="/images/atomic_habits_mindmap1.png" alt=""></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;基本原理&quot;&gt;&lt;a href=&quot;#基本原理&quot; class=&quot;headerlink&quot; title=&quot;基本原理&quot;&gt;&lt;/a&gt;基本原理&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;/images/atomic_habits_mindmap1.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
</summary>
      
    
    
    
    
    <category term="Reading" scheme="http://www.cjwind.idv.tw/tags/Reading/"/>
    
    <category term="Mindmap" scheme="http://www.cjwind.idv.tw/tags/Mindmap/"/>
    
  </entry>
  
  <entry>
    <title>Docker command snippet</title>
    <link href="http://www.cjwind.idv.tw/Docker-command-snippet/"/>
    <id>http://www.cjwind.idv.tw/Docker-command-snippet/</id>
    <published>2021-02-09T12:02:56.000Z</published>
    <updated>2021-02-09T12:19:00.121Z</updated>
    
    <content type="html"><![CDATA[<p>老是失憶……</p><figure class="highlight elixir"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 跑起一個 ubuntu container 並且用 foreground 模式進入 bash</span></span><br><span class="line"><span class="variable">$ </span>sudo docker run -it ubuntu bash</span><br><span class="line"></span><br><span class="line"><span class="variable">$ </span>sudo docker run -d -p [HOST_PORT]<span class="symbol">:</span>[CONTAINER_PORT] --name [CONTAINER_NAME] [IMAGE_NAME]<span class="symbol">:</span>[version]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 停止並移除 container</span></span><br><span class="line"><span class="variable">$ </span>sudo docker rm --force [CONTAINER]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 列出 local 有的 image</span></span><br><span class="line"><span class="variable">$ </span>sudo docker images</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在 Docker Hub 搜尋 image</span></span><br><span class="line"><span class="variable">$ </span>sudo docker search [KEYWORD]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在有 Dockerfile 的資料夾 build Docker image</span></span><br><span class="line"><span class="variable">$ </span>sudo docker build --tag [NAME]<span class="symbol">:</span>[TAG] .</span><br><span class="line"></span><br><span class="line"><span class="comment"># Remove Docker image</span></span><br><span class="line"><span class="variable">$ </span>sudo docker rmi [IMAGE]</span><br><span class="line"></span><br><span class="line"><span class="comment"># Login to a Docker registry</span></span><br><span class="line"><span class="comment"># 如果是 private registry 就要 login 才能 push</span></span><br><span class="line"><span class="variable">$ </span>sudo docker login</span><br><span class="line"></span><br><span class="line"><span class="comment"># Push Docker image</span></span><br><span class="line"><span class="variable">$ </span>sudo docker push [IMAGE_NAME]<span class="symbol">:</span>[TAG]</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;老是失憶……&lt;/p&gt;
&lt;figure class=&quot;highlight elixir&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# 跑起一個 ubuntu conta</summary>
      
    
    
    
    
    <category term="Docker" scheme="http://www.cjwind.idv.tw/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>Readmoo API Go Package</title>
    <link href="http://www.cjwind.idv.tw/Readmoo-API/"/>
    <id>http://www.cjwind.idv.tw/Readmoo-API/</id>
    <published>2021-02-09T08:51:05.000Z</published>
    <updated>2021-02-09T09:30:46.047Z</updated>
    
    <content type="html"><![CDATA[<p>用 Go 寫了個可以讀 Readmoo 的閱讀記錄跟劃線的 package。</p><p>可以從閱讀記錄拿到基本的書籍資料跟劃線。</p><p>細節見 <a href="https://github.com/cjwind/readmoo">Github</a>。</p><p><em>應該要把拿 token 弄得簡單點，現在很手動…</em></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;用 Go 寫了個可以讀 Readmoo 的閱讀記錄跟劃線的 package。&lt;/p&gt;
&lt;p&gt;可以從閱讀記錄拿到基本的書籍資料跟劃線。&lt;/p&gt;
&lt;p&gt;細節見 &lt;a href=&quot;https://github.com/cjwind/readmoo&quot;&gt;Github&lt;/a&gt;。&lt;/p&gt;</summary>
      
    
    
    
    
    <category term="Project" scheme="http://www.cjwind.idv.tw/tags/Project/"/>
    
    <category term="Go" scheme="http://www.cjwind.idv.tw/tags/Go/"/>
    
  </entry>
  
  <entry>
    <title>PhpStorm 快捷鍵</title>
    <link href="http://www.cjwind.idv.tw/PhpStorm-shortcut/"/>
    <id>http://www.cjwind.idv.tw/PhpStorm-shortcut/</id>
    <published>2021-02-05T15:57:41.000Z</published>
    <updated>2021-02-05T15:57:41.634Z</updated>
    
    <content type="html"><![CDATA[<p>我的 keymap 是 Sublime + Jetbrains 部份按鍵 + 自己設再配 vim 的大雜燴</p><ul><li><code>ctrl + shift + p</code>：執行動作（action）</li><li><code>ctrl + p</code>：找檔案</li><li><code>ctrl + r</code>：檔案中找 symbol</li><li><code>ctrl + alt + shift + t</code>：refactor 選單</li><li><code>alt + enter</code>：各種神奇功能(?)</li><li><code>alt + insert</code>：加入各種 code</li><li><code>shift + f6</code>：rename</li><li><code>alt + 1</code>：project browse window</li><li><code>alt + 3</code>：find window</li><li><code>alt + 4</code>：run window</li><li><code>alt + 9</code>：git window</li></ul><p>TBC…</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;我的 keymap 是 Sublime + Jetbrains 部份按鍵 + 自己設再配 vim 的大雜燴&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;ctrl + shift + p&lt;/code&gt;：執行動作（action）&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ctrl + p&lt;/co</summary>
      
    
    
    
    
    <category term="PhpStorm" scheme="http://www.cjwind.idv.tw/tags/PhpStorm/"/>
    
  </entry>
  
  <entry>
    <title>《跑者都該懂的跑步關鍵數據》跑步技術</title>
    <link href="http://www.cjwind.idv.tw/You-should-know-these-running-data/"/>
    <id>http://www.cjwind.idv.tw/You-should-know-these-running-data/</id>
    <published>2021-02-04T15:23:08.000Z</published>
    <updated>2021-03-07T07:50:47.192Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Mindmap-v1"><a href="#Mindmap-v1" class="headerlink" title="Mindmap v1"></a>Mindmap v1</h2><p><img src="/images/20210204_%E3%80%8A%E8%B7%91%E8%80%85%E9%83%BD%E8%A9%B2%E6%87%82%E7%9A%84%E9%97%9C%E9%8D%B5%E6%95%B8%E6%93%9A%E3%80%8B%E8%B7%91%E6%AD%A5%E6%8A%80%E8%A1%93_v1.png" alt=""></p><h2 id="Mindmap-v2"><a href="#Mindmap-v2" class="headerlink" title="Mindmap v2"></a>Mindmap v2</h2><p><img src="/images/20210209_%E3%80%8A%E8%B7%91%E8%80%85%E9%83%BD%E8%A9%B2%E6%87%82%E7%9A%84%E9%97%9C%E9%8D%B5%E6%95%B8%E6%93%9A%E3%80%8B%E8%B7%91%E6%AD%A5%E6%8A%80%E8%A1%93_v2.png" alt=""></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Mindmap-v1&quot;&gt;&lt;a href=&quot;#Mindmap-v1&quot; class=&quot;headerlink&quot; title=&quot;Mindmap v1&quot;&gt;&lt;/a&gt;Mindmap v1&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;/images/20210204_%E3%80%8A%E</summary>
      
    
    
    
    
    <category term="Reading" scheme="http://www.cjwind.idv.tw/tags/Reading/"/>
    
    <category term="Mindmap" scheme="http://www.cjwind.idv.tw/tags/Mindmap/"/>
    
    <category term="Running" scheme="http://www.cjwind.idv.tw/tags/Running/"/>
    
  </entry>
  
  <entry>
    <title>Go Module</title>
    <link href="http://www.cjwind.idv.tw/Golang/Go-Module/"/>
    <id>http://www.cjwind.idv.tw/Golang/Go-Module/</id>
    <published>2021-01-24T09:34:34.000Z</published>
    <updated>2021-01-24T09:35:40.000Z</updated>
    
    <content type="html"><![CDATA[<p>Go 從 1.13 開始支援 Go Module，可以在 <code>GOPATH</code> 以外的地方建立 go project 並進行套件管理。<em>一直覺得 source code 只能放在 <code>GOPATH</code> 裡超阿雜…</em></p><h2 id="建立-project"><a href="#建立-project" class="headerlink" title="建立 project"></a>建立 project</h2><p>在 <code>GOPATH</code> 以外的地方建立一個 directory，並且在其中執行 <code>go mod init</code>：</p><figure class="highlight gradle"><table><tr><td class="code"><pre><span class="line">$ mkdir <span class="keyword">project</span></span><br><span class="line">$ cd <span class="keyword">project</span></span><br><span class="line">$ go mod init github.com<span class="regexp">/cjwind/</span><span class="keyword">project</span></span><br></pre></td></tr></table></figure><p>會產生 <code>go.mod</code> 檔案，它會記錄 Go module 與使用的 Go 版本：</p><figure class="highlight gradle"><table><tr><td class="code"><pre><span class="line">module github.com<span class="regexp">/cjwind/</span><span class="keyword">project</span></span><br><span class="line"></span><br><span class="line">go <span class="number">1.15</span></span><br></pre></td></tr></table></figure><p>接下來在這個 directory 裡進行開發跟 build 就都一樣，重點是現在 source code 不用非得放在 <code>GOPATH</code> 裡啦～</p><h2 id="套件管理"><a href="#套件管理" class="headerlink" title="套件管理"></a>套件管理</h2><p>用 <code>go get</code> 安裝 package 後，會發現在 <code>go.mod</code> 多了一行 <code>require [package] [version]</code>，就表示目前使用的 package 及其 version。</p><p>另外可能會出現 <code>require [package] [version] // indirect</code>，這表示是我們使用的 package 所需要的 package。</p><p>也可以用 <code>go get [package]@[version]</code> 來指定特定的 package version。</p><h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><ul><li><a href="https://blog.golang.org/using-go-modules">Using Go Modules</a></li><li><a href="https://golang.org/ref/mod">Go Modules Reference</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Go 從 1.13 開始支援 Go Module，可以在 &lt;code&gt;GOPATH&lt;/code&gt; 以外的地方建立 go project 並進行套件管理。&lt;em&gt;一直覺得 source code 只能放在 &lt;code&gt;GOPATH&lt;/code&gt; 裡超阿雜…&lt;/em&gt;&lt;/p&gt;
</summary>
      
    
    
    
    
    <category term="Go" scheme="http://www.cjwind.idv.tw/tags/Go/"/>
    
  </entry>
  
  <entry>
    <title>Dockerfile</title>
    <link href="http://www.cjwind.idv.tw/Dockerfile/"/>
    <id>http://www.cjwind.idv.tw/Dockerfile/</id>
    <published>2020-11-21T14:49:58.000Z</published>
    <updated>2020-11-21T14:49:58.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="COPY"><a href="#COPY" class="headerlink" title="COPY"></a>COPY</h2><p><code>COPY</code> 如果 source 是 directory，會 copy directory 的內容，但是 directory 本身不會 copy。</p><p>假設有個資料夾叫 <code>css/</code>，底下有兩個 file <code>foo.css</code> 跟 <code>bar.css</code>。</p><figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">COPY</span><span class="bash"> ./css /workspace/</span></span><br></pre></td></tr></table></figure><p>這樣在 container 裡會變成 <code>/workspace/</code> 底下有 <code>foo.css</code> 跟 <code>bar.css</code>，而不是 <code>/workspace/css/</code> 底下有 <code>foo.css</code> 跟 <code>bar.css</code>。想要是 <code>/workspace/css/</code> 底下有兩個 file 得這樣寫：</p><figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">COPY</span><span class="bash"> ./css /workspace/css</span></span><br></pre></td></tr></table></figure><p>Ref：<a href="https://docs.docker.com/engine/reference/builder/#copy">https://docs.docker.com/engine/reference/builder/#copy</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;COPY&quot;&gt;&lt;a href=&quot;#COPY&quot; class=&quot;headerlink&quot; title=&quot;COPY&quot;&gt;&lt;/a&gt;COPY&lt;/h2&gt;&lt;p&gt;&lt;code&gt;COPY&lt;/code&gt; 如果 source 是 directory，會 copy directory 的內容，但</summary>
      
    
    
    
    
    <category term="Docker" scheme="http://www.cjwind.idv.tw/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>Go json and embedded struct</title>
    <link href="http://www.cjwind.idv.tw/Golang/Go-json-and-embedded-struct/"/>
    <id>http://www.cjwind.idv.tw/Golang/Go-json-and-embedded-struct/</id>
    <published>2020-11-15T14:00:46.000Z</published>
    <updated>2020-11-15T14:09:42.000Z</updated>
    
    <content type="html"><![CDATA[<p>使用 embedded struct 做 json 的 marshal 跟 unmarshal 時，json 欄位會省略 struct embedded 欄位的中間名，以比較簡潔的形式呈現。如果 struct 有寫出欄位名稱，json 欄位就會多那一層。</p><h2 id="使用-embedded-struct"><a href="#使用-embedded-struct" class="headerlink" title="使用 embedded struct"></a>使用 embedded struct</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Serving <span class="keyword">struct</span> &#123;</span><br><span class="line">    Amount <span class="keyword">float64</span></span><br><span class="line">    Unit   <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Food <span class="keyword">struct</span> &#123;</span><br><span class="line">    Name <span class="keyword">string</span></span><br><span class="line">    Serving    <span class="comment">// embedded struct</span></span><br><span class="line">    NutritionInfo</span><br><span class="line">    Comment <span class="keyword">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>marshal 結果：</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;Name&quot;</span>:<span class="string">&quot;Banana&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;Amount&quot;</span>:<span class="number">100</span>,</span><br><span class="line">  <span class="attr">&quot;Unit&quot;</span>:<span class="string">&quot;g&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;Calorie&quot;</span>:<span class="number">0</span>,</span><br><span class="line">  <span class="attr">&quot;Carb&quot;</span>:<span class="number">0</span>,</span><br><span class="line">  <span class="attr">&quot;Fat&quot;</span>:<span class="number">0</span>,</span><br><span class="line">  <span class="attr">&quot;Protein&quot;</span>:<span class="number">0</span>,</span><br><span class="line">  <span class="attr">&quot;Comment&quot;</span>:<span class="string">&quot;&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="不使用-embedded-struct"><a href="#不使用-embedded-struct" class="headerlink" title="不使用 embedded struct"></a>不使用 embedded struct</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Food <span class="keyword">struct</span> &#123;</span><br><span class="line">    Name <span class="keyword">string</span></span><br><span class="line">    Serving Serving    <span class="comment">// not embedded struct</span></span><br><span class="line">    NutritionInfo</span><br><span class="line">    Comment <span class="keyword">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>marshal 結果：</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;Name&quot;</span>:<span class="string">&quot;Banana&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;Serving&quot;</span>:</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">&quot;Amount&quot;</span>:<span class="number">100</span>,</span><br><span class="line">    <span class="attr">&quot;Unit&quot;</span>:<span class="string">&quot;g&quot;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">&quot;Calorie&quot;</span>:<span class="number">0</span>,</span><br><span class="line">  <span class="attr">&quot;Carb&quot;</span>:<span class="number">0</span>,</span><br><span class="line">  <span class="attr">&quot;Fat&quot;</span>:<span class="number">0</span>,</span><br><span class="line">  <span class="attr">&quot;Protein&quot;</span>:<span class="number">0</span>,</span><br><span class="line">  <span class="attr">&quot;Comment&quot;</span>:<span class="string">&quot;&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不用 embeded struct 就會有一層 <code>Serving</code>，用 embedded struct 就會省略 <code>Serving</code> 這層。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;使用 embedded struct 做 json 的 marshal 跟 unmarshal 時，json 欄位會省略 struct embedded 欄位的中間名，以比較簡潔的形式呈現。如果 struct 有寫出欄位名稱，json 欄位就會多那一層。&lt;/p&gt;
&lt;h2 i</summary>
      
    
    
    
    
    <category term="Go" scheme="http://www.cjwind.idv.tw/tags/Go/"/>
    
  </entry>
  
  <entry>
    <title>Git submodule</title>
    <link href="http://www.cjwind.idv.tw/Git-submodule/"/>
    <id>http://www.cjwind.idv.tw/Git-submodule/</id>
    <published>2020-10-08T15:12:57.000Z</published>
    <updated>2020-10-08T15:12:57.000Z</updated>
    
    <content type="html"><![CDATA[<p>submodule 是在 git repos 中使用別的 repos 的方式之一。</p><p>git 的 submodule 是記錄一個指到別人 repo 某個 commit 的指標。對主 repo 來說，記錄的只是一個 submodule commit hash。</p><p>切到 submodule 的目錄時做 git 操作會是在操作另一個 repo。</p><h2 id="加入-submodule"><a href="#加入-submodule" class="headerlink" title="加入 submodule"></a>加入 submodule</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git submodule add &lt;repo path&gt;</span></span><br></pre></td></tr></table></figure><h2 id="clone-含有-submodule-的-repos"><a href="#clone-含有-submodule-的-repos" class="headerlink" title="clone 含有 submodule 的 repos"></a>clone 含有 submodule 的 repos</h2><p>clone 含有 submodule 的 repos 後，submodule 的目錄會是空的，要做以下動作來初始化：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git submodule init</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git submodule update</span></span><br></pre></td></tr></table></figure><p><code>git submodule update</code> 會讓 submodule 的內容回到記錄的 commit。</p><h2 id="更新-submodule"><a href="#更新-submodule" class="headerlink" title="更新 submodule"></a>更新 submodule</h2><p>submodule 的 repo 更新或者想用不同版本（commit）的 submodule 時，要做以下操作：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> submodule_dir</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git pull</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> ..</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git a submodule_dir<span class="comment"># 更新主 repo 記錄的 submodule commit hash</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git ci</span></span><br></pre></td></tr></table></figure><p>概念是把 submodule 的 repo 更新或者 checkout 到想要的 commit，再在主 repo 更新記錄的 submodule commit hash。</p><h2 id="移除-submodule"><a href="#移除-submodule" class="headerlink" title="移除 submodule"></a>移除 submodule</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git rm -rf submodule_dir</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> vim .git/config<span class="comment"># 移掉 submodule 相關設定</span></span></span><br></pre></td></tr></table></figure><h2 id="gitmodules"><a href="#gitmodules" class="headerlink" title=".gitmodules"></a>.gitmodules</h2><p>檔案 <code>.gitmodules</code> 會記錄有哪些 submodule。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;submodule 是在 git repos 中使用別的 repos 的方式之一。&lt;/p&gt;
&lt;p&gt;git 的 submodule 是記錄一個指到別人 repo 某個 commit 的指標。對主 repo 來說，記錄的只是一個 submodule commit hash。&lt;/</summary>
      
    
    
    
    
    <category term="Git" scheme="http://www.cjwind.idv.tw/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>Go init() function</title>
    <link href="http://www.cjwind.idv.tw/Golang/Golang-init-func/"/>
    <id>http://www.cjwind.idv.tw/Golang/Golang-init-func/</id>
    <published>2020-08-29T09:48:15.000Z</published>
    <updated>2021-02-26T14:42:35.572Z</updated>
    
    <content type="html"><![CDATA[<p>任何檔案可以擁有任意數量的 <code>init()</code> function：</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>init()</code> 會在程式啟動時自動以宣告的順序執行，但不能被 call 或參考。</p><p>假設有以下兩個 go 檔案：</p><figure class="highlight go"><figcaption><span>foo.go</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;foo.go first init&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight go"><figcaption><span>main.go</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;main.go first init&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;main.go second init&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 <code>go run</code> 以不同的順序指定 source file 會有不同結果：</p><figure class="highlight maxima"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">go</span> run foo.<span class="built_in">go</span> main.<span class="built_in">go</span></span><br><span class="line">foo.<span class="built_in">go</span> <span class="built_in">first</span> init</span><br><span class="line">main.<span class="built_in">go</span> <span class="built_in">first</span> init</span><br><span class="line">main.<span class="built_in">go</span> <span class="built_in">second</span> init</span><br><span class="line"></span><br><span class="line">$ <span class="built_in">go</span> run main.<span class="built_in">go</span> foo.<span class="built_in">go</span></span><br><span class="line">main.<span class="built_in">go</span> <span class="built_in">first</span> init</span><br><span class="line">main.<span class="built_in">go</span> <span class="built_in">second</span> init</span><br><span class="line">foo.<span class="built_in">go</span> <span class="built_in">first</span> init</span><br><span class="line"></span><br><span class="line"># 不指定 file</span><br><span class="line">$ <span class="built_in">go</span> run .</span><br><span class="line">foo.<span class="built_in">go</span> <span class="built_in">first</span> init</span><br><span class="line">main.<span class="built_in">go</span> <span class="built_in">first</span> init</span><br><span class="line">main.<span class="built_in">go</span> <span class="built_in">second</span> init</span><br></pre></td></tr></table></figure><p>不指定 file 的話 <code>go</code> 會將 file 以其名稱排序。</p><p>如果嘗試直接 call <code>init()</code> 則會 compile error：</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;main.go first init&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    init()  <span class="comment">// compile error: undefined: init</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;任何檔案可以擁有任意數量的 &lt;code&gt;init()&lt;/code&gt; function：&lt;/p&gt;
&lt;figure class=&quot;highlight go&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span cl</summary>
      
    
    
    
    
    <category term="Go" scheme="http://www.cjwind.idv.tw/tags/Go/"/>
    
  </entry>
  
  <entry>
    <title>ch10 I Can&#39;t Run This Method in a Test Harness</title>
    <link href="http://www.cjwind.idv.tw/Working-Effectively-with-Legacy-Code/ch10-I-Can-t-Run-This-Method-in-a-Test-Harness/"/>
    <id>http://www.cjwind.idv.tw/Working-Effectively-with-Legacy-Code/ch10-I-Can-t-Run-This-Method-in-a-Test-Harness/</id>
    <published>2020-08-29T07:35:09.000Z</published>
    <updated>2020-09-19T05:07:56.000Z</updated>
    
    <content type="html"><![CDATA[<p>要為一段 code 寫測試，首先要在測試中建立它所屬的 class 的 instance，接著為要修改的 method 寫測試。這章要解決的是「難以在測試中執行要測試的 method」的情境。為一個 method 寫測試可能會遇到的問題：</p><ul><li>無法在測試中 access 那個 method，例如它可能是 private 的或是有其他存取限制。</li><li>很難建立所需參數，導致很難 call method，例如參數是一包 XML。</li><li>要測試的 method 可能產生糟糕的 side effect，例如修改 DB、發射飛彈等等，所以無法在測試中執行它。</li><li>需要透過該 method 使用的 object 進行 sense，才能知道這個 method 做了什麼事。</li></ul><h1 id="The-Case-of-the-Hidden-Method"><a href="#The-Case-of-the-Hidden-Method" class="headerlink" title="The Case of the Hidden Method"></a>The Case of the Hidden Method</h1><p>假設我們要修改的是一個 private method，想要測試它，該怎麼辦呢？</p><p>首先，能透過 public method 來測試它嗎？如果可以，就這麼幹吧～用 public method 去測試，就是按照程式中 private method 如何被使用的方式去測試它。如果有天要把 private method 改成 public，把它變成 public 的人應該寫一系列的測試說明這個 method 的用途以及 caller 該如何使用它。</p><p>這邊有提到一點 method 設計實作上的小概念：</p><blockquote><p>雖然 general 的 method 對 caller 來說蠻有用的，但每個 method 的功能應該剛好可以滿足 caller 並且易於理解與修改。</p></blockquote><p>有時候呢，我們就是想直接為 private method 寫測試（任性），可能是因為我們想用測試來知道如何使用 private method，或者用 public method 來測試它實在太難太痛苦啦～</p><p>例如一個擁有商業邏輯並且會 call third-party API 的 class 做的事情是：call API 取得一包 XML 資料，parse XML 得到商業邏輯需要的資料，再做商業邏輯上的計算或操作。我們想知道 parse XML 的 private method 是否正確，但它埋在整個流程裡，而用 public method 做整個的 call API、parsing、商業邏輯的測試難以只測試到 parse XML 的部份。</p><p>所以，想為 private method 寫測試時該怎麼辦呢？</p><blockquote><p>如果需要測試一個 private method，就該把它設成 public。</p></blockquote><p>看到書上這句話我蠻驚恐的，想著：「等等等，不是吧？就這樣直接把 private method 變成 public 好嗎？這不會在 class 上開出看起來突兀或者不知如何使用的 method 嗎？」</p><blockquote><p>如果不方便將其設為 public，大多數情況下意味著我們的 class 做太多事了，應該進行調整。</p></blockquote><p>喔～原來是這樣～這倒是真的～像上面那個例子，一個 class 既 call third-party API 又 parse XML 又做商業邏輯，太多事情了。</p><p>如果我們想測試一個 private method，首先看它是不是個適合在這個 class 當作 public 的 method？如果是，直接改成 public。否則看看是不是這個 class 做太多事了，有些事可以交由另一個 class 處理。例如我們把 parse XML 有關的 method 放到另一個 parser class，這些 method 到了新 class 會變成 public，原本的 class 就能 new 一個 parser 出來做事。</p><blockquote><p>好的設計應當是可測試的，不具可測試性的設計是糟糕的。</p></blockquote><p>如果我們遇到上面這樣的狀況，想拆解 class、將職責分開，卻沒有多少現成測試呢？假設我們想拆解這個包山包海的 class，但它本身卻沒有什麼測試，而 refactor 應當要有測試保護，雞生蛋蛋生雞的問題出現啦～</p><p>又或許，我們正在開發週期的後期，軟體已經接近 deploy，我們沒有多少時間去做拆解的 refactor，而且沒有測試又讓 refactor 的風險大幅提昇。儘管 refactor 可以改善程式結構、有好處，但需要考慮目前處於開發週期的哪個階段、時間多寡與風險高低，才能決定要不要 refactor 以及 refactor 到什麼程度。</p><p>時間不夠或風險太高的時，我們無法拆解 class。退而求其次，至少幫我們要修改的 private method 加上測試，讓這個 class 開始有測試保護也是好的。</p><p>想為 private method 加上測試，表示要能在測試中直接 call 到這個 method，要怎麼做呢？</p><p>又用到 Extract and Override 了～<em>這招也太萬用…</em></p><p>假設我們有個與機票搜尋、訂購有關的 class：</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Flight</span> </span>&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">search</span>(<span class="params"><span class="variable">$searchParams</span></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// call third party api and get response as xml</span></span><br><span class="line">    <span class="variable">$searchResults</span> = <span class="keyword">$this</span>-&gt;parseSearchResponse(<span class="variable">$xml</span>);</span><br><span class="line">    <span class="comment">// other impl.</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="function"><span class="keyword">function</span> <span class="title">parseSearchResponse</span>(<span class="params"><span class="variable">$xml</span></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// impl.</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">booking</span>(<span class="params"><span class="variable">$bookingParams</span></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// impl.</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// other methods</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 <code>search()</code> 裡先用 http client 向 third party API 送 request 並收 response，response 是一包 XML，我們想 parse 出其中需要的資料而 call <code>parseSearchResponse()</code>。因為 XML 相當複雜，我們希望能單獨確認 parsing 結果是否正確。</p><p>這個 class 除了 search、booking、parse 各種 XML 之外還會做許多事情，它的職責太多了，如果我們現在沒有時間去拆解它，卻想測試 <code>parseSearchResponse()</code> 的結果該怎麼做？</p><p>首先將 <code>parseSearchResponse()</code> 從 <code>private</code> 變成 <code>protected</code>：</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Flight</span> </span>&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">search</span>(<span class="params"><span class="variable">$searchParams</span></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// call third party api and get response as xml</span></span><br><span class="line">    <span class="variable">$searchResults</span> = <span class="keyword">$this</span>-&gt;parseSearchResponse(<span class="variable">$xml</span>);</span><br><span class="line">    <span class="comment">// other impl.</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 變成 protected</span></span><br><span class="line">  <span class="keyword">protected</span> <span class="function"><span class="keyword">function</span> <span class="title">parseSearchResponse</span>(<span class="params"><span class="variable">$xml</span></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// impl.</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接著在測試中繼承它：</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FlightForTest</span> <span class="keyword">extends</span> <span class="title">Flight</span> </span>&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">parseSearchResponse</span>(<span class="params"><span class="variable">$xml</span></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">parent</span>::parseSearchResponse(<span class="variable">$xml</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>這樣就能在測試 call 到 <code>parseSearchResponse()</code> 進行測試了：</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FlightTest</span> <span class="keyword">extends</span> <span class="title">TestCase</span> </span>&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">testParseSearchResponse</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="variable">$target</span> = <span class="keyword">new</span> FlightForTest();</span><br><span class="line">    <span class="variable">$xml</span> = <span class="string">&#x27;blabla&#x27;</span>;</span><br><span class="line">    <span class="variable">$ret</span> = <span class="variable">$target</span>-&gt;parseSearchResponse(<span class="variable">$xml</span>);</span><br><span class="line">    <span class="comment">// assertions</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>這麼做雖然沒有立即改善 <code>Flight</code> 做太多事的問題，但至少幫修改的地方加上測試，確保目前的修改是正確的。並且為將來拆解 class 的 refactor 鋪路――因為加了些測試而減少之後 refactor 所需的 effort 跟時間，使之後 refactor 成為可能。</p><h1 id="補充"><a href="#補充" class="headerlink" title="補充"></a>補充</h1><ul><li><a href="https://dotblogs.com.tw/hatelove/2012/07/19/why-you-should-not-write-unit-test-with-private-and-protected-method">[測試]單元測試：是否針對非 public method 進行測試？</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;要為一段 code 寫測試，首先要在測試中建立它所屬的 class 的 instance，接著為要修改的 method 寫測試。這章要解決的是「難以在測試中執行要測試的 method」的情境。為一個 method 寫測試可能會遇到的問題：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;無法在測</summary>
      
    
    
    
    <category term="Working Effectively with Legacy Code" scheme="http://www.cjwind.idv.tw/categories/Working-Effectively-with-Legacy-Code/"/>
    
    
    <category term="Reading" scheme="http://www.cjwind.idv.tw/tags/Reading/"/>
    
    <category term="Unit Test" scheme="http://www.cjwind.idv.tw/tags/Unit-Test/"/>
    
  </entry>
  
  <entry>
    <title>安裝 mariadb 並設定 root password</title>
    <link href="http://www.cjwind.idv.tw/Install-mariadb-and-setup-root-password/"/>
    <id>http://www.cjwind.idv.tw/Install-mariadb-and-setup-root-password/</id>
    <published>2020-08-16T09:57:52.000Z</published>
    <updated>2020-08-16T10:00:18.000Z</updated>
    
    <content type="html"><![CDATA[<p>在 Debian，先安裝：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo apt install mariadb-server</span></span><br></pre></td></tr></table></figure><p>裝完做些跟安全有關的設定跟 root password：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo mysql_secure_installation</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在 Debian，先安裝：&lt;/p&gt;
&lt;figure class=&quot;highlight shell&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;$&lt;/span&gt;&lt;span cl</summary>
      
    
    
    
    
    <category term="DB" scheme="http://www.cjwind.idv.tw/tags/DB/"/>
    
  </entry>
  
  <entry>
    <title>ch5 Tools</title>
    <link href="http://www.cjwind.idv.tw/Working-Effectively-with-Legacy-Code/ch5-Tools/"/>
    <id>http://www.cjwind.idv.tw/Working-Effectively-with-Legacy-Code/ch5-Tools/</id>
    <published>2020-08-13T01:19:58.000Z</published>
    <updated>2020-09-19T05:07:44.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h1><ul><li>自動化重構工具<ul><li>像 JetBrains、Visual Studio 等 IDE 的 refactor 功能。</li><li>在工具夠好的情況下，可以在沒有為 code 寫測試的情況下用工具進行自動化 refactor。但有時工具可能有問題，refactor 卻會修改到程式行為，所以使用工具進行 refactor 前，如果能先寫測試還是比較好的。</li><li>要注意工具在 refactor 時會跟不會進行哪些檢查<ul><li>例如 extract method，如果將新 method 命名為已存在 method 的名字，工具會不會顯示錯誤？</li></ul></li></ul></li><li>Unit Test 工具<ul><li>xUnit framework<br>  這類型 framework 執行測試大致的作法：找到 test class 裡所有 test method（依據語言不同有不同作法，有些語言可以用 reflection），為每個 test method 產生一個單獨的 object，該 object 的任務是去執行那個 test method。利用不同 object 隔離 test case，讓 test case 不會互相影響。</li></ul></li><li>一般測試控制工具<ul><li>FIT (Framework for Integration Test）</li><li>Fitnesse</li><li>Selenium</li><li><em>……等等其他</em></li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Summary&quot;&gt;&lt;a href=&quot;#Summary&quot; class=&quot;headerlink&quot; title=&quot;Summary&quot;&gt;&lt;/a&gt;Summary&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;自動化重構工具&lt;ul&gt;
&lt;li&gt;像 JetBrains、Visual Studio 等 </summary>
      
    
    
    
    <category term="Working Effectively with Legacy Code" scheme="http://www.cjwind.idv.tw/categories/Working-Effectively-with-Legacy-Code/"/>
    
    
    <category term="Reading" scheme="http://www.cjwind.idv.tw/tags/Reading/"/>
    
    <category term="Unit Test" scheme="http://www.cjwind.idv.tw/tags/Unit-Test/"/>
    
    <category term="Refactor" scheme="http://www.cjwind.idv.tw/tags/Refactor/"/>
    
  </entry>
  
  <entry>
    <title>ch4 The Seam Model</title>
    <link href="http://www.cjwind.idv.tw/Working-Effectively-with-Legacy-Code/ch4-The-Seam-Model/"/>
    <id>http://www.cjwind.idv.tw/Working-Effectively-with-Legacy-Code/ch4-The-Seam-Model/</id>
    <published>2020-08-11T01:11:13.000Z</published>
    <updated>2020-09-19T05:08:17.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Seam-amp-Enabling-Point"><a href="#Seam-amp-Enabling-Point" class="headerlink" title="Seam &amp; Enabling Point"></a>Seam &amp; Enabling Point</h1><p>seam（接縫）是指程式中一些特殊的點，在這些點上你不需要修改它本身就可以變動程式行為。</p><p>例如某段程式 call 了一個 function 來計算商品價格，現在想改變計算價格的 strategy。想在不改變 call 計價 function 的情況下，改變計價結果（程式行為）。</p><p>又例如程式 call 到牽連龐大子系統的 function，我們希望在 test 中避免執行到那些複雜的 code（不然很難測或無法測），又要在 prodcution code 裡照常執行到。如果這段 code 有 seam，便能在不改動到原本 call function 的情況下，換掉該 function 的行為來避免在 test 中碰到子系統。</p><p>每個 seam 都有一個 enabling point，在這裡你可以決定使用哪種行為。</p><p>seam 是可以讓你改變程式行為的「縫隙」，enabling point 則是決定那個 seam 要是什麼行為。在 enabling point 給不同的值，可以讓 seam 有不同的行為。例如物件 seam，物件 method 的參數列表是 enabling point，因為我們可以傳入不同的物件來改變程式行為。</p><p>為一團亂的 code 測試時，最好別去修改它本身，盡可能透過 seam 去解開 dependency 來測試。</p><h1 id="Seam-Types"><a href="#Seam-Types" class="headerlink" title="Seam Types"></a>Seam Types</h1><p>seam 有很多種類型。不同的語言，可以使用的類型也不同。一個語言從程式碼轉換到 machine code 的各個階段，擁有不同種類的 seam。</p><ul><li>preprocess 時期 seam<ul><li>在 C/C++ 裡可以用 macro 直接把字換掉來達到改變行為，例如直接把有 dependency 的 function call 用 <code>#define</code> 在 <code>#ifdef TESTING</code> 時換成空的 function。</li><li>enabling point 是 <code>#define TESTING</code></li></ul></li><li>link 時期 seam：在將多個 object file link 起來時的 seam<ul><li>dynamic link：直接換掉 dynamic link 要去找的 library 或 object file。</li><li>static link：透過 build script（像 Makefile），在測試環境去 link 抽換的 object file 而非原本 production code 的 object file。</li><li>enabling point 通常在 build 或 deploy script 裡，因為這時候才決定 link 誰。</li></ul></li><li>object seam<ul><li>一般用 interface、polymorphism 來做 dependency injection，以及 extract and override。</li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Seam-amp-Enabling-Point&quot;&gt;&lt;a href=&quot;#Seam-amp-Enabling-Point&quot; class=&quot;headerlink&quot; title=&quot;Seam &amp;amp; Enabling Point&quot;&gt;&lt;/a&gt;Seam &amp;amp; Enab</summary>
      
    
    
    
    <category term="Working Effectively with Legacy Code" scheme="http://www.cjwind.idv.tw/categories/Working-Effectively-with-Legacy-Code/"/>
    
    
    <category term="Reading" scheme="http://www.cjwind.idv.tw/tags/Reading/"/>
    
    <category term="Unit Test" scheme="http://www.cjwind.idv.tw/tags/Unit-Test/"/>
    
  </entry>
  
  <entry>
    <title>Debian 10 Desktop 中文輸入</title>
    <link href="http://www.cjwind.idv.tw/Debian-10-Desktop-Chinese/"/>
    <id>http://www.cjwind.idv.tw/Debian-10-Desktop-Chinese/</id>
    <published>2020-08-09T06:41:36.000Z</published>
    <updated>2020-08-09T07:10:54.000Z</updated>
    
    <content type="html"><![CDATA[<p>先安裝 ibus：</p><figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">$ sudo apt-<span class="builtin-name">get</span> install ibus ibus-chewing</span><br></pre></td></tr></table></figure><p>在 <code>~/.bashrc</code>  加入：</p><figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line"><span class="builtin-name">export</span> <span class="attribute">GTK_IM_MODULE</span>=ibus</span><br><span class="line"><span class="builtin-name">export</span> <span class="attribute">XMODIFIERS</span>=@im=ibus</span><br><span class="line"><span class="builtin-name">export</span> <span class="attribute">QT_IM_MODULE</span>=ibus</span><br></pre></td></tr></table></figure><p>寫個 shell script：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line">ibus-daemon -d -x</span><br></pre></td></tr></table></figure><p>在 KDE Setting 的 Autostart 設定啟動時執行 shell script 來啟動 ibus</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;先安裝 ibus：&lt;/p&gt;
&lt;figure class=&quot;highlight routeros&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ sudo apt-&lt;span class=&quot;builtin-name</summary>
      
    
    
    
    
    <category term="Linux" scheme="http://www.cjwind.idv.tw/tags/Linux/"/>
    
  </entry>
  
</feed>
