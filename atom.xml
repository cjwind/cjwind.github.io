<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>cjwind&#39;s note</title>
  
  
  <link href="http://www.cjwind.idv.tw/atom.xml" rel="self"/>
  
  <link href="http://www.cjwind.idv.tw/"/>
  <updated>2021-04-17T09:36:31.412Z</updated>
  <id>http://www.cjwind.idv.tw/</id>
  
  <author>
    <name>cjwind</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>ch4 Design Best Practices</title>
    <link href="http://www.cjwind.idv.tw/ch4-Design-Best-Practices/"/>
    <id>http://www.cjwind.idv.tw/ch4-Design-Best-Practices/</id>
    <published>2021-04-17T09:36:31.000Z</published>
    <updated>2021-04-17T09:36:31.412Z</updated>
    
    <content type="html"><![CDATA[<p>這章在講設計 API 的 best practice。</p><h2 id="Designing-for-Real-Life-Use-Cases"><a href="#Designing-for-Real-Life-Use-Cases" class="headerlink" title="Designing for Real-Life Use Cases"></a>Designing for Real-Life Use Cases</h2><p>設計 API 時要以特定的、實際的 use case 進行決策，不要空想。</p><blockquote><p>千萬不要公開內部基礎架構，把焦點放在與外部開發者（或 API 使用者）與 API 的互動體驗上。</p></blockquote><blockquote><p>藉由選擇特定的工作流程或 use case，你可以把重點放在一項設計上，並測試它是否可以幫助你的使用者。</p></blockquote><p>在 brainstorming 階段去想「如果怎樣的話…」是有幫助的，可是到了設計階段，太多的「如果怎樣的話」的想像，反而會讓設計失焦，所以針對特定的 use case 是比較好的。</p><h2 id="Designing-for-a-Great-Developer-Experience"><a href="#Designing-for-a-Great-Developer-Experience" class="headerlink" title="Designing for a Great Developer Experience"></a>Designing for a Great Developer Experience</h2><p>提供開發者好的開發體驗。</p><h3 id="讓-API-能更快、更容易上手"><a href="#讓-API-能更快、更容易上手" class="headerlink" title="讓 API 能更快、更容易上手"></a>讓 API 能更快、更容易上手</h3><p>文件可以幫開發者上手，有 tutorial 跟 getting started guide 也很好。</p><p>也可以提供線上互動式文件、線上的 sandbox 來讓 developer 可以實際測試。</p><p>提供 SDK 也可以幫助 developer 使用 API。</p><p>最後是應該要讓 developer 不需要登入或註冊就能使用 API。如果一定得要註冊，要盡可能減少註冊需要的資料。如果 API 使用 OAuth 保護，那麼應該要能讓 developer 在 UI 中產生 token 以使用 API。</p><h3 id="維持一致性"><a href="#維持一致性" class="headerlink" title="維持一致性"></a>維持一致性</h3><p>像是 entry nmae、request 參數、response 等等，應該要維持一致性，讓 developer 即使不看文件也能猜到部份的 API。</p><blockquote><p>在漸進修改的過程中，盡量與既有的設計模式保持一致，對使用者來說是最好的做法。</p></blockquote><p>不要讓同樣的東西使用不同的名稱。</p><blockquote><p>一致性很重要的原因是它可以減少試著了解你的 API 的 developer 的認知負擔（cognitive load）</p></blockquote><h2 id="Make-Troubleshooting-Easy"><a href="#Make-Troubleshooting-Easy" class="headerlink" title="Make Troubleshooting Easy"></a>Make Troubleshooting Easy</h2><p>藉由回傳有意義的 error 跟 building tool 做到這點。</p><p>設計 API 時應該有系統的組織跟分類錯誤以及他們的回傳方式來方便 developer 排除問題。</p><p>有意義的 error 容易了解、明確而且可以讓人採取行動。它們可以協助 developer 了解問題並處理它。提供這些 error 的 detail 可以帶來較佳的使用者體驗。</p><p>machine-readable 的 error code 字串可以讓 developer 以程式處理錯誤。</p><p>除了 machine-readable 的 error code 之外，也可以加入 human-readable 的敘述，來讓 developer 更了解發生了什麼問題。</p><p>error 要講出具體錯誤的原因，像是「token 因為被撤銷而造成驗證失敗」，用 token_revoked 比 invalid_auth 好。</p><h3 id="幫-error-分類"><a href="#幫-error-分類" class="headerlink" title="幫 error 分類"></a>幫 error 分類</h3><p>將 API request 過程（從 request 開始，到 architecture 的各種 service 邊界）的各種 high-level error 分門別類，例如：</p><p><img src="/images/upload_b00ea4546907b7cbad47aa8c428e31b5.png" alt=""></p><p>按照程式碼路徑將 error 分類後，要考慮對這些 error 而言，採取哪個 level 的 communication 是有意義的。一種方式是在 response payload 中放入 HTTP status code 跟 header，以及 machine-readable 的 code 或更詳細的 human-readable 的錯誤訊息。</p><p>大部分情況下，要盡量具體的說明來讓 developer 採取正確的後續動作。但有些時候，尤其跟安全有關的時候，可能要回傳比較籠統的資訊，不然原始訊息可能會透漏如資料庫 connection 資訊等會引發安全問題的資訊。</p><p><img src="/images/upload_a448184ccb3714b8ef41156e7e2ac580.png" alt=""></p><p>在程式結構上，可以用一套相同的 library 檢查 request 並將 error format 成相同的格式來 response。</p><p>將 error 文件化，像是寫在 API 文件中。</p><p>與 HTTP API 錯誤與問題相關可以參考 <a href="https://tools.ietf.org/html/rfc7807">RFC 7807</a>。</p><h3 id="Build-tooling"><a href="#Build-tooling" class="headerlink" title="Build tooling"></a>Build tooling</h3><p>log HTTP status、error、error 的頻率以及其他 request metadata，好方便在內部或外部進行 debug 或處理問題。</p><p>建立 dashboard 來協助 developer 分析 API request 的 metadata，例如可以統計最常用的 API entry、找出沒被用過的 API 參數、分類常見錯誤等等。</p><p>log 跟 dashboard 都有很多現成的工具。</p><h2 id="Make-Your-API-Extensible"><a href="#Make-Your-API-Extensible" class="headerlink" title="Make Your API Extensible"></a>Make Your API Extensible</h2><p>要擬定 API 的發展策略，讓 API 是可擴展的（extensible）。</p><blockquote><p>API 應該提供可開啟新工作流程的基本元素，而非只是對映你的 app 的工作流程。API 的建立方式決定了 API 的使用者可用他來做什麼事情。如果你提供太低階的操作，可能會讓整合者負擔太多工作。如果你提供太高階的操作，可能會讓大多數的整合只是對應你自己的 app 所作的工作而已。為了實踐創新，你必須找到適當的平衡點，讓使用者能夠啟動不屬於你的 app 或 API 本身的工作流程。</p></blockquote><p>在前後端分離的架構下，要區分內部使用跟對外公開的 API。兩者對於要提供什麼樣的 API 會有不同的考量。</p><p>extensible 的其中一個部份是確保 top partner 有提供 feedback 的機會。要設法 release 某些功能給 top partner 用用看，讓他們給予 feedback。</p><p>在想要用版本管理 API 時，如果早期就加入版本管理系統會比較容易，越晚加入越難實作。版本管理系統的好處在於它可以讓你用新版本進行 breaking changes，同時又能維持就版本的回溯相容性（backward  compatibility）。breaking changes 就是會讓之前使用你的 API 可以正常運作的 app 無法繼續運作的 changes。</p><p>不過，維護版本是需要成本的。如果很多年沒有能力支援舊版本，或者認為 API 不太需要變動，那麼可以不用版本，改用 additive（附加式）變動策略，在單一、穩定的版本中維持 backward compatibility。</p><p>如果預計在「未來任何時刻」都有可能出現 breaking changes 與更新，最好建立版本管理系統。在一開始就建立版本管理系統需要付出的成本比之後迫切需要它的時候才加入低得多。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;這章在講設計 API 的 best practice。&lt;/p&gt;
&lt;h2 id=&quot;Designing-for-Real-Life-Use-Cases&quot;&gt;&lt;a href=&quot;#Designing-for-Real-Life-Use-Cases&quot; class=&quot;headerlink</summary>
      
    
    
    
    <category term="Designing Web Apis" scheme="http://www.cjwind.idv.tw/categories/Designing-Web-Apis/"/>
    
    
    <category term="Reading" scheme="http://www.cjwind.idv.tw/tags/Reading/"/>
    
  </entry>
  
  <entry>
    <title>Postgresql backup &amp; restore command</title>
    <link href="http://www.cjwind.idv.tw/Postgresql-backup-and-restore-command/"/>
    <id>http://www.cjwind.idv.tw/Postgresql-backup-and-restore-command/</id>
    <published>2021-04-16T15:42:31.000Z</published>
    <updated>2021-04-16T15:43:34.450Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Auth"><a href="#Auth" class="headerlink" title="Auth"></a>Auth</h2><p>把 authentication 資訊寫在 <code>~/.pgpass</code>，格式如下：</p><figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line">host:port:<span class="keyword">database</span>:<span class="keyword">user</span>:<span class="keyword">password</span></span><br></pre></td></tr></table></figure><p>在用 <code>pg_dump</code> 跟 <code>psql</code> 時就可以不用輸入密碼。</p><p>當然這個檔案的權限要是 <code>600</code>。</p><h2 id="Backup"><a href="#Backup" class="headerlink" title="Backup"></a>Backup</h2><figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line">$ pg_dump \</span><br><span class="line">    <span class="comment">--dbname=&quot;[DBNAME]&quot; \</span></span><br><span class="line">    <span class="comment">--file=&quot;[FILEPATH]&quot; \</span></span><br><span class="line">    <span class="comment">--inserts --create \</span></span><br><span class="line">    -h [HOST] \</span><br><span class="line">    -p [PORT] \</span><br><span class="line">    -U [<span class="keyword">USER</span>] \</span><br><span class="line">    -w</span><br></pre></td></tr></table></figure><h2 id="Restore"><a href="#Restore" class="headerlink" title="Restore"></a>Restore</h2><figure class="highlight css"><table><tr><td class="code"><pre><span class="line">psql -d <span class="selector-attr">[DBNAME]</span> -f <span class="selector-attr">[SQL_FILE_PATH]</span> -h <span class="selector-attr">[HOST]</span> -<span class="selector-tag">p</span> <span class="selector-attr">[PORT]</span> -U <span class="selector-attr">[USER]</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Auth&quot;&gt;&lt;a href=&quot;#Auth&quot; class=&quot;headerlink&quot; title=&quot;Auth&quot;&gt;&lt;/a&gt;Auth&lt;/h2&gt;&lt;p&gt;把 authentication 資訊寫在 &lt;code&gt;~/.pgpass&lt;/code&gt;，格式如下：&lt;/p&gt;
&lt;figure</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>以 AWS CLI 使用 ECR</title>
    <link href="http://www.cjwind.idv.tw/AWS-ECR/"/>
    <id>http://www.cjwind.idv.tw/AWS-ECR/</id>
    <published>2021-04-04T06:35:13.000Z</published>
    <updated>2021-04-04T06:40:52.592Z</updated>
    
    <content type="html"><![CDATA[<p>ECR 全名是 Elastic Container Registry，是 Amazon 的 docker container registry。</p><p>安裝 AWS CLI 後先 <code>aws configure</code> 設定</p><h2 id="Push"><a href="#Push" class="headerlink" title="Push"></a>Push</h2><ol><li>做個 docker image</li><li>authenticate<br> <code>$ aws ecr get-login-password --region [region] | sudo docker login --username AWS --password-stdin [AWSUserID].dkr.ecr.[region].amazonaws.com</code></li><li>create repository，例如 <code>hello-ecr</code></li><li>幫 image 上 tag，例如 <code>[AWSUserID].dkr.ecr.us-east-2.amazonaws.com/hello-ecr:latest</code></li><li>docker push</li></ol><h2 id="Run"><a href="#Run" class="headerlink" title="Run"></a>Run</h2><p>一樣先 login，接著 <code>docker run</code>，例如：<code>$ docker run [AWSUserID].dkr.ecr.us-east-2.amazonaws.com/hello-ecr:latest</code></p><h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><ul><li><a href="https://docs.aws.amazon.com/zh_tw/cli/latest/userguide/install-cliv2-linux.html">在 Linux AWS CLI 第 2 版 上安裝、更新和解除安裝</a></li><li><a href="https://docs.aws.amazon.com/zh_tw/cli/latest/userguide/cli-configure-files.html#cli-configure-files-methods">組態與登入資料檔案設定</a></li><li><a href="https://docs.aws.amazon.com/AmazonECR/latest/userguide/getting-started-cli.html">搭配 Amazon ECR 使用 AWS CLI</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;ECR 全名是 Elastic Container Registry，是 Amazon 的 docker container registry。&lt;/p&gt;
&lt;p&gt;安裝 AWS CLI 後先 &lt;code&gt;aws configure&lt;/code&gt; 設定&lt;/p&gt;
&lt;h2 id=&quot;P</summary>
      
    
    
    
    
    <category term="AWS" scheme="http://www.cjwind.idv.tw/tags/AWS/"/>
    
  </entry>
  
  <entry>
    <title>Golang method receiver type 的差異</title>
    <link href="http://www.cjwind.idv.tw/Golang-method-receiver-type/"/>
    <id>http://www.cjwind.idv.tw/Golang-method-receiver-type/</id>
    <published>2021-03-28T12:59:58.000Z</published>
    <updated>2021-03-28T13:01:29.693Z</updated>
    
    <content type="html"><![CDATA[<p>在 Go 裡，method 的 receiver 是用 <code>*Obj</code> 還是用 <code>Obj</code> 會有不同的行為。</p><p>來個例子：</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Vertex <span class="keyword">struct</span> &#123;</span><br><span class="line">    X, Y <span class="keyword">float64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v Vertex)</span> <span class="title">Abs</span><span class="params">()</span> <span class="title">float64</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> math.Sqrt(v.X*v.X + v.Y*v.Y)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v Vertex)</span> <span class="title">moveX</span><span class="params">(movement <span class="keyword">float64</span>)</span></span> &#123;</span><br><span class="line">    v.X += movement</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v *Vertex)</span> <span class="title">moveY</span><span class="params">(movement <span class="keyword">float64</span>)</span></span> &#123;</span><br><span class="line">    v.Y += movement</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    v := Vertex&#123;X: <span class="number">10</span>, Y: <span class="number">20</span>&#125;</span><br><span class="line"></span><br><span class="line">    log.Println(v.X, v.Y, v.Abs())<span class="comment">// 10 20 22.360679774997898</span></span><br><span class="line"></span><br><span class="line">    v.moveX(<span class="number">2</span>)</span><br><span class="line">    log.Println(v.X, v.Y, v.Abs())<span class="comment">// 10 20 22.360679774997898</span></span><br><span class="line"></span><br><span class="line">    v.moveY(<span class="number">3</span>)</span><br><span class="line">    log.Println(v.X, v.Y, v.Abs())<span class="comment">// 10 23 25.079872407968907</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>v</code> 可以看成像參數。</p><p>用 <code>Vertex</code> 就是 copy by value，caller 跟 callee 的 <code>Vertex</code> instance 是不同的。</p><p>用 <code>*Vertex</code> 就像 C 語言 pointer 參數，本質上還是 copy by value 但因為是 pointer，所以在 <code>moveY()</code> 中的 <code>v</code> 變成是指向 caller 的那個 <code>Vertex</code> instance。</p><p>基本上 method 會動到 struct 內的 field 內容都會用 pointer。習慣上當有一個 method 的 receiver 是用 pointer 時，所有 method 的 receiver 都會用 pointer。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在 Go 裡，method 的 receiver 是用 &lt;code&gt;*Obj&lt;/code&gt; 還是用 &lt;code&gt;Obj&lt;/code&gt; 會有不同的行為。&lt;/p&gt;
&lt;p&gt;來個例子：&lt;/p&gt;
&lt;figure class=&quot;highlight go&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td </summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Synology NAS Docker private registry</title>
    <link href="http://www.cjwind.idv.tw/Synology-NAS-Docker-private-registry/"/>
    <id>http://www.cjwind.idv.tw/Synology-NAS-Docker-private-registry/</id>
    <published>2021-03-28T08:14:42.000Z</published>
    <updated>2021-03-28T08:29:04.931Z</updated>
    
    <content type="html"><![CDATA[<h2 id="環境"><a href="#環境" class="headerlink" title="環境"></a>環境</h2><ul><li>Synology NAS 型號：DS920+</li><li>DSM 版本：DSM 6.2.4-25556</li></ul><h2 id="建立-Private-Docker-Registry-步驟"><a href="#建立-Private-Docker-Registry-步驟" class="headerlink" title="建立 Private Docker Registry 步驟"></a>建立 Private Docker Registry 步驟</h2><ol><li>download registry image from Docker hub</li><li>start registry container</li><li>ssh 進 NAS</li><li>到 <code>/var/packages/Docker/etc/</code> 編輯 <code>dockerd.json</code></li><li>加入 <code>&quot;insecure-registries&quot;:[&quot;host:port&quot;]</code></li><li>重新啟動 docker <em>（我是把套件停用再啟用啦…）</em></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;環境&quot;&gt;&lt;a href=&quot;#環境&quot; class=&quot;headerlink&quot; title=&quot;環境&quot;&gt;&lt;/a&gt;環境&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;Synology NAS 型號：DS920+&lt;/li&gt;
&lt;li&gt;DSM 版本：DSM 6.2.4-25556&lt;/li&gt;
&lt;/ul</summary>
      
    
    
    
    
    <category term="Docker" scheme="http://www.cjwind.idv.tw/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>Is High Quality Software Worth the Cost?</title>
    <link href="http://www.cjwind.idv.tw/Is-High-Quality-Software-Worth-the-Cost/"/>
    <id>http://www.cjwind.idv.tw/Is-High-Quality-Software-Worth-the-Cost/</id>
    <published>2021-03-11T15:02:56.000Z</published>
    <updated>2021-03-11T15:12:27.182Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://martinfowler.com/articles/is-quality-worth-cost.html">原文</a></p><p>Mindmap 筆記：</p><p><img src="/images/is-high-quality-software-worth-the-cost.png" alt=""></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://martinfowler.com/articles/is-quality-worth-cost.html&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Mindmap 筆記：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/is-high-quality</summary>
      
    
    
    
    
    <category term="Mindmap" scheme="http://www.cjwind.idv.tw/tags/Mindmap/"/>
    
  </entry>
  
  <entry>
    <title>ch3 個人的有氧與訓練能力指標</title>
    <link href="http://www.cjwind.idv.tw/daniels-running-formula/ch3/"/>
    <id>http://www.cjwind.idv.tw/daniels-running-formula/ch3/</id>
    <published>2021-03-07T08:24:58.000Z</published>
    <updated>2021-03-07T08:25:51.608Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/daniels-running-formula/ch3-mindmap.png" alt=""></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;/images/daniels-running-formula/ch3-mindmap.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
</summary>
      
    
    
    
    <category term="丹尼爾博士跑步方程式" scheme="http://www.cjwind.idv.tw/categories/%E4%B8%B9%E5%B0%BC%E7%88%BE%E5%8D%9A%E5%A3%AB%E8%B7%91%E6%AD%A5%E6%96%B9%E7%A8%8B%E5%BC%8F/"/>
    
    
    <category term="Reading" scheme="http://www.cjwind.idv.tw/tags/Reading/"/>
    
    <category term="Mindmap" scheme="http://www.cjwind.idv.tw/tags/Mindmap/"/>
    
    <category term="Running" scheme="http://www.cjwind.idv.tw/tags/Running/"/>
    
  </entry>
  
  <entry>
    <title>ch2 跑步原則與跑步的技術</title>
    <link href="http://www.cjwind.idv.tw/daniels-running-formula/ch2/"/>
    <id>http://www.cjwind.idv.tw/daniels-running-formula/ch2/</id>
    <published>2021-03-07T07:54:23.000Z</published>
    <updated>2021-03-07T07:55:43.929Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/daniels-running-formula/ch2-mindmap.png" alt=""></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;/images/daniels-running-formula/ch2-mindmap.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
</summary>
      
    
    
    
    <category term="丹尼爾博士跑步方程式" scheme="http://www.cjwind.idv.tw/categories/%E4%B8%B9%E5%B0%BC%E7%88%BE%E5%8D%9A%E5%A3%AB%E8%B7%91%E6%AD%A5%E6%96%B9%E7%A8%8B%E5%BC%8F/"/>
    
    
    <category term="Reading" scheme="http://www.cjwind.idv.tw/tags/Reading/"/>
    
    <category term="Mindmap" scheme="http://www.cjwind.idv.tw/tags/Mindmap/"/>
    
    <category term="Running" scheme="http://www.cjwind.idv.tw/tags/Running/"/>
    
  </entry>
  
  <entry>
    <title>ch1 跑者成功的要素</title>
    <link href="http://www.cjwind.idv.tw/daniels-running-formula/ch1/"/>
    <id>http://www.cjwind.idv.tw/daniels-running-formula/ch1/</id>
    <published>2021-03-07T07:45:41.000Z</published>
    <updated>2021-03-07T07:52:50.353Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/daniels-running-formula/ch1-mindmap.png" alt=""></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;/images/daniels-running-formula/ch1-mindmap.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
</summary>
      
    
    
    
    <category term="丹尼爾博士跑步方程式" scheme="http://www.cjwind.idv.tw/categories/%E4%B8%B9%E5%B0%BC%E7%88%BE%E5%8D%9A%E5%A3%AB%E8%B7%91%E6%AD%A5%E6%96%B9%E7%A8%8B%E5%BC%8F/"/>
    
    
    <category term="Reading" scheme="http://www.cjwind.idv.tw/tags/Reading/"/>
    
    <category term="Mindmap" scheme="http://www.cjwind.idv.tw/tags/Mindmap/"/>
    
    <category term="Running" scheme="http://www.cjwind.idv.tw/tags/Running/"/>
    
  </entry>
  
  <entry>
    <title>ch2 API Paradigms</title>
    <link href="http://www.cjwind.idv.tw/Designing-Web-APIs/Designing-Web-APIs-ch2/"/>
    <id>http://www.cjwind.idv.tw/Designing-Web-APIs/Designing-Web-APIs-ch2/</id>
    <published>2021-02-27T10:27:28.000Z</published>
    <updated>2021-02-27T10:28:46.252Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>An API paradigmdefines the interface exposing backend data of a service to otherapplications.</p></blockquote><h2 id="Request-Response-API"><a href="#Request-Response-API" class="headerlink" title="Request-Response API"></a>Request-Response API</h2><p>Request-Response API 通常透過 HTTP web server 來公開 interface。</p><p>這種 API 會定義一些 endpoints，client 對這些 endpoints 發出 HTTP request 來索取資料，server 則給予 response。response 通常是 JSON 或 XML 格式。</p><p>Request-Response API 有三種：</p><ul><li>REST</li><li>RPC</li><li>GraphQL</li></ul><h3 id="REST-Representational-State-Transfer"><a href="#REST-Representational-State-Transfer" class="headerlink" title="REST (Representational State Transfer)"></a>REST (Representational State Transfer)</h3><blockquote><p>REST is all about <em>resource</em>.</p></blockquote><p>resource 是可以在 web 上被 identify、named、addressed 或 handled 的 entity。</p><p>REST API 將資料當成 resource 來 expose 出去，並使用 standard HTTP method 表示 CRUD 的動作。</p><p>REST API 遵循的一般規則：</p><ul><li>resource 是 URL 的一部分，例如 <code>/users</code></li><li>每個 resource 通常有兩個 URL。一個表示 collection，例如 <code>/users</code>。一個表示特定元素，例如 <code>/users/U123</code>。</li><li>resource 使用名詞而非動詞，例如用 <code>/users/U123</code>，而不是 <code>/getUserInfo/U123</code>。</li><li>用 <code>GET</code>、<code>POST</code>、<code>UPDATE</code> 跟 <code>DELETE</code> 等 HTTP method 來告訴 server 要執行的動作。<ul><li>Create<ul><li>用 <code>POST</code> 建立新 resource</li></ul></li><li>Read<ul><li>用 <code>GET</code> 讀取 resource</li><li><code>GET</code> request 永遠不會改變 resource 的狀態，不會有 side effect</li><li><code>GET</code> method 有 read-only 的意思</li><li><code>GET</code> 是 idempotent</li></ul></li><li>Update<ul><li>用 <code>PUT</code> 來 replace resource。</li><li>用 <code>PATCH</code> 來對現有 resource 做部份 update。<a href="http://tools.ietf.org/html/rfc5789">RFC 5789</a></li></ul></li><li>Delete<ul><li>以 <code>DELETE</code> 來刪除現有 resource。</li></ul></li></ul></li><li>server 回傳標準的 HTTP response status code 來表示成功或失敗<ul><li>2XX 代表成功</li><li>3XX 代表 resource 已被移除</li><li>4XX 代表 client 端錯誤</li><li>5XX 代表 server 端錯誤</li></ul></li><li>REST API 可回傳 JSON 或 XML 格式</li></ul><h4 id="Showing-relationships"><a href="#Showing-relationships" class="headerlink" title="Showing relationships"></a>Showing relationships</h4><p>盡量用 subresource 表示只屬於其他 resource 的 resource，不要用 top-level resource 表示它，這樣可以讓使用 API 的 developer 知道它們之間的關係。</p><p>例如 Github 的 API：<code>POST /repos/:owner/:repo/issues</code> 是在某個人的某個 repository 底下建立一個 issue。</p><h4 id="非-CRUD-操作"><a href="#非-CRUD-操作" class="headerlink" title="非 CRUD 操作"></a>非 CRUD 操作</h4><p>有時候 REST API 需要表示非 CRUD 的操作，常見作法如下：</p><ul><li>以 resource 的部份欄位來表示動作（action）<ul><li>例如 Github 要把 repository archive 起來是用 entry <code>PATCH /repos/:owner/:repo</code> 然後 data body 是 <code>&#123;&quot;archived&quot;: true&#125;</code>。因為 <code>PATCH</code> entry 的 request  data body 是 resource 要被更新的欄位，所以才說是以「resource 的部份欄位」來表示動作。</li></ul></li><li>將操作視為 subresource<ul><li>例如 Github 的 lock issue 是 <code>PUT /repos/:owner/:repo/issues/:number/lock</code></li></ul></li><li>有些操作難以用 REST 模式，例如搜尋，這時候通常會在 API URL 直接使用操作的動詞。<ul><li>例如在 Github 中尋找符合 query 的檔案：<code>GET /search/code?q=:query:</code>。</li></ul></li></ul><h3 id="Remote-Procedure-Call-RPC"><a href="#Remote-Procedure-Call-RPC" class="headerlink" title="Remote Procedure Call (RPC)"></a>Remote Procedure Call (RPC)</h3><p>REST 跟 resource 有關，RPC 則跟動作（action）有關。</p><p>RPC 的 client 會在 server 上執行一段 code。client 通常會傳 method name 跟 argument 給 server，然後得到 JSON 或 XML。</p><p>RPC API 通常遵循兩個規則：</p><ul><li>endpoint 含有準備執行的 action 的名稱</li><li>API call 是用最適合的 HTTP verb 來執行：<code>GET</code> 是 read-only request，<code>POST</code> 則是其他。</li></ul><blockquote><p>當 API 公開的動作比 CRUD 封裝的還要細膩且複雜，或是存在與眼前的「資源」無關的 side effect 時，很適合使用 RPC。RPC style 的 API 也可以配合複雜的 resource model，或針對多種類型的 resource 執行的動作。</p></blockquote><p>RPC style 的 API 除了用 HTTP 外也可以用其他 protocol，包括 <a href="https://thrift.apache.org">Apache Thrift</a> 跟 <a href="https://grpc.io/docs/guides/index.html">gRPC</a>。</p><h3 id="GraphQL"><a href="#GraphQL" class="headerlink" title="GraphQL"></a>GraphQL</h3><p><a href="https://graphql.org">https://graphql.org</a></p><p>GraphQL 可以讓 client 端定義需要的 data structure，讓 server 以那個 structure 回傳資料。例如以下是送給 Github API 的 GraphQL query 及其 response：</p><figure class="highlight clojure"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    user(<span class="name">login:</span> <span class="string">&quot;saurabhsahni&quot;</span>) &#123;</span><br><span class="line">        id</span><br><span class="line">        name</span><br><span class="line">        company</span><br><span class="line">        createdAt</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>response：</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;data&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;user&quot;</span>: &#123;</span><br><span class="line">            <span class="attr">&quot;id&quot;</span>: <span class="string">&quot;MDQ6VXNlcjY1MDIS&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;Saurabh Sahni&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;company&quot;</span>: <span class="string">&quot;Slack&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;createdAt&quot;</span>: <span class="string">&quot;2009-03-19T21:00:06Z&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>GraphQL 只需要一個 URL endpoint，而且不需要用不同的 HTTP verb 描述操作，只要在 JSON 內容中寫要做的動作就可以了。</p><h4 id="GraphQL-的優點"><a href="#GraphQL-的優點" class="headerlink" title="GraphQL 的優點"></a>GraphQL 的優點</h4><p>跟 REST 及 RPC 比起來，GraphQL 的優點：</p><ul><li>節省多次 round trip<ul><li>client 可以用 nested query 以一個 request 從多個 resource 取得資料</li><li>以 REST 來說，要取得多個 resource 資料可能需要很多個 request</li></ul></li><li>不需要 versioning<ul><li>在 GraphQL API 增加新的欄位跟 type 不會影響既有的 query</li><li>要 deprecate 一個欄位也很容易：可以用 log 分析 client 用了哪些欄位，在工具中隱藏某些欄位，並且在沒人用的時候移除它們。</li></ul></li><li>較小的 payload<ul><li>因為 client 可以明確指定要什麼資料，所以 payload 可以比較小。</li><li>REST 跟 RPC 常常回傳 client 永遠用不到的資料。</li></ul></li><li>Strongly typed<ul><li>GraphQL 是 strongly typed，它的 type checking 會確保 query 的語法是正確且有效的。</li></ul></li><li>Introspection<ul><li><a href="https://github.com/graphql/graphiql">GraphiQL</a> 這個瀏覽器 IDE 可以寫 GraphQL query 來試驗跟了解 GraphQL API <em>（就是可以直接玩 API 啦）</em></li></ul></li></ul><h4 id="GraphQL-的缺點"><a href="#GraphQL-的缺點" class="headerlink" title="GraphQL 的缺點"></a>GraphQL 的缺點</h4><p>對提供 GraphQL API 的提供者來說，GraphQL 增加了複雜性，server 需要做額外的工作來解析複雜的 query 跟驗證參數。最佳化 GraphQL query 的效能也很麻煩。</p><h3 id="REST-vs-RPC-vs-GraphQL"><a href="#REST-vs-RPC-vs-GraphQL" class="headerlink" title="REST vs RPC vs GraphQL"></a>REST vs RPC vs GraphQL</h3><img src="/images/designing-web-apis/ch2-1.jpg" class="" width="620"><img src="/images/designing-web-apis/ch2-2.jpg" class="" width="620"><h2 id="Event-Driven-API"><a href="#Event-Driven-API" class="headerlink" title="Event-Driven API"></a>Event-Driven API</h2><p>如果 service 的資料常常會改變，用 request-response API 的作法 response 很快會過時，這時候使用 API 的 developer 通常會以 polling 來確保得到最新的資料。但如果 polling 頻率太低，可能會在需要即時更新的狀況下無法即時更新 。而 polling 頻率太高則會浪費資源，因為大部分 request 都不會有新資料。</p><p>要即時分享 event 資料，有三種方式：WebHook、WebSocket 跟 HTTP Streaming。</p><h3 id="WebHook"><a href="#WebHook" class="headerlink" title="WebHook"></a>WebHook</h3><p><strong>WebHook 是個接收 HTTP POST（或 GET、PUT 或 DELETE）的 URL。</strong> 實作 WebHook 的 API provider 會在某些事情發生時 POST 一個訊息給使用者設置好的 URL，例如信用卡授權的 postback。</p><p>提供 WebHook 會引入的複雜性：</p><ul><li>Failures and retries：為了確保資訊成功 deliver，須建立發生錯誤時的 retry 機制。</li><li>Security：使用 WebHook 時，API 使用者要驗證從 WebHook 收到的資料，以確保資料是合法的。</li><li>Firewall：在防火牆後的 app 很難用 WebHook 收資料，得在防火牆上打洞。</li><li>Noise 雜訊：通常一個 WebHook call 都代表一個 event。如果有成千上萬個 event 在短時間內發生而且必須透過單一 WebHook 來傳送，可能會產生雜訊。</li></ul><h3 id="WebSocket"><a href="#WebSocket" class="headerlink" title="WebSocket"></a>WebSocket</h3><blockquote><p>WebSocket is a protocol used to establish a two-way streaming communication channel over a single Transport Control Protocol (TCP) connection.</p></blockquote><p>WebSocket 這個 protocol 通常用在 web client 跟 server 間，有時也會被用來做 server 對 server 的通訊。WebSocket 可以在比較低的 overhead 的情況下開啟 full-duplex 通訊（server 跟 client 可以同時跟對方通訊）。</p><p>WebSocket 是運作在 port 80 或 443 上，所以不用在防火牆上另外開 port 來進行連線與通訊。而且使用 WebSocket 也不像 WebHook 得對 internet 打開一個 HTTP endpoint 來接收 event，相對來說比較安全。</p><p>WebSocket 適合快速、live 的 streaming 以及長時間（long-lived）的 connection。但不見得適合用在行動裝置或者網路不穩定的地方，因為 client 必須有能力維持 connection，connection 斷了 client 就得重新啟動它。</p><h3 id="HTTP-Streaming"><a href="#HTTP-Streaming" class="headerlink" title="HTTP Streaming"></a>HTTP Streaming</h3><p>在 request-response 形式的 HTTP API 裡，client 送出 request 後，會收到一包有限長度的 response。而使用 HTTP Streaming，server 可以透過 client 開啟的 long-lived connection 來持續推送新資料。</p><img src="/images/designing-web-apis/ch2-3.png" class="" width="620"><blockquote><p>To  transmit  data  over  a  persistent  connection  from  server  to  client, there  are  two  options.  The  first  option  is  for  the  server  to  set  the Transfer-Encoding header to chunked. This indicates to clients that data will be arriving in chunks of newline-delimited strings. For typ‐ical application developers, this is easy to parse.<br>Another  option  is  to  stream  data  via  server-sent  events  (SSE).  This option  is  great  for  clients  consuming  these  events  in  a  browser because they can use the standardized EventSource API.</p></blockquote><blockquote><p>HTTP  Streaming  is  easy  to  consume.  However,  one  of  the  issues with  it  is  related  to  buffering.  Clients  and  proxies  often  have  bufferlimits. They might not start rendering data to the application until a threshold is met. Also, if clients want to frequently change what kind of events they listen to, HTTP Streaming might not be ideal because it requires reconnections.</p></blockquote><h3 id="Event-Driven-API-的比較"><a href="#Event-Driven-API-的比較" class="headerlink" title="Event-Driven API 的比較"></a>Event-Driven API 的比較</h3><img src="/images/designing-web-apis/ch2-4.png" class="" width="620"><img src="/images/designing-web-apis/ch2-5.png" class="" width="620"><h2 id="總結"><a href="#總結" class="headerlink" title="總結"></a>總結</h2><p>沒有一體適用的 API paradigm。每種 API paradigm 只適合特定類型的 use case，所以在實際狀況下有可能需要支援多種 paradigm。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;An API paradigmdefines the interface exposing backend data of a service to otherapplications.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;Requ</summary>
      
    
    
    
    <category term="Designing Web Apis" scheme="http://www.cjwind.idv.tw/categories/Designing-Web-Apis/"/>
    
    
    <category term="Reading" scheme="http://www.cjwind.idv.tw/tags/Reading/"/>
    
  </entry>
  
  <entry>
    <title>《原子習慣》</title>
    <link href="http://www.cjwind.idv.tw/Atomic-Habits/"/>
    <id>http://www.cjwind.idv.tw/Atomic-Habits/</id>
    <published>2021-02-16T10:01:51.000Z</published>
    <updated>2021-02-26T01:18:35.776Z</updated>
    
    <content type="html"><![CDATA[<h2 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h2><p><img src="/images/atomic_habits_mindmap1.png" alt=""></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;基本原理&quot;&gt;&lt;a href=&quot;#基本原理&quot; class=&quot;headerlink&quot; title=&quot;基本原理&quot;&gt;&lt;/a&gt;基本原理&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;/images/atomic_habits_mindmap1.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
</summary>
      
    
    
    
    
    <category term="Reading" scheme="http://www.cjwind.idv.tw/tags/Reading/"/>
    
    <category term="Mindmap" scheme="http://www.cjwind.idv.tw/tags/Mindmap/"/>
    
  </entry>
  
  <entry>
    <title>Docker command snippet</title>
    <link href="http://www.cjwind.idv.tw/Docker-command-snippet/"/>
    <id>http://www.cjwind.idv.tw/Docker-command-snippet/</id>
    <published>2021-02-09T12:02:56.000Z</published>
    <updated>2021-02-09T12:19:00.121Z</updated>
    
    <content type="html"><![CDATA[<p>老是失憶……</p><figure class="highlight elixir"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 跑起一個 ubuntu container 並且用 foreground 模式進入 bash</span></span><br><span class="line"><span class="variable">$ </span>sudo docker run -it ubuntu bash</span><br><span class="line"></span><br><span class="line"><span class="variable">$ </span>sudo docker run -d -p [HOST_PORT]<span class="symbol">:</span>[CONTAINER_PORT] --name [CONTAINER_NAME] [IMAGE_NAME]<span class="symbol">:</span>[version]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 停止並移除 container</span></span><br><span class="line"><span class="variable">$ </span>sudo docker rm --force [CONTAINER]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 列出 local 有的 image</span></span><br><span class="line"><span class="variable">$ </span>sudo docker images</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在 Docker Hub 搜尋 image</span></span><br><span class="line"><span class="variable">$ </span>sudo docker search [KEYWORD]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在有 Dockerfile 的資料夾 build Docker image</span></span><br><span class="line"><span class="variable">$ </span>sudo docker build --tag [NAME]<span class="symbol">:</span>[TAG] .</span><br><span class="line"></span><br><span class="line"><span class="comment"># Remove Docker image</span></span><br><span class="line"><span class="variable">$ </span>sudo docker rmi [IMAGE]</span><br><span class="line"></span><br><span class="line"><span class="comment"># Login to a Docker registry</span></span><br><span class="line"><span class="comment"># 如果是 private registry 就要 login 才能 push</span></span><br><span class="line"><span class="variable">$ </span>sudo docker login</span><br><span class="line"></span><br><span class="line"><span class="comment"># Push Docker image</span></span><br><span class="line"><span class="variable">$ </span>sudo docker push [IMAGE_NAME]<span class="symbol">:</span>[TAG]</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;老是失憶……&lt;/p&gt;
&lt;figure class=&quot;highlight elixir&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# 跑起一個 ubuntu conta</summary>
      
    
    
    
    
    <category term="Docker" scheme="http://www.cjwind.idv.tw/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>Readmoo API Go Package</title>
    <link href="http://www.cjwind.idv.tw/Readmoo-API/"/>
    <id>http://www.cjwind.idv.tw/Readmoo-API/</id>
    <published>2021-02-09T08:51:05.000Z</published>
    <updated>2021-02-09T09:30:46.047Z</updated>
    
    <content type="html"><![CDATA[<p>用 Go 寫了個可以讀 Readmoo 的閱讀記錄跟劃線的 package。</p><p>可以從閱讀記錄拿到基本的書籍資料跟劃線。</p><p>細節見 <a href="https://github.com/cjwind/readmoo">Github</a>。</p><p><em>應該要把拿 token 弄得簡單點，現在很手動…</em></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;用 Go 寫了個可以讀 Readmoo 的閱讀記錄跟劃線的 package。&lt;/p&gt;
&lt;p&gt;可以從閱讀記錄拿到基本的書籍資料跟劃線。&lt;/p&gt;
&lt;p&gt;細節見 &lt;a href=&quot;https://github.com/cjwind/readmoo&quot;&gt;Github&lt;/a&gt;。&lt;/p&gt;</summary>
      
    
    
    
    
    <category term="Project" scheme="http://www.cjwind.idv.tw/tags/Project/"/>
    
    <category term="Go" scheme="http://www.cjwind.idv.tw/tags/Go/"/>
    
  </entry>
  
  <entry>
    <title>PhpStorm 快捷鍵</title>
    <link href="http://www.cjwind.idv.tw/PhpStorm-shortcut/"/>
    <id>http://www.cjwind.idv.tw/PhpStorm-shortcut/</id>
    <published>2021-02-05T15:57:41.000Z</published>
    <updated>2021-02-05T15:57:41.634Z</updated>
    
    <content type="html"><![CDATA[<p>我的 keymap 是 Sublime + Jetbrains 部份按鍵 + 自己設再配 vim 的大雜燴</p><ul><li><code>ctrl + shift + p</code>：執行動作（action）</li><li><code>ctrl + p</code>：找檔案</li><li><code>ctrl + r</code>：檔案中找 symbol</li><li><code>ctrl + alt + shift + t</code>：refactor 選單</li><li><code>alt + enter</code>：各種神奇功能(?)</li><li><code>alt + insert</code>：加入各種 code</li><li><code>shift + f6</code>：rename</li><li><code>alt + 1</code>：project browse window</li><li><code>alt + 3</code>：find window</li><li><code>alt + 4</code>：run window</li><li><code>alt + 9</code>：git window</li></ul><p>TBC…</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;我的 keymap 是 Sublime + Jetbrains 部份按鍵 + 自己設再配 vim 的大雜燴&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;ctrl + shift + p&lt;/code&gt;：執行動作（action）&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ctrl + p&lt;/co</summary>
      
    
    
    
    
    <category term="PhpStorm" scheme="http://www.cjwind.idv.tw/tags/PhpStorm/"/>
    
  </entry>
  
  <entry>
    <title>《跑者都該懂的跑步關鍵數據》跑步技術</title>
    <link href="http://www.cjwind.idv.tw/You-should-know-these-running-data/"/>
    <id>http://www.cjwind.idv.tw/You-should-know-these-running-data/</id>
    <published>2021-02-04T15:23:08.000Z</published>
    <updated>2021-03-07T07:50:47.192Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Mindmap-v1"><a href="#Mindmap-v1" class="headerlink" title="Mindmap v1"></a>Mindmap v1</h2><p><img src="/images/20210204_%E3%80%8A%E8%B7%91%E8%80%85%E9%83%BD%E8%A9%B2%E6%87%82%E7%9A%84%E9%97%9C%E9%8D%B5%E6%95%B8%E6%93%9A%E3%80%8B%E8%B7%91%E6%AD%A5%E6%8A%80%E8%A1%93_v1.png" alt=""></p><h2 id="Mindmap-v2"><a href="#Mindmap-v2" class="headerlink" title="Mindmap v2"></a>Mindmap v2</h2><p><img src="/images/20210209_%E3%80%8A%E8%B7%91%E8%80%85%E9%83%BD%E8%A9%B2%E6%87%82%E7%9A%84%E9%97%9C%E9%8D%B5%E6%95%B8%E6%93%9A%E3%80%8B%E8%B7%91%E6%AD%A5%E6%8A%80%E8%A1%93_v2.png" alt=""></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Mindmap-v1&quot;&gt;&lt;a href=&quot;#Mindmap-v1&quot; class=&quot;headerlink&quot; title=&quot;Mindmap v1&quot;&gt;&lt;/a&gt;Mindmap v1&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;/images/20210204_%E3%80%8A%E</summary>
      
    
    
    
    
    <category term="Reading" scheme="http://www.cjwind.idv.tw/tags/Reading/"/>
    
    <category term="Mindmap" scheme="http://www.cjwind.idv.tw/tags/Mindmap/"/>
    
    <category term="Running" scheme="http://www.cjwind.idv.tw/tags/Running/"/>
    
  </entry>
  
  <entry>
    <title>Go Module</title>
    <link href="http://www.cjwind.idv.tw/Golang/Go-Module/"/>
    <id>http://www.cjwind.idv.tw/Golang/Go-Module/</id>
    <published>2021-01-24T09:34:34.000Z</published>
    <updated>2021-01-24T09:35:40.000Z</updated>
    
    <content type="html"><![CDATA[<p>Go 從 1.13 開始支援 Go Module，可以在 <code>GOPATH</code> 以外的地方建立 go project 並進行套件管理。<em>一直覺得 source code 只能放在 <code>GOPATH</code> 裡超阿雜…</em></p><h2 id="建立-project"><a href="#建立-project" class="headerlink" title="建立 project"></a>建立 project</h2><p>在 <code>GOPATH</code> 以外的地方建立一個 directory，並且在其中執行 <code>go mod init</code>：</p><figure class="highlight gradle"><table><tr><td class="code"><pre><span class="line">$ mkdir <span class="keyword">project</span></span><br><span class="line">$ cd <span class="keyword">project</span></span><br><span class="line">$ go mod init github.com<span class="regexp">/cjwind/</span><span class="keyword">project</span></span><br></pre></td></tr></table></figure><p>會產生 <code>go.mod</code> 檔案，它會記錄 Go module 與使用的 Go 版本：</p><figure class="highlight gradle"><table><tr><td class="code"><pre><span class="line">module github.com<span class="regexp">/cjwind/</span><span class="keyword">project</span></span><br><span class="line"></span><br><span class="line">go <span class="number">1.15</span></span><br></pre></td></tr></table></figure><p>接下來在這個 directory 裡進行開發跟 build 就都一樣，重點是現在 source code 不用非得放在 <code>GOPATH</code> 裡啦～</p><h2 id="套件管理"><a href="#套件管理" class="headerlink" title="套件管理"></a>套件管理</h2><p>用 <code>go get</code> 安裝 package 後，會發現在 <code>go.mod</code> 多了一行 <code>require [package] [version]</code>，就表示目前使用的 package 及其 version。</p><p>另外可能會出現 <code>require [package] [version] // indirect</code>，這表示是我們使用的 package 所需要的 package。</p><p>也可以用 <code>go get [package]@[version]</code> 來指定特定的 package version。</p><h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><ul><li><a href="https://blog.golang.org/using-go-modules">Using Go Modules</a></li><li><a href="https://golang.org/ref/mod">Go Modules Reference</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Go 從 1.13 開始支援 Go Module，可以在 &lt;code&gt;GOPATH&lt;/code&gt; 以外的地方建立 go project 並進行套件管理。&lt;em&gt;一直覺得 source code 只能放在 &lt;code&gt;GOPATH&lt;/code&gt; 裡超阿雜…&lt;/em&gt;&lt;/p&gt;
</summary>
      
    
    
    
    
    <category term="Go" scheme="http://www.cjwind.idv.tw/tags/Go/"/>
    
  </entry>
  
  <entry>
    <title>Dockerfile</title>
    <link href="http://www.cjwind.idv.tw/Dockerfile/"/>
    <id>http://www.cjwind.idv.tw/Dockerfile/</id>
    <published>2020-11-21T14:49:58.000Z</published>
    <updated>2020-11-21T14:49:58.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="COPY"><a href="#COPY" class="headerlink" title="COPY"></a>COPY</h2><p><code>COPY</code> 如果 source 是 directory，會 copy directory 的內容，但是 directory 本身不會 copy。</p><p>假設有個資料夾叫 <code>css/</code>，底下有兩個 file <code>foo.css</code> 跟 <code>bar.css</code>。</p><figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">COPY</span><span class="bash"> ./css /workspace/</span></span><br></pre></td></tr></table></figure><p>這樣在 container 裡會變成 <code>/workspace/</code> 底下有 <code>foo.css</code> 跟 <code>bar.css</code>，而不是 <code>/workspace/css/</code> 底下有 <code>foo.css</code> 跟 <code>bar.css</code>。想要是 <code>/workspace/css/</code> 底下有兩個 file 得這樣寫：</p><figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">COPY</span><span class="bash"> ./css /workspace/css</span></span><br></pre></td></tr></table></figure><p>Ref：<a href="https://docs.docker.com/engine/reference/builder/#copy">https://docs.docker.com/engine/reference/builder/#copy</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;COPY&quot;&gt;&lt;a href=&quot;#COPY&quot; class=&quot;headerlink&quot; title=&quot;COPY&quot;&gt;&lt;/a&gt;COPY&lt;/h2&gt;&lt;p&gt;&lt;code&gt;COPY&lt;/code&gt; 如果 source 是 directory，會 copy directory 的內容，但</summary>
      
    
    
    
    
    <category term="Docker" scheme="http://www.cjwind.idv.tw/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>Go json and embedded struct</title>
    <link href="http://www.cjwind.idv.tw/Golang/Go-json-and-embedded-struct/"/>
    <id>http://www.cjwind.idv.tw/Golang/Go-json-and-embedded-struct/</id>
    <published>2020-11-15T14:00:46.000Z</published>
    <updated>2020-11-15T14:09:42.000Z</updated>
    
    <content type="html"><![CDATA[<p>使用 embedded struct 做 json 的 marshal 跟 unmarshal 時，json 欄位會省略 struct embedded 欄位的中間名，以比較簡潔的形式呈現。如果 struct 有寫出欄位名稱，json 欄位就會多那一層。</p><h2 id="使用-embedded-struct"><a href="#使用-embedded-struct" class="headerlink" title="使用 embedded struct"></a>使用 embedded struct</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Serving <span class="keyword">struct</span> &#123;</span><br><span class="line">    Amount <span class="keyword">float64</span></span><br><span class="line">    Unit   <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Food <span class="keyword">struct</span> &#123;</span><br><span class="line">    Name <span class="keyword">string</span></span><br><span class="line">    Serving    <span class="comment">// embedded struct</span></span><br><span class="line">    NutritionInfo</span><br><span class="line">    Comment <span class="keyword">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>marshal 結果：</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;Name&quot;</span>:<span class="string">&quot;Banana&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;Amount&quot;</span>:<span class="number">100</span>,</span><br><span class="line">  <span class="attr">&quot;Unit&quot;</span>:<span class="string">&quot;g&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;Calorie&quot;</span>:<span class="number">0</span>,</span><br><span class="line">  <span class="attr">&quot;Carb&quot;</span>:<span class="number">0</span>,</span><br><span class="line">  <span class="attr">&quot;Fat&quot;</span>:<span class="number">0</span>,</span><br><span class="line">  <span class="attr">&quot;Protein&quot;</span>:<span class="number">0</span>,</span><br><span class="line">  <span class="attr">&quot;Comment&quot;</span>:<span class="string">&quot;&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="不使用-embedded-struct"><a href="#不使用-embedded-struct" class="headerlink" title="不使用 embedded struct"></a>不使用 embedded struct</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Food <span class="keyword">struct</span> &#123;</span><br><span class="line">    Name <span class="keyword">string</span></span><br><span class="line">    Serving Serving    <span class="comment">// not embedded struct</span></span><br><span class="line">    NutritionInfo</span><br><span class="line">    Comment <span class="keyword">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>marshal 結果：</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;Name&quot;</span>:<span class="string">&quot;Banana&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;Serving&quot;</span>:</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">&quot;Amount&quot;</span>:<span class="number">100</span>,</span><br><span class="line">    <span class="attr">&quot;Unit&quot;</span>:<span class="string">&quot;g&quot;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">&quot;Calorie&quot;</span>:<span class="number">0</span>,</span><br><span class="line">  <span class="attr">&quot;Carb&quot;</span>:<span class="number">0</span>,</span><br><span class="line">  <span class="attr">&quot;Fat&quot;</span>:<span class="number">0</span>,</span><br><span class="line">  <span class="attr">&quot;Protein&quot;</span>:<span class="number">0</span>,</span><br><span class="line">  <span class="attr">&quot;Comment&quot;</span>:<span class="string">&quot;&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不用 embeded struct 就會有一層 <code>Serving</code>，用 embedded struct 就會省略 <code>Serving</code> 這層。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;使用 embedded struct 做 json 的 marshal 跟 unmarshal 時，json 欄位會省略 struct embedded 欄位的中間名，以比較簡潔的形式呈現。如果 struct 有寫出欄位名稱，json 欄位就會多那一層。&lt;/p&gt;
&lt;h2 i</summary>
      
    
    
    
    
    <category term="Go" scheme="http://www.cjwind.idv.tw/tags/Go/"/>
    
  </entry>
  
  <entry>
    <title>Git submodule</title>
    <link href="http://www.cjwind.idv.tw/Git-submodule/"/>
    <id>http://www.cjwind.idv.tw/Git-submodule/</id>
    <published>2020-10-08T15:12:57.000Z</published>
    <updated>2020-10-08T15:12:57.000Z</updated>
    
    <content type="html"><![CDATA[<p>submodule 是在 git repos 中使用別的 repos 的方式之一。</p><p>git 的 submodule 是記錄一個指到別人 repo 某個 commit 的指標。對主 repo 來說，記錄的只是一個 submodule commit hash。</p><p>切到 submodule 的目錄時做 git 操作會是在操作另一個 repo。</p><h2 id="加入-submodule"><a href="#加入-submodule" class="headerlink" title="加入 submodule"></a>加入 submodule</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git submodule add &lt;repo path&gt;</span></span><br></pre></td></tr></table></figure><h2 id="clone-含有-submodule-的-repos"><a href="#clone-含有-submodule-的-repos" class="headerlink" title="clone 含有 submodule 的 repos"></a>clone 含有 submodule 的 repos</h2><p>clone 含有 submodule 的 repos 後，submodule 的目錄會是空的，要做以下動作來初始化：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git submodule init</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git submodule update</span></span><br></pre></td></tr></table></figure><p><code>git submodule update</code> 會讓 submodule 的內容回到記錄的 commit。</p><h2 id="更新-submodule"><a href="#更新-submodule" class="headerlink" title="更新 submodule"></a>更新 submodule</h2><p>submodule 的 repo 更新或者想用不同版本（commit）的 submodule 時，要做以下操作：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> submodule_dir</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git pull</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> ..</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git a submodule_dir<span class="comment"># 更新主 repo 記錄的 submodule commit hash</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git ci</span></span><br></pre></td></tr></table></figure><p>概念是把 submodule 的 repo 更新或者 checkout 到想要的 commit，再在主 repo 更新記錄的 submodule commit hash。</p><h2 id="移除-submodule"><a href="#移除-submodule" class="headerlink" title="移除 submodule"></a>移除 submodule</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git rm -rf submodule_dir</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> vim .git/config<span class="comment"># 移掉 submodule 相關設定</span></span></span><br></pre></td></tr></table></figure><h2 id="gitmodules"><a href="#gitmodules" class="headerlink" title=".gitmodules"></a>.gitmodules</h2><p>檔案 <code>.gitmodules</code> 會記錄有哪些 submodule。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;submodule 是在 git repos 中使用別的 repos 的方式之一。&lt;/p&gt;
&lt;p&gt;git 的 submodule 是記錄一個指到別人 repo 某個 commit 的指標。對主 repo 來說，記錄的只是一個 submodule commit hash。&lt;/</summary>
      
    
    
    
    
    <category term="Git" scheme="http://www.cjwind.idv.tw/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>Go init() function</title>
    <link href="http://www.cjwind.idv.tw/Golang/Golang-init-func/"/>
    <id>http://www.cjwind.idv.tw/Golang/Golang-init-func/</id>
    <published>2020-08-29T09:48:15.000Z</published>
    <updated>2021-02-26T14:42:35.572Z</updated>
    
    <content type="html"><![CDATA[<p>任何檔案可以擁有任意數量的 <code>init()</code> function：</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>init()</code> 會在程式啟動時自動以宣告的順序執行，但不能被 call 或參考。</p><p>假設有以下兩個 go 檔案：</p><figure class="highlight go"><figcaption><span>foo.go</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;foo.go first init&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight go"><figcaption><span>main.go</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;main.go first init&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;main.go second init&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 <code>go run</code> 以不同的順序指定 source file 會有不同結果：</p><figure class="highlight maxima"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">go</span> run foo.<span class="built_in">go</span> main.<span class="built_in">go</span></span><br><span class="line">foo.<span class="built_in">go</span> <span class="built_in">first</span> init</span><br><span class="line">main.<span class="built_in">go</span> <span class="built_in">first</span> init</span><br><span class="line">main.<span class="built_in">go</span> <span class="built_in">second</span> init</span><br><span class="line"></span><br><span class="line">$ <span class="built_in">go</span> run main.<span class="built_in">go</span> foo.<span class="built_in">go</span></span><br><span class="line">main.<span class="built_in">go</span> <span class="built_in">first</span> init</span><br><span class="line">main.<span class="built_in">go</span> <span class="built_in">second</span> init</span><br><span class="line">foo.<span class="built_in">go</span> <span class="built_in">first</span> init</span><br><span class="line"></span><br><span class="line"># 不指定 file</span><br><span class="line">$ <span class="built_in">go</span> run .</span><br><span class="line">foo.<span class="built_in">go</span> <span class="built_in">first</span> init</span><br><span class="line">main.<span class="built_in">go</span> <span class="built_in">first</span> init</span><br><span class="line">main.<span class="built_in">go</span> <span class="built_in">second</span> init</span><br></pre></td></tr></table></figure><p>不指定 file 的話 <code>go</code> 會將 file 以其名稱排序。</p><p>如果嘗試直接 call <code>init()</code> 則會 compile error：</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;main.go first init&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    init()  <span class="comment">// compile error: undefined: init</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;任何檔案可以擁有任意數量的 &lt;code&gt;init()&lt;/code&gt; function：&lt;/p&gt;
&lt;figure class=&quot;highlight go&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span cl</summary>
      
    
    
    
    
    <category term="Go" scheme="http://www.cjwind.idv.tw/tags/Go/"/>
    
  </entry>
  
</feed>
