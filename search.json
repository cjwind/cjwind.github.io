[{"title":"2014 年回顧與 2015 年目標","url":"/2014-and-2015/","content":"<p>今年，專業上：</p>\n<ul>\n<li>開了這個 blog</li>\n<li>看完《Effective C++》（跳過 template 就是了，那塊太不熟根本看不懂）</li>\n<li>《深入淺出物件導向分析與設計》一到九章（剩一章，耶！）</li>\n<li>正在看《程式設計師的自我修養──連結、載入、程式庫》</li>\n<li>邊做邊學 Ruby on Rails</li>\n<li>對 C++ 有再熟一點，吧？</li>\n<li>設計架構崩崩中</li>\n<li>有比較會切細工作，吧？</li>\n<li>多會一點 Git</li>\n</ul>\n<p>2015 年目標：</p>\n<ul>\n<li>吃掉《深入淺出物件導向分析與設計》</li>\n<li>啃掉《程式設計師的自我修養──連結、載入、程式庫》</li>\n<li>看《深入淺出設計模式》</li>\n<li>看《Clean Code》<del>（寫到這裡我在想是不是在找死？）</del></li>\n<li>寫個 Ruby Gem</li>\n<li>練習 OOAD</li>\n<li>練習「想清楚再做」跟「避免分析癱瘓」（有時候會一直在那裡想然後做不了決定 X_X）</li>\n<li>找些 open source project 來 follow（好像有點抽象）</li>\n<li>填補理論跟實務之間的空虛地帶（具體上還沒決定，先列些主題）<ul>\n<li>OS</li>\n<li>Compiler</li>\n<li>Multi-Thread Programming</li>\n</ul>\n</li>\n</ul>\n<p>我也不知道寫這些目標會不會照著做，很具體的應該會，寫得越抽象的越容易歪掉就是了。明年底再來看哪些有做到、哪些歪掉、又有什麼是吃飽太閒在亂玩。:P</p>\n","tags":["Murmur"]},{"title":"2014 Google Code Jam Qualification Round","url":"/2014-google-code-jam-qualification-round/","content":"<p>昨天晚上在慵懶的狀態下寫今年 Google Code Jam 資格賽。</p>\n<p>A 跟 B 很簡單，A 就照著算一下，B 簡單 Greedy，看到過 C 的比例比較低先跳過，看 D 覺得要想一下，可是已經在想睡覺……丟了一次很爛的 algo 上去果然 WA，放棄收工了，只要 B 的 large input 有對也是會過，阿要是沒對就 GG 了！XD</p>\n<p>遙想我每次玩 Code Jam 都只有過資格賽……Orz……看今年會不會有鬥志一點，至少兩次時間可以參加的 Round 1 都去玩一下。</p>\n<script src=\"//gist.github.com/596ddacefe38b6f97eea.js?file=2014GCJ_QR_A.cpp\"></script>\n\n<script src=\"//gist.github.com/6aaa4b0c9bc8ea7e05c9.js?file=2014GCJ_QR_B.cpp\"></script>\n\n<p><del>貼這種 code 出來好像在丟人現眼</del></p>\n<p>簡單針對 code 檢討一下好了，algo 沒什麼好檢討的，因為寫的兩題太簡單。</p>\n<ol>\n<li>跟 C++ IO 不熟，才會出現很明顯的 copy。還為了 output 七位小數而混雜 printf()，因為我不會調 C++ 的 output format。<del>比賽的時候懶得查直接用最熟的比較快</del></li>\n<li>變數名稱亂取，<del>不過算了比賽程式不要計較太多</del> XD</li>\n</ol>\n","tags":["Programming Contest"]},{"title":"2014 Google Code Jam Round 1A","url":"/2014-google-code-jam-round-1a/","content":"<p>掛蛋啦哈哈哈哈哈哈哈哈…….Orz…..</p>\n<p>早上八點半爬起來，弄一弄我只剩十分鐘清醒，所以一開始整個沒醒。看了 A 的題目，十幾二十分鐘後，中華電信來弄網路跟 MOD，弄完就十點了，我實在有點想跟他說 MOD 放著不用裝了，依照我們的習性大概也沒人會去開來看。網路弄完，醒了但也只剩 1.5 小時。</p>\n<p>稍微想一下 A，只想到計算 0 跟 1 的個數可以判斷是不是 possible，但是計算次數的部分就還沒想到。後來去看 B，整個覺得我好久沒看這種東西，沒想清楚題目，自以為邊只有三種情況，寫了條件很多的 BFS，寫完 WA 到天邊去，反正掛蛋也沒有 penalty 問題…..(欸)</p>\n<p>平常沒在練習，掛蛋也不是什麼很稀奇的事。下一場 1B 的時間對我來說太爛了（我是作息時間不太工程師的工程師），只好 1C 再戰。</p>\n","tags":["Programming Contest"]},{"title":"2014 Google Code Jam Round 1C","url":"/2014-google-code-jam-round-1c/","content":"<p>沒進，只對 A，不過這是我第一次 R1 破蛋……2013 年掛蛋，2011 年也是，其他年份沒參加。</p>\n<script src=\"//gist.github.com/2a50020d3a0fbdaf5c17.js\"></script>\n\n<p>一整個亂……= =</p>\n<p>考慮過從最遠古的祖先直接建表，但想想覺得應該不行。就變成往回推的判斷：</p>\n<ol>\n<li>若 Q 是奇數，則 impossible。</li>\n<li>若 <code>Q / P = x (x 為整數) = 2 ^ n</code>，則 <code>ans = n</code>。</li>\n<li><code>Q&#39; = Q / 2</code> 直到 <code>Q&#39; &lt; P</code>（記錄除的次數 n），<code>P&#39; = P - Q&#39;</code>，recursive 檢查 <code>P&#39;/Q&#39;</code> 是否可能出現。是則 <code>ans = n</code>，否則 impossible。</li>\n</ol>\n<p>既然有 code 可以檢討還是檢討一下好了。</p>\n<ol>\n<li>看看那精美的 <code>scanf()</code>，又一次 C++ format input/output 不熟。</li>\n<li>邏輯上有方向但細節沒想清楚，像 Q 一直除 2 的時候原本沒先檢查是不是能整除，原本也沒處理處理特殊值 1。</li>\n<li>大測資一開始沒用 <code>long long int</code>，然後就 segementation fault 了。</li>\n</ol>\n","tags":["Programming Contest"]},{"title":"《C++ API 設計》ch2 Qualities","url":"/API-Design-for-Cpp-ch2-note/","content":"<p><em>盡量不要讓看過的書像船過水無痕，嘗試用自己的話做小結。</em></p>\n<p>這章的重點在：What are the basic qualities of a good API?</p>\n<h2 id=\"Model-the-problem-domain\"><a href=\"#Model-the-problem-domain\" class=\"headerlink\" title=\"Model the problem domain\"></a>Model the problem domain</h2><p>API 是用來解決某個問題的，問題可大可小。</p>\n<p><strong>API 要能對問題提供抽象化的概念，並且能夠將這抽象概念以 interface 表達出來。</strong>以 C++ 來說，我的理解是用 class name 以及 function name 表達抽象概念，也就是使用 API 的人應該要能從 class 及 function 看出抽象概念及使用邏輯。</p>\n<p><strong>一個問題沒有絕對正確的抽象化方式，重點是 API 要保有某種一致性及邏輯。</strong></p>\n<p>如果用物件導向來做 modeling 就會用 object modeling，也就是會定出 object、每個 object 做什麼、object 之間的關係與互動。一個 class 應該要定義為「做什麼」（what）而不是「怎麼做」（how）。</p>\n<h2 id=\"Hide-implementation-details\"><a href=\"#Hide-implementation-details\" class=\"headerlink\" title=\"Hide implementation details\"></a>Hide implementation details</h2><p>隱藏所有實作細節。如果沒藏好，以後要改實作，使用者可能跟著改到崩潰然後就不想用你的 API 了。(無誤)</p>\n<p>interface 訂得好，底下怎麼搞都沒關係，改 interface 比較會影響到使用者。</p>\n<p>隱藏實作細節的方法：</p>\n<ul>\n<li>Declaration &amp; Definition<br>盡量在 header 只寫 declaration，implementation 放在 cpp。</li>\n<li>Encapsulation<ul>\n<li>請把 member 藏起來，外面需要它們的話使用 getter &amp; setter。</li>\n<li>隱藏 class 內部才使用的 implementation method 們，API 使用者不需要知道 API 實際上如何實作出功能的。</li>\n<li>隱藏 class 內部才使用的 implementation class 們。</li>\n<li>所謂隱藏就是設成 private。</li>\n</ul>\n</li>\n</ul>\n<p>PS：這裡說的使用者是指使用 API 的人，通常是其他 programmer 或自己，不是使用軟體的一般使用者。</p>\n<h2 id=\"Minimally-complete\"><a href=\"#Minimally-complete\" class=\"headerlink\" title=\"Minimally complete\"></a>Minimally complete</h2><p>API 功能要完整，可以滿足使用者需要的所有功能，要盡可能小但無法再更小了。</p>\n<p>要小心 virtual function 可能會公開過多 function 給使用者。<em>不過我還沒很懂這意思…</em></p>\n<h2 id=\"Easy-to-use\"><a href=\"#Easy-to-use\" class=\"headerlink\" title=\"Easy to use\"></a>Easy to use</h2><p>看到這裡總覺得在軟體設計上到處都有這句話，只是層次不太一樣。在 application 層級上，easy to use 希望的是一般使用者的好用。而在 API 層級上則是針對 API 使用者──通常是 programmer。</p>\n<ul>\n<li>Discoverable<br>使用者光看 API 就能自己心領神會、找出如何使用。</li>\n<li>Difficult to misuse<br>難以誤用，舉例：傳三個 enum Year、Month、Day 當參數比傳三個 int 不容易誤用。<em>《Effective C++》好像說過同樣的話…</em></li>\n<li>Consistent<br><a href=\"/Consistent-API-Design/\">API 設計的一致性</a></li>\n<li>Orthogonal<ul>\n<li>method 之間沒 side effect，例如 call 改變某屬性的 method 不會動到其他屬性。</li>\n<li>修改 API 的部分實作也不會影響到其他部分。</li>\n<li>做法：保持一種資訊只有一個地方有，不要到處 copy-paste code。盡量封裝，避免一個變數到處都可以 access 以致改了 A 可能就動到 B 的行為。</li>\n</ul>\n</li>\n<li>Resource allocation<ul>\n<li>用 smart pointer 管理 memory。</li>\n<li>其他種類的 resource 也可以用 class 加以管理，object 的 construct 是 allocate resource，destruct 則是 release resource，通常稱為 RAII（Resource Acquisition Is Initialization）。舉例：Qt 的 QMutexLocker。</li>\n</ul>\n</li>\n<li>Platform independent<br>避免在公開的 header 用針對特定平台的 <code>#if</code> 跟 <code>#ifdef</code>，例如 <code>#ifdef _WIN32</code>。</li>\n</ul>\n<h2 id=\"鬆散耦合\"><a href=\"#鬆散耦合\" class=\"headerlink\" title=\"鬆散耦合\"></a>鬆散耦合</h2><p>跟 OO 的原則一樣，class 之間、module 之間不要黏太緊。</p>\n<p>簡單看兩個 component A 跟 B 黏得緊不緊的方式是看改了 A 後 B 會不會改很多、A 看得到 B 多少東西（如只看得到 public function 還是也看得到 private member 等等）。</p>\n<p>要避免兩個 component 互相依賴變成 dependency cycle，不然想用 A 就一定要有 B，但邏輯上可能根本不需要 B，看起來就很怪。</p>\n<p>這邊提兩種鬆散耦合的方法：Manager class 跟事件通知。</p>\n<h3 id=\"Manager-class\"><a href=\"#Manager-class\" class=\"headerlink\" title=\"Manager class\"></a>Manager class</h3><p>Manager class 會擁有並管理某些 class，例如與 output 有關的 class。</p>\n<p>如果有一個 Manager class 管理 N 個 output class，其他 M 個 需要使用 output class 的 class 可以不需要跟所有 output class 都有關係（這樣會有 N * M 個關聯），大家可以只跟 Manager class 有關係（只剩 N + M 個關聯），從而降低 outpu class 與其他 class 間的耦合。</p>\n<p><em>原來 Manager class 還有這種功能…</em></p>\n<h3 id=\"事件通知\"><a href=\"#事件通知\" class=\"headerlink\" title=\"事件通知\"></a>事件通知</h3><p>在「某件事發生時需要通知其他人」的情境下，有以下幾種方式可以降低通知者與被通知者的耦合：</p>\n<ul>\n<li>callback<br>C 寫法，使用 function pointer，也可以有很多 callback。</li>\n<li>observer<br><a href=\"/Observer-Pattern/\">Observer Pattern</a></li>\n<li>notification<br>不針對特定事件，比較像整個系統的機制，例如 signal-slot。</li>\n</ul>\n<p>這些方法可以讓通知方與被通知方彼此不需要知道對方是誰，否則雙方得知道對方是誰才能通知，而當兩邊各有很多 class 的時候，那根本是場災難……</p>\n<h2 id=\"相關-note\"><a href=\"#相關-note\" class=\"headerlink\" title=\"相關 note\"></a>相關 note</h2><ul>\n<li><a href=\"/Core-API-and-convenient-API/\">API 的基本功能性及便利性</a></li>\n</ul>\n<h2 id=\"Murmur\"><a href=\"#Murmur\" class=\"headerlink\" title=\"Murmur\"></a>Murmur</h2><p>老覺得跟 OO 的原則很類似，很多概念都有在其他地方看過。不過現在再看，似乎更能配合實際經驗加以理解。</p>\n","tags":["C++","Reading","API"]},{"title":"《C++ API 設計》ch5 API Style","url":"/API-Design-for-Cpp-ch5-note/","content":"<p>API 分很多種 style，各有優缺跟取捨。</p>\n<ul>\n<li>C style</li>\n<li>Object Oriented C++ style</li>\n<li>Template style</li>\n<li>Data driven style</li>\n</ul>\n<p>這種分類方式是以 C/C++ 系列區分，但我覺得在其他語言方面也有類似概念。</p>\n<h2 id=\"C-style\"><a href=\"#C-style\" class=\"headerlink\" title=\"C style\"></a>C style</h2><p>一般 C function 們，通常會用 struct 跟一些命名規則來區別不同功能跟 component 等等。</p>\n<p>類似的東西：PHP 那些 <code>mysql_</code> 開頭的 function 們。</p>\n<h3 id=\"讓-C-可以-call-C-API\"><a href=\"#讓-C-可以-call-C-API\" class=\"headerlink\" title=\"讓 C++ 可以 call C API\"></a>讓 C++ 可以 call C API</h3><p>有時候使用者是用 C++ 開發，而 C style 的 API 希望能給這樣的使用者使用。在此狀況下，C style API 需要：</p>\n<ol>\n<li>C API 可以用 C++ compiler 編過</li>\n<li>用 <code>extern &quot;C&quot;</code> 處理 C++ 與 C 之間 linkage 的問題<br>同樣的 function 在 C compiler 跟 C++ 的 compiler 產生的 object file 中會以不同方式呈現，例如 C++ 有 <code>name decoration</code>，但 C 沒有。因此 C API 得用 extern “C” 包起來，讓 C++ compiler 知道這段應該要用 C style 的 link 方式。</li>\n</ol>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">ifdef</span> __cplusplus</span></span><br><span class=\"line\"><span class=\"keyword\">extern</span> <span class=\"string\">\"C\"</span> &#123;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// C API declaration</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">ifdef</span> __cplusplus</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></span><br></pre></td></tr></table></figure>\n\n<p>實例：<a href=\"/Cpp-uses-C-library-example\">C++ uses C library example</a></p>\n<h2 id=\"Object-Oriented-C-style\"><a href=\"#Object-Oriented-C-style\" class=\"headerlink\" title=\"Object Oriented C++ style\"></a>Object Oriented C++ style</h2><p>以物件導向為基礎的寫法。</p>\n<p>類似的東西：PHP 的 <code>mysqli</code> 物件。</p>\n<h2 id=\"Template-style\"><a href=\"#Template-style\" class=\"headerlink\" title=\"Template style\"></a>Template style</h2><p>以 template 於 compile time 達到 static polymorphism──相同 interface 可支援多種 type，例如 STL。</p>\n<p>相對物件導向的多型是在 runtime 做，使用 template 有較高的執行效率，但 compile 出來的檔案會比較大。因此，相對 code 大小較著重執行效能時可用 template，反之可用物件導向。</p>\n<p>缺點之一是 template 的定義得放在 header，導致使用的程式需一起 compile template 的 header，但仍有些方式可以將 template 定義藏在 .cpp。另外，template 的 compile error 訊息很複雜，無論自己開發有什麼問題或者使用者使用時有何問題，複雜的 error message 讓人蠻頭大的。<em>被害過…但至今還是沒搞懂…(欸)</em></p>\n<h2 id=\"Data-driven-style\"><a href=\"#Data-driven-style\" class=\"headerlink\" title=\"Data driven style\"></a>Data driven style</h2><p>interface 提供非常 general 的 function，實際上做什麼事由 input 決定。interface 大概像這樣：</p>\n<p><code>Result DoCommand(string cmd, ArgList args)</code></p>\n<p><code>Command()</code> 內部 implement 會依據 <code>cmd</code> 決定要做什麼，<code>args</code> 則是對應 command 的參數，<code>Result</code> 則是回傳值。</p>\n<p>例如 web service，使用者丟想做的命令跟參數給 web service，web service 再依據命令及參數回應。</p>\n<p>由於 interface 非常 general，需要相對應的 general 的參數型態來傳這些參數，像上面的 <code>Result</code>。在不強調 data type 的語言（weakly type language）像 python 中很好處理，但在 C++ 裡就要自己寫或用其他 library 提供的了，如 Qt 的 QVariant。</p>\n<p>好處是 API 修改非常彈性，幾乎不需要動到 interface。壞處是單從 interface 看不出 API 提供的功能，因為太 general 了，這時候只能靠文件。</p>\n","tags":["C++","Reading","API"]},{"title":"關於筆記","url":"/About-note-2/","content":"<p>今天看到<a href=\"http://www.buffettism88.com/2015/07/notetoaction.html\" target=\"_blank\" rel=\"noopener\">這篇文章</a>，加上近日對於整理筆記之厭倦，在想到底寫筆記是寫來幹嘛的？</p>\n<p>那篇文章表示不用寫「資訊」，但以學習知識來說，我還是需要一點「重點整理」方便日後查找，尤其是一些從書上看來、稍微消化過但也還沒熟到整個記下來的部分。資訊的確幾乎都可以找 google 大神，但是重新 google 到的資訊可能跟我的印象有出入，還有一些眉眉角角不見得記得，有個地方作為資訊的集中地對我還是有用的。</p>\n<p>只不過，有時候似乎會趨向小時候在課堂上抄寫筆記的狀況，像在抄書。這感覺就怪怪的，有時候分不清楚自己是在抄書還是那真是重點（好吧，我猜如果覺得很厭倦的話大概就是在抄書或者已經不需要寫了）。想著想著發現原來今年初寫過<a href=\"/Murmur-about-note\">筆記這回事</a>。</p>\n<p>以上是跟專業、學習知識有關的「筆記」。至於看其他書啊、聽演講啊之類的，我比較會寫心得感想，像那篇文章所說的第二種筆記。在專業有關的學習上，這種感想會在書裡變眉批，這裡一句、那裡一段的，有時候是疑問，有時候是吐槽(欸?)，但這種亂七八糟的心得就不太會去整理了。</p>\n<p>可能會慢慢增加對於專業領域的想法吧，我對時事或一些事情會有某些想法，但很奇怪，對於自身專業卻不太有自己的想法。</p>\n","tags":["Murmur"]},{"title":"Adapter Pattern","url":"/Adapter-Pattern/","content":"<p><strong>將一個 class 的 interface 轉換成另一個 interface 供其他人使用，讓原本不相容的 interface 可以相容。</strong></p>\n<p>一個轉接頭的概念。</p>\n<h2 id=\"使用情境\"><a href=\"#使用情境\" class=\"headerlink\" title=\"使用情境\"></a>使用情境</h2><p>不想改其他使用 class A 的 code 卻想用 class B 達成相同功能時，以 Adapter 將 class B 的 interface 轉成 class A。</p>\n<p>Adapter 因為受限 Adaptee 的能力，不一定能完美 implement interface 所提供的功能，這種時候通常用文件（就大家講好）或 exception 等等方式處理。之前一直以為 Adpater 要完全 implement interface 提供的功能，遇到受限的狀況就有點 confuse 這樣是不是 adpater…</p>\n<h2 id=\"UML\"><a href=\"#UML\" class=\"headerlink\" title=\"UML\"></a>UML</h2><p><img src=\"/images/adapter_pattern.png\" alt=\"Adapter Pattern (合成)\"></p>\n<p>Client 只知道 Target 的 interface，不知道 Adaptee 的 interface，Class 跟 Adaptee 之間是鬆綁的。如果需要同時使用兩種 interface，Adapater 也可以 implement 多個 Target interface，例如有 Target1 及 Target2 兩個 interface，有些地方原本使用 Target1，後來新寫的 code 使用 Target2，Adapter 同時支援兩者就可以不改動到原有的 code。</p>\n<p>我比較習慣用合成讓 Adapter 使用 Adaptee，有另一種做法是用繼承，沒很懂這樣用的好處跟時機，先記著有這種方式：</p>\n<p><img src=\"/images/adapter_pattern2.png\" alt=\"Adapter Pattern (繼承)\"></p>\n<h2 id=\"跟其他-pattern-比較\"><a href=\"#跟其他-pattern-比較\" class=\"headerlink\" title=\"跟其他 pattern 比較\"></a>跟其他 pattern 比較</h2><ul>\n<li>Adapter 是做 interface 轉換。</li>\n<li>Facade 是為了提供簡單的 interface 讓其他人易於操作 sub system，Adapter 跟 Facade 的差別在「目的」。</li>\n<li>Decorator 是加功能。</li>\n</ul>\n","tags":["Design Pattern"]},{"title":"Linux kernel 5.0 增加 System Call","url":"/Add-system-call-to-linux/","content":"<h2 id=\"Download-kernel-source-code\"><a href=\"#Download-kernel-source-code\" class=\"headerlink\" title=\"Download kernel source code\"></a>Download kernel source code</h2><p>我用的 kernel source code 是從 <code>https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git</code> clone 的，寫這篇的版本是 <code>5.0.0-rc3</code>。</p>\n<figure class=\"highlight elixir\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"variable\">$ </span>git clone <span class=\"symbol\">https:</span>/<span class=\"regexp\">/git.kernel.org/pub</span><span class=\"regexp\">/scm/linux</span><span class=\"regexp\">/kernel/git</span><span class=\"regexp\">/stable/linux</span>.git linux-stable</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Add-system-call\"><a href=\"#Add-system-call\" class=\"headerlink\" title=\"Add system call\"></a>Add system call</h2><p>首先在 kernel source code root 建立一個資料夾 <code>mysyscall/</code>：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> <span class=\"built_in\">cd</span> linux-stable</span></span><br><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> mkdir mysyscall</span></span><br></pre></td></tr></table></figure>\n\n<p>新增 <code>mysyscall/hello.c</code>、加入新的 system call <code>sys_hello()</code>（不可免俗的來 hello world 一下）：</p>\n<figure class=\"highlight c\"><figcaption><span>mysyscall/hello.c</span></figcaption><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;linux/kernel.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\">asmlinkage <span class=\"keyword\">long</span> <span class=\"title\">sys_hello</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span> </span>&#123;</span><br><span class=\"line\">    printk(<span class=\"string\">\"Hello Kernel World!\\n\"</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<a id=\"more\"></a>\n\n<p>新增 <code>mysyscall/Makefile</code> 編譯 <code>hello.c</code>：</p>\n<figure class=\"highlight makefile\"><figcaption><span>mysycall/Makefile</span></figcaption><table><tr><td class=\"code\"><pre><span class=\"line\">obj-y := hello.o</span><br></pre></td></tr></table></figure>\n\n<p>修改 <code>Makefile</code> 下面這行：</p>\n<figure class=\"highlight makefile\"><figcaption><span>Makefile</span></figcaption><table><tr><td class=\"code\"><pre><span class=\"line\">core-y\t\t+= kernel/ certs/ mm/ fs/ ipc/ security/ crypto/ block/</span><br></pre></td></tr></table></figure>\n\n<p>加入 <code>mysyscall/</code>：</p>\n<figure class=\"highlight makefile\"><figcaption><span>Makefile</span></figcaption><table><tr><td class=\"code\"><pre><span class=\"line\">core-y\t\t+= kernel/ certs/ mm/ fs/ ipc/ security/ crypto/ block/ mysyscall/</span><br></pre></td></tr></table></figure>\n\n<p>接下來將 system call 加入 system call header file，在 <code>include/linux/syscalls.h</code> 最下面 <code>#endif</code> 前加入以下這行。</p>\n<figure class=\"highlight c\"><figcaption><span>include/linux/syscalls.h</span></figcaption><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">asmlinkage <span class=\"keyword\">long</span> <span class=\"title\">sys_hello</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span></span>;</span><br></pre></td></tr></table></figure>\n\n<p>最後在 system call table 加入新 entry。我是 64bit，system call table 在 <code>arch/x86/entry/syscalls/syscall_64.tbl</code>。</p>\n<figure class=\"highlight plain\"><figcaption><span>arch/x86/entry/syscalls/syscall_64.tbl</span></figcaption><table><tr><td class=\"code\"><pre><span class=\"line\">330\tcommon\tpkey_alloc\t\t__x64_sys_pkey_alloc</span><br><span class=\"line\">331\tcommon\tpkey_free\t\t__x64_sys_pkey_free</span><br><span class=\"line\">332\tcommon\tstatx\t\t\t__x64_sys_statx</span><br><span class=\"line\">333\tcommon\tio_pgetevents\t\t__x64_sys_io_pgetevents</span><br><span class=\"line\">334\tcommon\trseq\t\t\t__x64_sys_rseq</span><br><span class=\"line\">335\t64\thello\t\t\tsys_hello</span><br></pre></td></tr></table></figure>\n\n<p>加在 64bit 區域的最後面，<code>335</code> 是新 system call 的編號。後面還有 500 多編號的是 32bit 的 system call。</p>\n<h2 id=\"Build-and-install\"><a href=\"#Build-and-install\" class=\"headerlink\" title=\"Build and install\"></a>Build and install</h2><p>改完後當然是 compile 跟安裝啦！</p>\n<figure class=\"highlight elixir\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"variable\">$ </span>make menuconfig       <span class=\"comment\"># 如果之前設定過可以不用</span></span><br><span class=\"line\"><span class=\"variable\">$ </span>make                  <span class=\"comment\"># 可以加 -j N 來平行編譯</span></span><br><span class=\"line\"><span class=\"variable\">$ </span>sudo make modules_install</span><br><span class=\"line\"><span class=\"variable\">$ </span>sudo make install</span><br></pre></td></tr></table></figure>\n\n<p><code>make</code> 後就可以去睡個覺惹～(無誤)</p>\n<h2 id=\"Call-new-system-call\"><a href=\"#Call-new-system-call\" class=\"headerlink\" title=\"Call new system call\"></a>Call new system call</h2><p>經過「build、install、打不開、改一改 config 再 build、還是打不開…」的千山萬水(?)後，終於用新 kernel 成功開機，來用新 system call say hello 吧！</p>\n<figure class=\"highlight c\"><figcaption><span>hello.c</span></figcaption><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;unistd.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;sys/syscall.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">long</span> ret = syscall(<span class=\"number\">335</span>);    <span class=\"comment\">// 335 是剛剛的 system call 編號</span></span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"sys_hello return %d\\n\"</span>, ret);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>執行正常會看到：</p>\n<figure class=\"highlight angelscript\"><table><tr><td class=\"code\"><pre><span class=\"line\">sys_hello <span class=\"keyword\">return</span> <span class=\"number\">0</span></span><br></pre></td></tr></table></figure>\n\n<p>在 kernel 裡用 <code>printk()</code> 印出的訊息可以用指令 <code>dmesg</code>（需要 root 權限）看到：</p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">[</span>    <span class=\"number\">3.211745</span><span class=\"string\">]</span> <span class=\"string\">AVX2</span> <span class=\"string\">version</span> <span class=\"string\">of</span> <span class=\"string\">gcm_enc/dec</span> <span class=\"string\">engaged.</span></span><br><span class=\"line\"><span class=\"string\">[</span>    <span class=\"number\">3.211748</span><span class=\"string\">]</span> <span class=\"string\">AES</span> <span class=\"string\">CTR</span> <span class=\"string\">mode</span> <span class=\"string\">by8</span> <span class=\"string\">optimization</span> <span class=\"string\">enabled</span></span><br><span class=\"line\"><span class=\"string\">[</span>    <span class=\"number\">3.459866</span><span class=\"string\">]</span> <span class=\"attr\">IPv6:</span> <span class=\"string\">ADDRCONF(NETDEV_CHANGE):</span> <span class=\"attr\">ens3:</span> <span class=\"string\">link</span> <span class=\"string\">becomes</span> <span class=\"string\">ready</span></span><br><span class=\"line\"><span class=\"string\">[</span>   <span class=\"number\">81.608954</span><span class=\"string\">]</span> <span class=\"string\">Hello</span> <span class=\"string\">Kernel</span> <span class=\"string\">World!</span></span><br></pre></td></tr></table></figure>\n\n<p>以上是在 Linux kernel 5.0.0 加個新 system call 的方式，基本上 4.x 也差不多（5.0 好像是因為 4.x 版本號太多才跳的…）</p>\n<h2 id=\"所謂的千山萬水-…\"><a href=\"#所謂的千山萬水-…\" class=\"headerlink\" title=\"所謂的千山萬水(??)…\"></a>所謂的千山萬水(??)…</h2><p>數不清重編又重開了幾次……</p>\n<p>kernel 的 config 我是用原本系統裡，為了縮短編譯時間再 <code>make menuconfig</code> 拔掉很多不需要的設定，畢竟只是用個 VM 編那麼多硬體 driver 是要幹嘛……但拔到不該拔的就打不開啦哈哈哈……</p>\n<p>再來是我想在 host OS 上 build、裝進 VM 裡開，試圖搬 kernel、system map、module 然後做 initramfs，但不知為何這麼幹就是開不起來，同樣的 code 在 VM build 然後 install 就開起來了……應該是裝的時候有東西沒弄好……Orz</p>\n<p>最後……先 NFS 吧～（喂</p>\n","tags":["Linux","System Software"]},{"title":"Amdahl's law","url":"/Amdahl-s-law/","content":"<p>提升系統某部份效能（減少執行時間）時，對系統整體的影響取決於該部份佔系統的比重以及其效能提升的程度。</p>\n<p>某個程式原本的執行時間是 <code>T</code>，效能提升後執行時間為 <code>T&#39;</code>。其中某部份程式的執行時間為 <code>t</code>、其佔全部執行時間的比例為 <code>a = t / T</code>。假設此部份提升效能後的執行時間為 <code>t&#39;</code>，即該部份效能提升為 <code>k = t / t&#39;</code>，則整個程式的效能提升為：</p>\n<p><code>S = T / T&#39; = 1 / ((1 - a) + a / k)</code></p>\n<p>是個蠻直覺的定理。在 <a href=\"/performance-of-concurrency/\">Performance of Concurrency</a> 有寫過，這篇是比較 general 的版本。</p>\n"},{"title":"C++ 宣告 data members 為 private","url":"/C++-declare-data-members-private/","content":"<p>應將 member data 宣告為 private，以 public member function 存取 member data。如此可透過 member function 做細微的 access control，例如以只有 get function 沒有 set function 實作 read-only 的性質。</p>\n<p>將 member data 宣告為 private 也提升它的封裝性。一個元件的封裝性跟其內容改變時需修改的 code 量成反比，需修改的 code 越多表示封裝性越低。例如修改一 member data 的名稱時，需要檢查所有 code？還是繼承架構中的 code？還是該 class 的 code？</p>\n<p>要注意在 class 提供外界使用並可供繼承時（如 framework、library 的 class），protected 不比 public 來得更有封裝性，兩者幾乎不相上下。雖然 protected member data 的使用範圍僅限於繼承體系，但由於公開給他人使用，使用該 member 的 code 數量跟直接 public 給他人使用沒什麼區別。<em>（就是都很多啦！）</em></p>\n<h2 id=\"Ref\"><a href=\"#Ref\" class=\"headerlink\" title=\"Ref\"></a>Ref</h2><ul>\n<li>《Effective C++》item 22 Declare data members private</li>\n</ul>\n","tags":["C++","Programming"]},{"title":"C pointer to pointer","url":"/C-pointer-to-pointer/","content":"<p><code>Object **self</code> 是 C 語言的 pointer to pointer，常用在想在 callee 操作 caller 的資料。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Object</span> &#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> a, b;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Object</span> <span class=\"title\">Obejct</span>;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">init_object</span><span class=\"params\">(Object **self)</span> </span>&#123; <span class=\"comment\">// call-by-value</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"literal\">NULL</span> == (*self = <span class=\"built_in\">malloc</span>(<span class=\"keyword\">sizeof</span>(Object)))) </span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">    (*self)-&gt;a = <span class=\"number\">0</span>; </span><br><span class=\"line\">    (*self)-&gt;b = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">int</span> argc, <span class=\"keyword\">char</span> *argv[])</span> </span>&#123;</span><br><span class=\"line\">    Object *o = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    init_object(&amp;o);</span><br><span class=\"line\">    o-&gt;a = <span class=\"number\">9922</span>; </span><br><span class=\"line\">    o-&gt;b = <span class=\"number\">5566</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"/images/c_pointer_to_pointer.jpg\" alt=\"C Pointer to pointer\"></p>\n<p>C 語言是 call by value， <code>self</code> 的 value 是 <code>&amp;o</code> 的 value，也就是 <code>o</code> 的 address。在 <code>init_object()</code> 對 <code>self</code>  dereference、用 <code>*self</code> 操作等同用 <code>o</code> 操作，所以 <code>*self = malloc(sizeof(Object))</code> 等同讓 <code>o</code> 指向新 allocate 出來的 memory，而 <code>(*self)-&gt;a</code> 等同 <code>o-&gt;a</code> 。<code>o</code> 是個 <code>Object</code> 的 pointer， <code>o-&gt;a</code> 是它指向的 <code>Object</code> 的 field <code>a</code>，<code>(*self)-&gt;a = 0</code> 是在初始化 <code>main()</code> 中 <code>o</code> pointer 指向的 <code>Object</code>。</p>\n<p>如果不使用 pointer to pointer，像下面這樣會發生什麼事？</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">init_object</span><span class=\"params\">(Object *self)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"literal\">NULL</span> == (self = <span class=\"built_in\">malloc</span>(<span class=\"keyword\">sizeof</span>(Object)))) </span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">    self-&gt;a = <span class=\"number\">0</span>; </span><br><span class=\"line\">    self-&gt;b = <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">int</span> argc, <span class=\"keyword\">char</span> *argv[])</span> </span>&#123;</span><br><span class=\"line\">    Object *o = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    init_object(o);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>這時候 <code>self</code> 的 value 是 <code>o</code> 的 value，也就是 <code>NULL</code>。在 <code>init_object()</code> 裡 <code>self</code> 是個 local variable，allocate 一塊 <code>Object</code> 大小的 memory 給它以及其他操作都不會如我們希望的影響到 <code>main()</code> 裡的 <code>o</code> 。</p>\n","tags":["C"]},{"title":"C 語言 stringify 技巧","url":"/C-stringify/","content":"<p>一般 <code>#define</code> macro 不會將 parameter 展開成字串，只會把 parameter 放到對應位置，例如：</p>\n<figure class=\"highlight xml\"><figcaption><span>php</span></figcaption><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"php\"><span class=\"meta\">&lt;?php</span></span></span><br><span class=\"line\"><span class=\"php\"><span class=\"keyword\">echo</span> <span class=\"string\">\"Hello world\"</span>;</span></span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> ECHO(str) printf(<span class=\"meta-string\">\"%s\\n\"</span>, str)</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">char</span> s[] = <span class=\"string\">\"hello\"</span>;</span><br><span class=\"line\">    ECHO(s);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>經過 preprocess：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ cpp stringify.c</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">char</span> s[] = <span class=\"string\">\"hello\"</span>;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"%s\\n\"</span>, s);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>如果在 parameter 前加 <code>#</code>，preprocessor 會把 actual argument 變成字串，稱為 <a href=\"https://gcc.gnu.org/onlinedocs/cpp/Stringizing.html\" target=\"_blank\" rel=\"noopener\">Stringizing</a>。用個例子說明：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> ECHO(str) printf(<span class=\"meta-string\">\"%s\\n\"</span>, #str)</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">char</span> s[] = <span class=\"string\">\"hello\"</span>;</span><br><span class=\"line\">    ECHO(s);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>經過 preprocess（只是例子，code 本身不太 make sense）：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">char</span> s[] = <span class=\"string\">\"hello\"</span>;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"%s\\n\"</span>, <span class=\"string\">\"s\"</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>Linux kernel 使用這個技巧將 macro 展開成字串。</p>\n<p><code>__stringify</code> 定義在 <a href=\"https://elixir.bootlin.com/linux/v4.19/source/include/linux/stringify.h\" target=\"_blank\" rel=\"noopener\"><code>include/linux/stringify.h</code></a>：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> __stringify_1(x...)\t#x</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> __stringify(x...)\t__stringify_1(x)</span></span><br></pre></td></tr></table></figure>\n\n<p>為什麼 <code>__stringify</code> 要 define 兩次呢？</p>\n<p>在 <a href=\"https://gcc.gnu.org/onlinedocs/cpp/Argument-Prescan.html\" target=\"_blank\" rel=\"noopener\">Argument Prescan</a> 提到 macro 的參數如果也是 macro，一般在被替換進 macro body 前就會被展開，但如果是 stringized 則不會被展開。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> __stringify_1(x...) #x</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> __stringify(x...)   __stringify_1(x)</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> FOO bar</span></span><br><span class=\"line\"></span><br><span class=\"line\">__stringify_1(FOO)        <span class=\"comment\">// become \"FOO\"</span></span><br><span class=\"line\">__stringify(FOO)          <span class=\"comment\">// become \"bar\"</span></span><br></pre></td></tr></table></figure>\n\n<p>這例子裡 <code>__stringify_1(FOO)</code> 因為是 stringized 的 macro 參數，所以 <code>FOO</code> 不會被展開，macro 替換後最後變成 <code>&quot;FOO&quot;</code>。而 <code>__stringify(FOO)</code> 會先展開 <code>FOO</code> 並替換，變成 <code>__stringify_1(bar)</code>，接著再 scan 一次將 macro 展開為 <code>&quot;bar&quot;</code>。</p>\n<p><code>__stringify</code> define 兩次是為了讓參數可以使用 macro。像上面的例子，通常期望 <code>__stringify(FOO)</code> 得到 <code>&quot;bar&quot;</code> 而非 <code>&quot;FOO&quot;</code>。</p>\n<p><code>...</code> 是跟 function 一樣的不定參數，可參考 <a href=\"https://gcc.gnu.org/onlinedocs/cpp/Variadic-Macros.html\" target=\"_blank\" rel=\"noopener\">Variadic Macros</a>。</p>\n","tags":["Linux","C"]},{"title":"Cargo project basic","url":"/Cargo-project-basic/","content":"<h2 id=\"Cargo-basic\"><a href=\"#Cargo-basic\" class=\"headerlink\" title=\"Cargo basic\"></a>Cargo basic</h2><p>Cargo 是 <a href=\"https://www.rust-lang.org/en-US/index.html\" target=\"_blank\" rel=\"noopener\">Rust</a> 的 build &amp; package management system，通常會用 Cargo 管理 Rust project。<a href=\"https://www.rust-lang.org/en-US/install.html\" target=\"_blank\" rel=\"noopener\">安裝 Rust</a> 會一起裝 Cargo。</p>\n<p>這跟 npm、bower、composer 等等 package manager 很像，不過為 Rust 需要 compile，所以 Cargo 除了 package management 還有 build system。package manager 是為了解決各種 library 或 package dependency 的問題，例如像 C/C++ 得自己處理如何 build 跟 link library（還會有只剩 binary 檔不知道 source code 從哪來的 library）、維持 library 版本以及升級 library 等問題。</p>\n<p>Cargo 裡稱 package 或 library 為 crate。</p>\n<p>Cargo 基本指令：</p>\n<figure class=\"highlight elixir\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"variable\">$ </span>cargo build</span><br><span class=\"line\"><span class=\"variable\">$ </span>cargo run</span><br><span class=\"line\"><span class=\"variable\">$ </span>cargo clean</span><br><span class=\"line\"><span class=\"variable\">$ </span>cargo update  <span class=\"comment\"># 升級 crate</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Start-new-project\"><a href=\"#Start-new-project\" class=\"headerlink\" title=\"Start new project\"></a>Start new project</h2><p><code>$ cargo new &lt;project name&gt; --bin</code></p>\n<p>產生基本 project 的 directory，內含 <code>src/</code> 跟 <code>Cargo.toml</code> 並且建立 git repository。加 <code>--bin</code> 是為了 build 出可執行檔，不加會是 library。建立 project 後修改 <code>Cargo.toml</code> 即可，<code>Cargo.toml</code> sample：</p>\n<figure class=\"highlight ini\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"section\">[package]</span></span><br><span class=\"line\"><span class=\"attr\">name</span> = <span class=\"string\">\"rust-hello-cargo\"</span></span><br><span class=\"line\"><span class=\"attr\">version</span> = <span class=\"string\">\"0.1.0\"</span></span><br><span class=\"line\"><span class=\"attr\">authors</span> = [<span class=\"string\">\"cjwind &lt;cwentsai@gmail.com&gt;\"</span>]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"section\">[dependencies]</span></span><br></pre></td></tr></table></figure>\n\n\n<h2 id=\"Directory-structure\"><a href=\"#Directory-structure\" class=\"headerlink\" title=\"Directory structure\"></a>Directory structure</h2><figure class=\"highlight reasonml\"><table><tr><td class=\"code\"><pre><span class=\"line\">src/    # source code directory</span><br><span class=\"line\">    xxx.rs</span><br><span class=\"line\"><span class=\"module-access\"><span class=\"module\"><span class=\"identifier\">Cargo</span>.</span></span>toml    # Cargo configuration</span><br><span class=\"line\"><span class=\"module-access\"><span class=\"module\"><span class=\"identifier\">Cargo</span>.</span></span>lock    # Cargo uses the <span class=\"module-access\"><span class=\"module\"><span class=\"identifier\">Cargo</span>.</span></span>lock file <span class=\"keyword\">to</span> keep track <span class=\"keyword\">of</span> dependencies</span><br></pre></td></tr></table></figure>\n\n<p>Cargo 會自己維護 <code>Cargo.lock</code>，不須手動修改。</p>\n<h3 id=\"Cargo-toml\"><a href=\"#Cargo-toml\" class=\"headerlink\" title=\"Cargo.toml\"></a>Cargo.toml</h3><p>Cargo 用 <code>Cargo.toml</code> 來 maintain dependency──需要什麼 crate 以及 crate 版本。這跟 nodejs、PHP 之類的 package management 差不多，只是各自用不同格式而已。</p>\n<p>修改 <code>Cargo.toml</code> 之後再 build，Cargo 會去抓需要的 crate 跟處理 dependency──如果 crate 還有 depend 是 project 沒有的也會去抓──然後 compile 它們。</p>\n<h3 id=\"Cargo-lock\"><a href=\"#Cargo-lock\" class=\"headerlink\" title=\"Cargo.lock\"></a>Cargo.lock</h3><p>假設 project 依賴 crate A 1.0.12，crate A 有新版本 1.0.13 時會怎樣？</p>\n<p>如果 Cargo 自動更新 crate 版本，萬一新版 crate A 反而讓我們的程式爛掉怎麼辦？畢竟總是可能有 bug 的，又或者某些介面或功能被修改了、行為跟原本不一樣也可能造成問題。</p>\n<p>Cargo 對此的解決方式跟其他 package manager 差不多──使用 <code>Cargo.lock</code>。</p>\n<p>第一次 build project 的時候（應該是 dependency 改動過後的第一次），Cargo 會在 <code>Cargo.lock</code> 記下當下 crate 的版本並且認定這些版本是 ok 的。之後即使 crate 有新版本，Cargo 也不會主動去更新而是以 <code>Cargo.lock</code> 記錄的為準，直到我們要求升級 crate。</p>\n<p><code>cargo update</code> 預設只會升最後一碼版號，比較大版本的升級要手動改 <code>Cargo.toml</code>。因為大版本的更新可能會有 interface 的改動，需要我們確認相應修改沒問題才能更新。</p>\n<h2 id=\"延伸閱讀\"><a href=\"#延伸閱讀\" class=\"headerlink\" title=\"延伸閱讀\"></a>延伸閱讀</h2><ul>\n<li><a href=\"http://semver.org/\" target=\"_blank\" rel=\"noopener\">Semantic Versioning</a></li>\n</ul>\n","tags":["Rust"]},{"title":"Class Diagram","url":"/Class-Diagram/","content":"<p>class diagram 只是個概觀，不會說明所有細節（例如如何實作），可以為需要建立的 class 進行 modeling。</p>\n<p>用一張圖解釋：</p>\n<img src=\"/images/class_diagram_ex.png\" class=\"\" width=\"800\">\n\n\n<h1 id=\"class-間的關係\"><a href=\"#class-間的關係\" class=\"headerlink\" title=\"class 間的關係\"></a>class 間的關係</h1><p>抽象上來看 class 之間的關係，程式語言裡不見得有對應的語法，但是釐清抽象上的關係有助寫 code。只要對系統來說是合理的，class 間的關係可能因為系統的演進而改變。</p>\n<p>association 是 class 間的關係，aggregation 及 composition 則是更特定的關係。</p>\n<p>關聯強度：composition &gt; aggregation &gt; association</p>\n<h2 id=\"Association\"><a href=\"#Association\" class=\"headerlink\" title=\"Association\"></a>Association</h2><p>class 間有關係但關聯性較弱。</p>\n<p>UML 以一條線表示：</p>\n<p><img src=\"/images/association.png\" alt=\"Association\"></p>\n<h2 id=\"Aggregation\"><a href=\"#Aggregation\" class=\"headerlink\" title=\"Aggregation\"></a>Aggregation</h2><p>class 間是 <strong>has a</strong> 的關係。</p>\n<p>main object 不負責 composed object 的 create 及 destroy，composed object 可以獨立於 main object 之外。例如車子跟輪胎間的關係（Car has a Tire），輪胎可以獨立於車子之外（可以從車子上拆下來）。</p>\n<p>UML 以空心菱形表示：</p>\n<p><img src=\"/images/aggregation.png\" alt=\"Aggregation\"></p>\n<h2 id=\"Composition\"><a href=\"#Composition\" class=\"headerlink\" title=\"Composition\"></a>Composition</h2><p>class 間是 <strong>own</strong> 的關係。<del>（碎念：own 跟 has 根本沒辦法用中文區分…）</del></p>\n<p>main object own composed object.</p>\n<p>composed object 是 main object 的一部分（a part of），composed object 不會獨立存在於 main object 之外。main object 負責 composed object 的 create 及 destroy，main object destroy 時 composed object 也會 destroy。例如生物跟細胞間的關係（Animal owns Cell）。</p>\n<p>UML 以實心菱形表示：</p>\n<p><img src=\"/images/composition.png\" alt=\"Composition\"></p>\n<p>composition 跟 aggregation 最大的不同在於 composed object 的生命週期是否與 main object 有關。</p>\n","tags":["OOAD"]},{"title":"Codeception module yii2 event tester","url":"/Codeception-module-yii2-event-tester/","content":"<p>在<a href=\"/test-event/\">如何測試 event</a> 裡提到 event 的測試有兩個方面，其中之一是測試 event 是否有被正確 trigger，有些 test framework 有檢驗 event 是否 trigger（或稱 emit）的驗證。（我應該是在某個 js test framework 看到的）</p>\n<p>現在工作是用 <a href=\"https://www.yiiframework.com/\" target=\"_blank\" rel=\"noopener\">Yii</a> 這套 PHP framework，配合的 test framework 是 Codeception。</p>\n<p>Yii2 有它的 <a href=\"https://www.yiiframework.com/doc/guide/2.0/en/concept-events\" target=\"_blank\" rel=\"noopener\">Event</a> 機制，看了下 <a href=\"https://codeception.com/\" target=\"_blank\" rel=\"noopener\">Codeception</a> 的 Yii2 module 沒有提供 event trigger 的驗證，上星期無聊就自己寫了個 <a href=\"https://github.com/cjwind/codeception-yii2-event-tester\" target=\"_blank\" rel=\"noopener\">codeception-yii2-event-tester</a> 啦。 </p>\n<p>實作方面沒什麼困難，都在搞怎麼包 composer package 跟搞定 Travis。</p>\n","tags":["Codeception","Yii2","PHP","Testing"]},{"title":"Cohesion 內聚力","url":"/Cohesion/","content":"<blockquote>\n<p>A cohensive class does one thing really well and does not try to do or be something else.</p>\n</blockquote>\n<p>來來來翻譯一下：一個 class 只做一件事，不會插手做別人的事。</p>\n<p>但是，這「一件事」的大小跟規模是由設計的人定義的，可以很大也可以很小，定義清楚即可。</p>\n<p>class 內聚力越高，class 間的耦合度（改動一個 class 就要改動其他 code 的程度）越低，越容易 reuse 及擴展。</p>\n<p>讓一個 class 只做一件事，只有那件事情需要修改時才會讓這個 class 改變。這樣每次修改的影響範圍可以縮小，可能產生 bug 的範圍也就縮小啦。另一個好處是 debug 的時候，programmer 可以較迅速的知道可能出問題的範圍，降低時間成本。</p>\n<p>檢查內聚力的方式：做一項改變時是否牽動到許多 class？是的話表示內聚力低、耦合度高，程式不易修改跟擴充。</p>\n","tags":["OOAD"]},{"title":"Commonality and Variability","url":"/Commonality-and-Variability/","content":"<p>commonality（共通性）跟 variability（變化性）算是觀念，可以套用到軟體開發的不同階段。</p>\n<p>在釐清客戶需求的階段，commonality 可以想成軟體「像」什麼，也就是系統需要做的事。variability 則是軟體「不像」什麼，即系統不用處理的事。透過釐清系統像什麼、不像什麼，來了解客戶心中想要的系統究竟要做什麼事。</p>\n<p>到了 design 及 implement 階段，分析 class 間的 commonality，可以將共同的部分抽到 base class。</p>\n","tags":["OOAD"]},{"title":"Composite Pattern","url":"/Composite-Pattern/","content":"<p><strong>讓使用者將物件合成為樹狀結構，呈現「部分/整體」的階層關係。如此可讓使用的程式以相同的方式處理單獨或合成的物件。</strong><del>這句話沒解釋的話根本看不懂吧……</del></p>\n<p>讓樹狀結構的 node 都是同樣的 interface，因而可以用相同的方式（相同的 interface）操作 subtree root node（合成物件）以及操作 leaf node（單獨物件）。</p>\n<h2 id=\"UML\"><a href=\"#UML\" class=\"headerlink\" title=\"UML\"></a>UML</h2><p><img src=\"/images/composite_pattern.png\" alt=\"Composite Pattern\"></p>\n<p><code>Composite</code> 就是 tree 中非 leaf 的 node。<code>Client</code> 可以透過 <code>Component</code> interface 同時操作 leaf node 及 subtree node。</p>\n<p>這做法會讓 <code>Leaf</code> 繼承一些它不需要的 function 如 <code>getChild()</code>。實作上可以在 <code>Component</code> class 將 function 們的 default 行為 implement 成「不 support 此操作」，由 <code>Composite</code> 跟 <code>Leaf</code> override 對其有意義的 function。至於「不 support 此操作」的實作方式可以是丟出 exception、印 log、return false 等等……</p>\n<h2 id=\"設計取捨\"><a href=\"#設計取捨\" class=\"headerlink\" title=\"設計取捨\"></a>設計取捨</h2><p><code>Component</code> interface 包含對 leaf node 沒意義、對 subtree root node 才有意義的操作，就這個 interface 來看包含了兩種責任，操作 leaf node 與操作 subtree root node，不符合 class 單一責任的設計原則。不過呢，這就是設計上的取捨，以單一責任交換能統一操作 tree 中的 node，實際使用上就是要看情境決定哪一個比較重要。</p>\n<h2 id=\"似曾相識的-fu\"><a href=\"#似曾相識的-fu\" class=\"headerlink\" title=\"似曾相識的 fu (?)\"></a>似曾相識的 fu (?)</h2><p>範例程式生一堆 Component 又 add 來 add 去，看著看著總覺得跟 Qt 的 QStandardItem 寫法很像。看了下 Qt 的 code，<code>QStandardItem</code> 不像是用 composite pattern，應該是打從一開始就定義 item 是個可以有 child 的東西了。</p>\n<p><del>這也是為什麼上一篇是用 QStandardItem 當例子…</del></p>\n","tags":["Design Pattern"]},{"title":"Concurrency and Parallelism","url":"/Concurrency-and-Parallelism/","content":"<h2 id=\"Concurrency-vs-Parallelism\"><a href=\"#Concurrency-vs-Parallelism\" class=\"headerlink\" title=\"Concurrency vs Parallelism\"></a>Concurrency vs Parallelism</h2><p>concurrency 是如何拆分程式成多個獨立的工作，讓這些工作可以一起「正在進行（in progress）」但不一定要「同時執行」。「正在進行」是多個工作可以輪流到 CPU（或者 core）上執行，雖然不是同時執行但這些工作都是正在進行中的。而 parallelism 則是多個工作「同時執行」，也就是實際上必須要有多個 core 能同時執行工作。</p>\n<p>打個比方，有一個廚師要煮一頓飯，他「同時」（實際上是輪流，廚師不會分身術）洗菜、切菜、炒菜跟煮湯，這是 concurrency，把煮一頓飯分成四個工作。現在<del>廚師會分身術</del>喔不是，是有四個廚師，一個洗菜、一個切菜、一個煮湯、一個炒菜，所有人<strong>一起動作</strong>就是 parallelism（如果同時間只有一個廚師能動作，不算 parallelism）。煮一頓飯也可以拆成炒青菜、煮飯、煮湯三件事，每件事各自從洗到切到煮或炒，這樣也是一個 concurrency solution，而如果有多個廚師一起做，便成了 parallelism。</p>\n<p>concurrency 關乎程式結構，parallelism 關乎程式執行。concurrency 是程式或系統怎麼切分成多個工作，而 parallelism 則得要同時「執行」。</p>\n<h2 id=\"關於中文翻譯\"><a href=\"#關於中文翻譯\" class=\"headerlink\" title=\"關於中文翻譯\"></a>關於中文翻譯</h2><p>concurrency 的中文翻譯是「並行」，parallelism 是「平行」。但「平行」很容易出現在描述裡，常常搞不清楚到底「平行」是指 parallelism 還是只是一個形容？我比較喜歡在需要精準指出是 concurrency 或 parallelism 的時候用原文，單純的形容或者描述用「平行」，除非英文用在中文句子有點怪才會用中文「並行」跟「平行」並且加註英文。</p>\n<h2 id=\"Ref\"><a href=\"#Ref\" class=\"headerlink\" title=\"Ref\"></a>Ref</h2><ul>\n<li><a href=\"https://blog.golang.org/concurrency-is-not-parallelism\" target=\"_blank\" rel=\"noopener\">https://blog.golang.org/concurrency-is-not-parallelism</a></li>\n<li>《The Art of Concurrency》</li>\n</ul>\n","tags":["Concurrency"]},{"title":"API 設計的一致性","url":"/Consistent-API-Design/","content":"<p>像 naming、argument 順序、standard pattern 的使用、memory model、exception 的使用、error handling 等等，如果設計上有一致性，使用者較容易使用。保有一致性時，使用者可以輕易透過原本的理解認知推測新功能或其他部分如何使用。</p>\n<p>在設計 C++ API 上，如果跟 standard library 保有相同的模式與規則也會讓 API 易於使用，畢竟大家都會用 standard library 啊！</p>\n<p>雖然這篇標題是說 API 的設計，但小至 class 跟 function 也是有類似的觀念啊～</p>\n<p>舉個 argument 不一致的例子：<code>fscanf()</code> 跟 <code>fgets()</code>，它們分別長這樣：</p>\n<p><code>int fscanf(FILE* stream, const char* format, ...);</code><br><code>char* fgets(char* str, int num, FILE* stream);</code></p>\n<p>兩個類似的 function，<code>FILE* stream</code> 參數卻是一個在第一個、一個在最後一個，讓我太久沒用就得回頭瞄一下文件……</p>\n","tags":["C++","API"]},{"title":"API 的基本功能性及便利性","url":"/Core-API-and-convenient-API/","content":"<p>API 的功能可以是比較 atomic、比較基本的，讓外部使用這些基本功能組合出它想要的東西。也可以是 API 本身即組合一些基本功能、提供較方便的功能給外部使用。這兩種特性雖然互相衝突，但都是作為 API 希望滿足的。</p>\n<p>滿足這兩種特性的方式是將僅提供基本功能的 core API 及較方便的 API 分開。可能是以 class 或檔案區隔，甚至直接拆成不同 library。重點是較方便的 API 是使用 core API 的 public interface，就像在 core API 外再包一層，而不會 access 到 core API 的內部結構。</p>\n<p>如此使用者就能有方便使用的 API 也能在想自行組合功能的時候使用進階的 core API。這概念類似於 UI 設計上常有的「進階」按鈕──平常設定頁只會有基本設定，按進階按鈕後才會顯示更細部的設定。</p>\n","tags":["API"]},{"title":"C++ STL container interator","url":"/Cpp-STL-container-iterator/","content":"<p>trace 聽說比較好讀的 LLVM libcxx。寫法是 template 所以 implementation 都在 header file 裡，這裡以 list 為例。</p>\n<p>LLVM libcxx：<a href=\"http://libcxx.llvm.org/index.html\" target=\"_blank\" rel=\"noopener\">http://libcxx.llvm.org/index.html</a></p>\n<p>首先，class <code>list</code> 繼承 <code>__list_imp</code>。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">523</span> <span class=\"keyword\">template</span> &lt;<span class=\"class\"><span class=\"keyword\">class</span> _<span class=\"title\">Tp</span>, <span class=\"title\">class</span> _<span class=\"title\">Alloc</span>&gt;</span></span><br><span class=\"line\"><span class=\"class\">524 <span class=\"title\">class</span> __<span class=\"title\">list_imp</span></span></span><br><span class=\"line\"><span class=\"class\">525 &#123;</span></span><br><span class=\"line\"><span class=\"number\">526</span>     __list_imp(<span class=\"keyword\">const</span> __list_imp&amp;);</span><br><span class=\"line\"><span class=\"number\">527</span>     __list_imp&amp; <span class=\"keyword\">operator</span>=(<span class=\"keyword\">const</span> __list_imp&amp;);</span><br><span class=\"line\"><span class=\"number\">528</span> <span class=\"keyword\">protected</span>:</span><br><span class=\"line\"><span class=\"number\">529</span>     <span class=\"keyword\">typedef</span> _Tp                                                     value_type;</span><br><span class=\"line\"><span class=\"number\">533</span>     <span class=\"keyword\">typedef</span> <span class=\"keyword\">typename</span> __alloc_traits::void_pointer                   __void_pointer;</span><br><span class=\"line\"><span class=\"number\">534</span>     <span class=\"keyword\">typedef</span> __list_iterator&lt;value_type, __void_pointer&gt;             iterator;</span><br><span class=\"line\"><span class=\"number\">536</span>     <span class=\"keyword\">typedef</span> __list_node_base&lt;value_type, __void_pointer&gt;            __node_base;</span><br><span class=\"line\">...</span><br><span class=\"line\"><span class=\"number\">552</span>     __node_base __end_;</span><br><span class=\"line\">...</span><br><span class=\"line\"><span class=\"number\">587</span>     <span class=\"function\">iterator <span class=\"title\">begin</span><span class=\"params\">()</span> _NOEXCEPT</span></span><br><span class=\"line\"><span class=\"function\">588     </span>&#123;</span><br><span class=\"line\"><span class=\"number\">589</span> <span class=\"meta\">#<span class=\"meta-keyword\">if</span> _LIBCPP_DEBUG_LEVEL &gt;= 2</span></span><br><span class=\"line\"><span class=\"number\">590</span>         <span class=\"keyword\">return</span> iterator(__end_.__next_, <span class=\"keyword\">this</span>);</span><br><span class=\"line\"><span class=\"number\">591</span> <span class=\"meta\">#<span class=\"meta-keyword\">else</span></span></span><br><span class=\"line\"><span class=\"number\">592</span>         <span class=\"keyword\">return</span> iterator(__end_.__next_);</span><br><span class=\"line\"><span class=\"number\">593</span> <span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></span><br><span class=\"line\"><span class=\"number\">594</span>     &#125;</span><br><span class=\"line\">...</span><br><span class=\"line\"><span class=\"number\">805</span> <span class=\"keyword\">template</span> &lt;<span class=\"class\"><span class=\"keyword\">class</span> _<span class=\"title\">Tp</span>, <span class=\"title\">class</span> _<span class=\"title\">Alloc</span> /*= <span class=\"title\">allocator</span>&lt;_Tp&gt;*/&gt;</span></span><br><span class=\"line\"><span class=\"class\">806 <span class=\"title\">class</span> _<span class=\"title\">LIBCPP_TYPE_VIS_ONLY</span> <span class=\"title\">list</span></span></span><br><span class=\"line\"><span class=\"class\">807     :</span> <span class=\"keyword\">private</span> __list_imp&lt;_Tp, _Alloc&gt;</span><br><span class=\"line\"><span class=\"number\">808</span> &#123;</span><br></pre></td></tr></table></figure>\n\n<p>從 <code>__list_imp::begin()</code> 開始，<code>iterator</code> 在 line 534 被定義為 <code>__list_iterator&lt;value_type, __void_pointer&gt;</code>，<code>__list_iterator</code> 是個 class：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">273</span> <span class=\"keyword\">template</span> &lt;<span class=\"class\"><span class=\"keyword\">class</span> _<span class=\"title\">Tp</span>, <span class=\"title\">class</span> _<span class=\"title\">VoidPtr</span>&gt;</span></span><br><span class=\"line\"><span class=\"class\">274 <span class=\"title\">class</span> _<span class=\"title\">LIBCPP_TYPE_VIS_ONLY</span> __<span class=\"title\">list_iterator</span></span></span><br><span class=\"line\"><span class=\"class\">275 &#123;</span></span><br><span class=\"line\"><span class=\"number\">276</span>     <span class=\"keyword\">typedef</span> __list_node_pointer_traits&lt;_Tp, _VoidPtr&gt; _NodeTraits;</span><br><span class=\"line\"><span class=\"number\">277</span>     <span class=\"keyword\">typedef</span> <span class=\"keyword\">typename</span> _NodeTraits::__link_pointer __link_pointer;</span><br><span class=\"line\"><span class=\"number\">278</span> </span><br><span class=\"line\"><span class=\"number\">279</span>     __link_pointer __ptr_;</span><br><span class=\"line\"><span class=\"number\">280</span> </span><br><span class=\"line\"><span class=\"number\">281</span> <span class=\"meta\">#<span class=\"meta-keyword\">if</span> _LIBCPP_DEBUG_LEVEL &gt;= 2</span></span><br><span class=\"line\"><span class=\"number\">282</span>     _LIBCPP_INLINE_VISIBILITY</span><br><span class=\"line\"><span class=\"number\">283</span>     <span class=\"keyword\">explicit</span> __list_iterator(__link_pointer __p, <span class=\"keyword\">const</span> <span class=\"keyword\">void</span>* __c) _NOEXCEPT</span><br><span class=\"line\"><span class=\"number\">284</span>         : __ptr_(__p)</span><br><span class=\"line\"><span class=\"number\">285</span>     &#123;</span><br><span class=\"line\"><span class=\"number\">286</span>         __get_db()-&gt;__insert_ic(<span class=\"keyword\">this</span>, __c);</span><br><span class=\"line\"><span class=\"number\">287</span>     &#125;</span><br><span class=\"line\"><span class=\"number\">288</span> <span class=\"meta\">#<span class=\"meta-keyword\">else</span></span></span><br><span class=\"line\"><span class=\"number\">289</span>     _LIBCPP_INLINE_VISIBILITY</span><br><span class=\"line\"><span class=\"number\">290</span>     <span class=\"keyword\">explicit</span> __list_iterator(__link_pointer __p) _NOEXCEPT : __ptr_(__p) &#123;&#125;</span><br><span class=\"line\"><span class=\"number\">291</span> <span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></span><br></pre></td></tr></table></figure>\n\n<p>在 <code>__list_iterator</code> constructor 存下傳進來的 <code>__link_pointer</code>，也就是 <code>__list_imp::__end_.__next_</code>。<code>__list_node_pointer_traits</code> 是個 struct，裡面定義了 type <code>__link_pointer</code>，然後這東西追下去有點沒完沒了，照字面意思當它是個 pointer 吧。</p>\n<p><code>__end_</code> 是個 <code>__node_base</code>，也就是 <code>__list_node_base&lt;value_type, __void_pointer&gt;</code>：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">228</span> <span class=\"keyword\">template</span> &lt;<span class=\"class\"><span class=\"keyword\">class</span> _<span class=\"title\">Tp</span>, <span class=\"title\">class</span> _<span class=\"title\">VoidPtr</span>&gt;</span></span><br><span class=\"line\"><span class=\"class\">229 <span class=\"title\">struct</span> __<span class=\"title\">list_node_base</span></span></span><br><span class=\"line\"><span class=\"class\">230 &#123;</span></span><br><span class=\"line\"><span class=\"number\">231</span>     <span class=\"keyword\">typedef</span> __list_node_pointer_traits&lt;_Tp, _VoidPtr&gt; _NodeTraits;</span><br><span class=\"line\"><span class=\"number\">232</span>     <span class=\"keyword\">typedef</span> <span class=\"keyword\">typename</span> _NodeTraits::__node_pointer __node_pointer;</span><br><span class=\"line\"><span class=\"number\">233</span>     <span class=\"keyword\">typedef</span> <span class=\"keyword\">typename</span> _NodeTraits::__base_pointer __base_pointer;</span><br><span class=\"line\"><span class=\"number\">234</span>     <span class=\"keyword\">typedef</span> <span class=\"keyword\">typename</span> _NodeTraits::__link_pointer __link_pointer;</span><br><span class=\"line\"><span class=\"number\">235</span> </span><br><span class=\"line\"><span class=\"number\">236</span>     __link_pointer __prev_;</span><br><span class=\"line\"><span class=\"number\">237</span>     __link_pointer __next_;</span><br></pre></td></tr></table></figure>\n\n<p>那麼 <code>__end_</code> 又是做什麼用的呢？我猜它跟 list 的最後一個 node 之類的有關係，所以看看 <code>push_back()</code> 是不是會動到它。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">1537</span> <span class=\"keyword\">template</span> &lt;<span class=\"class\"><span class=\"keyword\">class</span> _<span class=\"title\">Tp</span>, <span class=\"title\">class</span> _<span class=\"title\">Alloc</span>&gt;</span></span><br><span class=\"line\"><span class=\"class\">1538 <span class=\"title\">void</span></span></span><br><span class=\"line\"><span class=\"class\">1539 <span class=\"title\">list</span>&lt;_Tp, _Alloc&gt;:</span>:push_front(<span class=\"keyword\">const</span> value_type&amp; __x)</span><br><span class=\"line\"><span class=\"number\">1540</span> &#123;</span><br><span class=\"line\"><span class=\"number\">1541</span>     __node_allocator&amp; __na = base::__node_alloc();</span><br><span class=\"line\"><span class=\"number\">1542</span>     <span class=\"keyword\">typedef</span> __allocator_destructor&lt;__node_allocator&gt; _Dp;</span><br><span class=\"line\"><span class=\"number\">1543</span>     <span class=\"built_in\">unique_ptr</span>&lt;__node, _Dp&gt; __hold(__node_alloc_traits::allocate(__na, <span class=\"number\">1</span>), _Dp(__na, <span class=\"number\">1</span>));</span><br><span class=\"line\"><span class=\"number\">1544</span>     __node_alloc_traits::construct(__na, _VSTD::addressof(__hold-&gt;__value_), __x);</span><br><span class=\"line\"><span class=\"number\">1545</span>     __link_pointer __nl = __hold-&gt;__as_link();</span><br><span class=\"line\"><span class=\"number\">1546</span>     __link_nodes_at_front(__nl, __nl);</span><br><span class=\"line\"><span class=\"number\">1547</span>     ++base::__sz();</span><br><span class=\"line\"><span class=\"number\">1548</span>     __hold.release();</span><br><span class=\"line\"><span class=\"number\">1549</span> &#125;</span><br><span class=\"line\"><span class=\"number\">1550</span> </span><br><span class=\"line\"><span class=\"number\">1551</span> <span class=\"keyword\">template</span> &lt;<span class=\"class\"><span class=\"keyword\">class</span> _<span class=\"title\">Tp</span>, <span class=\"title\">class</span> _<span class=\"title\">Alloc</span>&gt;</span></span><br><span class=\"line\"><span class=\"class\">1552 <span class=\"title\">void</span></span></span><br><span class=\"line\"><span class=\"class\">1553 <span class=\"title\">list</span>&lt;_Tp, _Alloc&gt;:</span>:push_back(<span class=\"keyword\">const</span> value_type&amp; __x)</span><br><span class=\"line\"><span class=\"number\">1554</span> &#123;</span><br><span class=\"line\"><span class=\"number\">1555</span>     __node_allocator&amp; __na = base::__node_alloc();</span><br><span class=\"line\"><span class=\"number\">1556</span>     <span class=\"keyword\">typedef</span> __allocator_destructor&lt;__node_allocator&gt; _Dp;</span><br><span class=\"line\"><span class=\"number\">1557</span>     <span class=\"built_in\">unique_ptr</span>&lt;__node, _Dp&gt; __hold(__node_alloc_traits::allocate(__na, <span class=\"number\">1</span>), _Dp(__na, <span class=\"number\">1</span>));</span><br><span class=\"line\"><span class=\"number\">1558</span>     __node_alloc_traits::construct(__na, _VSTD::addressof(__hold-&gt;__value_), __x);</span><br><span class=\"line\"><span class=\"number\">1559</span>     __link_nodes_at_back(__hold.get()-&gt;__as_link(), __hold.get()-&gt;__as_link());</span><br><span class=\"line\"><span class=\"number\">1560</span>     ++base::__sz();</span><br><span class=\"line\"><span class=\"number\">1561</span>     __hold.release();</span><br><span class=\"line\"><span class=\"number\">1562</span> &#125;</span><br><span class=\"line\">...</span><br><span class=\"line\"><span class=\"number\">1099</span> <span class=\"comment\">// Link in nodes [__f, __l] at the front of the list</span></span><br><span class=\"line\"><span class=\"number\">1100</span> <span class=\"keyword\">template</span> &lt;<span class=\"class\"><span class=\"keyword\">class</span> _<span class=\"title\">Tp</span>, <span class=\"title\">class</span> _<span class=\"title\">Alloc</span>&gt;</span></span><br><span class=\"line\"><span class=\"class\">1101 <span class=\"title\">inline</span></span></span><br><span class=\"line\"><span class=\"class\">1102 <span class=\"title\">void</span></span></span><br><span class=\"line\"><span class=\"class\">1103 <span class=\"title\">list</span>&lt;_Tp, _Alloc&gt;:</span>:__link_nodes_at_front(__link_pointer __f, __link_pointer __l)</span><br><span class=\"line\"><span class=\"number\">1104</span> &#123;</span><br><span class=\"line\"><span class=\"number\">1105</span>     __f-&gt;__prev_ = base::__end_as_link();</span><br><span class=\"line\"><span class=\"number\">1106</span>     __l-&gt;__next_ = base::__end_.__next_;</span><br><span class=\"line\"><span class=\"number\">1107</span>     __l-&gt;__next_-&gt;__prev_ = __l;</span><br><span class=\"line\"><span class=\"number\">1108</span>     base::__end_.__next_ = __f;</span><br><span class=\"line\"><span class=\"number\">1109</span> &#125;</span><br><span class=\"line\"><span class=\"number\">1110</span> </span><br><span class=\"line\"><span class=\"number\">1111</span> <span class=\"comment\">// Link in nodes [__f, __l] at the front of the list</span></span><br><span class=\"line\"><span class=\"number\">1112</span> <span class=\"keyword\">template</span> &lt;<span class=\"class\"><span class=\"keyword\">class</span> _<span class=\"title\">Tp</span>, <span class=\"title\">class</span> _<span class=\"title\">Alloc</span>&gt;</span></span><br><span class=\"line\"><span class=\"class\">1113 <span class=\"title\">inline</span></span></span><br><span class=\"line\"><span class=\"class\">1114 <span class=\"title\">void</span></span></span><br><span class=\"line\"><span class=\"class\">1115 <span class=\"title\">list</span>&lt;_Tp, _Alloc&gt;:</span>:__link_nodes_at_back(__link_pointer __f, __link_pointer __l)</span><br><span class=\"line\"><span class=\"number\">1116</span> &#123;</span><br><span class=\"line\"><span class=\"number\">1117</span>     __l-&gt;__next_ = base::__end_as_link();</span><br><span class=\"line\"><span class=\"number\">1118</span>     __f-&gt;__prev_ = base::__end_.__prev_;</span><br><span class=\"line\"><span class=\"number\">1119</span>     __f-&gt;__prev_-&gt;__next_ = __f;</span><br><span class=\"line\"><span class=\"number\">1120</span>     base::__end_.__prev_ = __l;</span><br><span class=\"line\"><span class=\"number\">1121</span> &#125;</span><br></pre></td></tr></table></figure>\n\n<p><code>list</code> 繼承 <code>__list_imp</code>，所以 <code>__link_nodes_at_front()</code> 的 <code>base::__end_</code> 是 <code>__list_imp</code> 的 <code>__end_</code>。從上面四個 function 看起來，<code>__end_.__prev_</code> 指到 list 的最後一個 node，<code>__end_.__next_</code> 指向 list 第一個 node。也就是說，<code>__end_</code> 是用來記錄 list 的第一個及最後一個 node。</p>\n<p>到這裡回頭看 <code>begin()</code>，它生了個 <code>__list_iterator</code> 並把 <code>list</code> 第一個 node 的 address 丟給 <code>__list_iterator</code>，<code>__list_iterator</code> 將 address 記在 <code>__ptr_</code>。</p>\n<p>最後，iterator 如何取值跟移動。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">350</span>     _LIBCPP_INLINE_VISIBILITY</span><br><span class=\"line\"><span class=\"number\">351</span>     pointer <span class=\"keyword\">operator</span>-&gt;() <span class=\"keyword\">const</span></span><br><span class=\"line\"><span class=\"number\">352</span>     &#123;</span><br><span class=\"line\"><span class=\"number\">357</span>         <span class=\"keyword\">return</span> pointer_traits&lt;pointer&gt;::pointer_to(__ptr_-&gt;__as_node()-&gt;__value_);</span><br><span class=\"line\"><span class=\"number\">358</span>     &#125;</span><br></pre></td></tr></table></figure>\n\n<p>就是直接拿 value。XD</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">360</span>     _LIBCPP_INLINE_VISIBILITY</span><br><span class=\"line\"><span class=\"number\">361</span>     __list_iterator&amp; <span class=\"keyword\">operator</span>++()</span><br><span class=\"line\"><span class=\"number\">362</span>     &#123;</span><br><span class=\"line\"><span class=\"number\">367</span>         __ptr_ = __ptr_-&gt;__next_;</span><br><span class=\"line\"><span class=\"number\">368</span>         <span class=\"keyword\">return</span> *<span class=\"keyword\">this</span>;</span><br><span class=\"line\"><span class=\"number\">369</span>     &#125;</span><br></pre></td></tr></table></figure>\n\n<p>透過 <code>__next_</code> 移到下一個 node。</p>\n<p>略過很多太細節的 struct，只是想知道 STL 的 iterator 大致是如何取值以及如何做「下一個」的動作的。總結，<code>__list_iterator</code> 是透過 pointer 去 access <code>__list_imp</code> 的內部資料。</p>\n<h2 id=\"其他資料\"><a href=\"#其他資料\" class=\"headerlink\" title=\"其他資料\"></a>其他資料</h2><ul>\n<li>GNU libstdc++：<a href=\"https://github.com/gcc-mirror/gcc/tree/master/libstdc%2B%2B-v3/include/std\" target=\"_blank\" rel=\"noopener\">https://github.com/gcc-mirror/gcc/tree/master/libstdc%2B%2B-v3/include/std</a></li>\n</ul>\n","tags":["C++","STL"]},{"title":"C++ Virtual destructor in interface","url":"/Cpp-Virtual-destructor-in-interface/","content":"<p>C++ 不像 Java 有 interface，這邊說的 interface 是所有 function 皆為 pure virtual function 的 abstract class。</p>\n<p>interface 依然要有 virtual destructor，否則用 interface pointer 去砍 object 的時候會變成 undefined behavior。如果希望 interface 中的 virtual destructor 仍是 pure virtual，可以這樣寫：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Interface</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"keyword\">virtual</span> ~Interface() = <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">inline</span> Interface::~Interface() &#123; &#125;</span><br></pre></td></tr></table></figure>\n\n<p>由於只要有 class 繼承 Interface，Interface 的 destructor 就會被 derived class call 到，所以必須要有 definition 才不會 link error。</p>\n<p>virtual destructor 另一個使用場合──希望訂一個 interface 但不想訂定其中要有什麼 function──不想訂 function 但又需要該 class 是 abstract class 時就可用 virtual destructor 達到目的。聽起來有點怪，我遇到這種狀況是希望有個 interface 可以代表某種類的 object，但是在 interface 的階段卻又無法確定 derived class 會有那些 function，最後因為覺得結構上不需要而沒有真的使用，不曉得有沒有其他更好的方法？</p>\n<p>2018-12：現在看看覺得「希望訂一個 interface 但不想訂定其中要有什麼 function」的情況有點怪……又想不起來之前遇到什麼了……要訂 interface 至少要有基本 function，否則是否先不訂 interface、先做 class，等漸漸看到有共通的 function 時再訂定 interface？</p>\n<h2 id=\"Ref\"><a href=\"#Ref\" class=\"headerlink\" title=\"Ref\"></a>Ref</h2><ul>\n<li><a href=\"/c-plus-plus-virtual-destructor\">C++ Virtual Destructor</a></li>\n<li><a href=\"http://stackoverflow.com/questions/270917/why-should-i-declare-a-virtual-destructor-for-an-abstract-class-in-c\" target=\"_blank\" rel=\"noopener\">http://stackoverflow.com/questions/270917/why-should-i-declare-a-virtual-destructor-for-an-abstract-class-in-c</a></li>\n<li><a href=\"http://stackoverflow.com/questions/630950/pure-virtual-destructor-in-c\" target=\"_blank\" rel=\"noopener\">http://stackoverflow.com/questions/630950/pure-virtual-destructor-in-c</a></li>\n<li><a href=\"http://www.gotw.ca/gotw/031.htm\" target=\"_blank\" rel=\"noopener\">http://www.gotw.ca/gotw/031.htm</a></li>\n</ul>\n","tags":["C++","Programming"]},{"title":"C++ uses C library example","url":"/Cpp-uses-C-library-example/","content":"<p>C compiler 編出來的 object file 可以跟 C++ compiler 編出來的 object file link 在一起。</p>\n<p>假設 Linux 環境下有一個 object file <code>foo.o</code> 是 C compiler 編出來的，可以將 <code>foo.o</code> 看作一 C library，而 <code>main.cpp</code> 是由 C++ 實作並且使用 <code>foo.o</code> 裡的 function，因此 <code>main.cpp</code> 會 include 內含 function declaration 的 <code>foo.h</code>。C++ compiler 在一般狀況下會將 <code>foo.h</code> 內的 function 當作 C++ function 以 C++ 的規則處理。</p>\n<p>由於 <code>foo.o</code> 是 C compiler 編出來的，其對 function 的處理方式不像 C++ 會額外加修飾，使得 link 時 <code>main.o</code> 及 <code>foo.o</code> 中 symbol 對不起來而產生 <code>undefined reference</code> 錯誤。在 <code>foo.h</code> 中加上 <code>extern &quot;C&quot;</code> 是告訴 C++ compiler 要把這段 function declaration 當作 C function 處理，也就是不做 <strong>name decoration</strong>，之後 link symbol 才對得起來。實例如下：</p>\n<figure class=\"highlight c\"><figcaption><span>foo.h</span></figcaption><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// foo.h</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">ifdef</span> __cplusplus</span></span><br><span class=\"line\"><span class=\"keyword\">extern</span> <span class=\"string\">\"C\"</span> &#123;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">foo</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">ifdef</span> __cplusplus</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight c\"><figcaption><span>foo.c</span></figcaption><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// foo.c</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">\"foo.h\"</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">foo</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"C foo()!\\n\"</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight cpp\"><figcaption><span>main.cpp</span></figcaption><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// main.cpp</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">\"foo.h\"</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"C++ main\"</span> &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">    foo();</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><code>foo.o</code> 的 symbol：</p>\n<figure class=\"highlight routeros\"><table><tr><td class=\"code\"><pre><span class=\"line\">&gt; gcc -c foo.c</span><br><span class=\"line\">&gt; readelf -s foo.o</span><br><span class=\"line\"></span><br><span class=\"line\">Symbol table <span class=\"string\">'.symtab'</span> contains 11 entries:</span><br><span class=\"line\">   Num:    Value  Size<span class=\"built_in\"> Type </span>   Bind   Vis      Ndx Name</span><br><span class=\"line\">     0: 00000000     0 NOTYPE  LOCAL <span class=\"built_in\"> DEFAULT </span> UND</span><br><span class=\"line\">     1: 00000000     0 FILE    LOCAL <span class=\"built_in\"> DEFAULT </span> ABS foo.c</span><br><span class=\"line\">     2: 00000000     0 SECTION LOCAL <span class=\"built_in\"> DEFAULT </span>   1</span><br><span class=\"line\">     3: 00000000     0 SECTION LOCAL <span class=\"built_in\"> DEFAULT </span>   3</span><br><span class=\"line\">     4: 00000000     0 SECTION LOCAL <span class=\"built_in\"> DEFAULT </span>   4</span><br><span class=\"line\">     5: 00000000     0 SECTION LOCAL <span class=\"built_in\"> DEFAULT </span>   5</span><br><span class=\"line\">     6: 00000000     0 SECTION LOCAL <span class=\"built_in\"> DEFAULT </span>   7</span><br><span class=\"line\">     7: 00000000     0 SECTION LOCAL <span class=\"built_in\"> DEFAULT </span>   8</span><br><span class=\"line\">     8: 00000000     0 SECTION LOCAL <span class=\"built_in\"> DEFAULT </span>   6</span><br><span class=\"line\">     9: 00000000    20 FUNC    GLOBAL<span class=\"built_in\"> DEFAULT </span>   1 foo</span><br><span class=\"line\">    10: 00000000     0 NOTYPE  GLOBAL<span class=\"built_in\"> DEFAULT </span> UND puts</span><br></pre></td></tr></table></figure>\n\n<p>一般狀況的 <code>main.o</code> symbol（重點在 18）：</p>\n<figure class=\"highlight routeros\"><table><tr><td class=\"code\"><pre><span class=\"line\">&gt; g++ -c main.cpp</span><br><span class=\"line\">&gt; readelf -s main.o</span><br><span class=\"line\"></span><br><span class=\"line\">Symbol table <span class=\"string\">'.symtab'</span> contains 23 entries:</span><br><span class=\"line\">   Num:    Value  Size<span class=\"built_in\"> Type </span>   Bind   Vis      Ndx Name</span><br><span class=\"line\">     0: 00000000     0 NOTYPE  LOCAL <span class=\"built_in\"> DEFAULT </span> UND</span><br><span class=\"line\">     1: 00000000     0 FILE    LOCAL <span class=\"built_in\"> DEFAULT </span> ABS main.cpp</span><br><span class=\"line\">     2: 00000000     0 SECTION LOCAL <span class=\"built_in\"> DEFAULT </span>   1</span><br><span class=\"line\">     3: 00000000     0 SECTION LOCAL <span class=\"built_in\"> DEFAULT </span>   3</span><br><span class=\"line\">     4: 00000000     0 SECTION LOCAL <span class=\"built_in\"> DEFAULT </span>   4</span><br><span class=\"line\">     5: 00000000     1 OBJECT  LOCAL <span class=\"built_in\"> DEFAULT </span>   4 _ZStL8__ioinit</span><br><span class=\"line\">     6: 00000000     0 SECTION LOCAL <span class=\"built_in\"> DEFAULT </span>   5</span><br><span class=\"line\">     7: 00000039    64 FUNC    LOCAL <span class=\"built_in\"> DEFAULT </span>   1 _Z41__static_initializati</span><br><span class=\"line\">     8: 00000079    28 FUNC    LOCAL <span class=\"built_in\"> DEFAULT </span>   1 _GLOBAL__sub_I_main</span><br><span class=\"line\">     9: 00000000     0 SECTION LOCAL <span class=\"built_in\"> DEFAULT </span>   6</span><br><span class=\"line\">    10: 00000000     0 SECTION LOCAL <span class=\"built_in\"> DEFAULT </span>   9</span><br><span class=\"line\">    11: 00000000     0 SECTION LOCAL <span class=\"built_in\"> DEFAULT </span>  10</span><br><span class=\"line\">    12: 00000000     0 SECTION LOCAL <span class=\"built_in\"> DEFAULT </span>   8</span><br><span class=\"line\">    13: 00000000    57 FUNC    GLOBAL<span class=\"built_in\"> DEFAULT </span>   1 main</span><br><span class=\"line\">    14: 00000000     0 NOTYPE  GLOBAL<span class=\"built_in\"> DEFAULT </span> UND _ZSt4cout</span><br><span class=\"line\">    15: 00000000     0 NOTYPE  GLOBAL<span class=\"built_in\"> DEFAULT </span> UND _ZStlsISt11char_traitsIcE</span><br><span class=\"line\">    16: 00000000     0 NOTYPE  GLOBAL<span class=\"built_in\"> DEFAULT </span> UND _ZSt4endlIcSt11char_trait</span><br><span class=\"line\">    17: 00000000     0 NOTYPE  GLOBAL<span class=\"built_in\"> DEFAULT </span> UND _ZNSolsEPFRSoS_E</span><br><span class=\"line\">    18: 00000000     0 NOTYPE  GLOBAL<span class=\"built_in\"> DEFAULT </span> UND _Z3foov</span><br><span class=\"line\">    19: 00000000     0 NOTYPE  GLOBAL<span class=\"built_in\"> DEFAULT </span> UND _ZNSt8ios_base4InitC1Ev</span><br><span class=\"line\">    20: 00000000     0 NOTYPE  GLOBAL<span class=\"built_in\"> DEFAULT </span> UND _ZNSt8ios_base4InitD1Ev</span><br><span class=\"line\">    21: 00000000     0 NOTYPE  GLOBAL<span class=\"built_in\"> DEFAULT </span> UND __dso_handle</span><br><span class=\"line\">    22: 00000000     0 NOTYPE  GLOBAL<span class=\"built_in\"> DEFAULT </span> UND __cxa_atexit</span><br></pre></td></tr></table></figure>\n\n<p><code>foo.h</code> 有 <code>extern &quot;C&quot;</code> 的 <code>main.o</code> symbol：</p>\n<figure class=\"highlight routeros\"><table><tr><td class=\"code\"><pre><span class=\"line\">&gt;readelf -s main.o</span><br><span class=\"line\"></span><br><span class=\"line\">Symbol table <span class=\"string\">'.symtab'</span> contains 23 entries:</span><br><span class=\"line\">   Num:    Value  Size<span class=\"built_in\"> Type </span>   Bind   Vis      Ndx Name</span><br><span class=\"line\">     0: 00000000     0 NOTYPE  LOCAL <span class=\"built_in\"> DEFAULT </span> UND</span><br><span class=\"line\">     1: 00000000     0 FILE    LOCAL <span class=\"built_in\"> DEFAULT </span> ABS main.cpp</span><br><span class=\"line\">     2: 00000000     0 SECTION LOCAL <span class=\"built_in\"> DEFAULT </span>   1</span><br><span class=\"line\">     3: 00000000     0 SECTION LOCAL <span class=\"built_in\"> DEFAULT </span>   3</span><br><span class=\"line\">     4: 00000000     0 SECTION LOCAL <span class=\"built_in\"> DEFAULT </span>   4</span><br><span class=\"line\">     5: 00000000     1 OBJECT  LOCAL <span class=\"built_in\"> DEFAULT </span>   4 _ZStL8__ioinit</span><br><span class=\"line\">     6: 00000000     0 SECTION LOCAL <span class=\"built_in\"> DEFAULT </span>   5</span><br><span class=\"line\">     7: 00000039    64 FUNC    LOCAL <span class=\"built_in\"> DEFAULT </span>   1 _Z41__static_initializati</span><br><span class=\"line\">     8: 00000079    28 FUNC    LOCAL <span class=\"built_in\"> DEFAULT </span>   1 _GLOBAL__sub_I_main</span><br><span class=\"line\">     9: 00000000     0 SECTION LOCAL <span class=\"built_in\"> DEFAULT </span>   6</span><br><span class=\"line\">    10: 00000000     0 SECTION LOCAL <span class=\"built_in\"> DEFAULT </span>   9</span><br><span class=\"line\">    11: 00000000     0 SECTION LOCAL <span class=\"built_in\"> DEFAULT </span>  10</span><br><span class=\"line\">    12: 00000000     0 SECTION LOCAL <span class=\"built_in\"> DEFAULT </span>   8</span><br><span class=\"line\">    13: 00000000    57 FUNC    GLOBAL<span class=\"built_in\"> DEFAULT </span>   1 main</span><br><span class=\"line\">    14: 00000000     0 NOTYPE  GLOBAL<span class=\"built_in\"> DEFAULT </span> UND _ZSt4cout</span><br><span class=\"line\">    15: 00000000     0 NOTYPE  GLOBAL<span class=\"built_in\"> DEFAULT </span> UND _ZStlsISt11char_traitsIcE</span><br><span class=\"line\">    16: 00000000     0 NOTYPE  GLOBAL<span class=\"built_in\"> DEFAULT </span> UND _ZSt4endlIcSt11char_trait</span><br><span class=\"line\">    17: 00000000     0 NOTYPE  GLOBAL<span class=\"built_in\"> DEFAULT </span> UND _ZNSolsEPFRSoS_E</span><br><span class=\"line\">    18: 00000000     0 NOTYPE  GLOBAL<span class=\"built_in\"> DEFAULT </span> UND foo</span><br><span class=\"line\">    19: 00000000     0 NOTYPE  GLOBAL<span class=\"built_in\"> DEFAULT </span> UND _ZNSt8ios_base4InitC1Ev</span><br><span class=\"line\">    20: 00000000     0 NOTYPE  GLOBAL<span class=\"built_in\"> DEFAULT </span> UND _ZNSt8ios_base4InitD1Ev</span><br><span class=\"line\">    21: 00000000     0 NOTYPE  GLOBAL<span class=\"built_in\"> DEFAULT </span> UND __dso_handle</span><br><span class=\"line\">    22: 00000000     0 NOTYPE  GLOBAL<span class=\"built_in\"> DEFAULT </span> UND __cxa_atexit</span><br></pre></td></tr></table></figure>\n","tags":["C++","Linux"]},{"title":"DLL usage","url":"/DLL-usage/","content":"<p>link DLL 分成 implicit link 及 explicit link。</p>\n<h2 id=\"Implicit-link\"><a href=\"#Implicit-link\" class=\"headerlink\" title=\"Implicit link\"></a>Implicit link</h2><p>DLL library 需要 export 出 symbol，使用 DLL 的程式則需要 import symbol。VC 裡透過 <code>__declspec(export)</code> 來標示要 export 的  symbol，以及 <code>__declspec(import)</code> 標示要從外面 import 的 symbol。如果要讓 C++ 的 symbol 跟 C 相容，需要加 <code>extern &quot;C&quot;</code>（不做 C++ 名稱修飾）。</p>\n<p>使用 library 的程式需要：</p>\n<ul>\n<li>compile 時需要 library export 的 symbol 的 header file</li>\n<li>需 link library 的 <code>.lib</code>，<code>.lib</code> 會在 build DLL 時一起 build 出來</li>\n<li>執行時需 <code>.dll</code></li>\n</ul>\n<p>build DLL 產生的 <code>.lib</code> 跟 static library 的不一樣，DLL 的 <code>.lib</code> 只是告訴使用的程式去哪找到 DLL，不會包含實際功能，所以檔案比較小。使用 implicitly link DLL 的程式必須要在 load 時可以找到 DLL，否則會跳錯誤訊息而且無法繼續執行。</p>\n<p>作為 library 的 project 需在 VC 的 project properties→General→Configuration Type 設為 <code>Dynamic Library (.dll)</code>、Target Extension 設為 <code>.dll</code>。另外，如果 code 實際上沒有 export symbol，build DLL 時不會生出 <code>.lib</code>。</p>\n<h3 id=\"Sample\"><a href=\"#Sample\" class=\"headerlink\" title=\"Sample\"></a>Sample</h3><h4 id=\"Foo-library\"><a href=\"#Foo-library\" class=\"headerlink\" title=\"Foo library\"></a>Foo library</h4><p>compile 時需 define <code>FOO_DLL_EXPORTS</code>。</p>\n<figure class=\"highlight c++\"><figcaption><span>Foo.h</span></figcaption><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">ifndef</span> FOO_H</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> FOO_H</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">ifdef</span> FOO_DLL_EXPORTS</span></span><br><span class=\"line\">    <span class=\"meta\">#<span class=\"meta-keyword\">define</span> FOO_API __declspec(dllexport)</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">else</span></span></span><br><span class=\"line\">    <span class=\"meta\">#<span class=\"meta-keyword\">define</span> FOO_API __declspec(dllimport)</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\">FOO_API <span class=\"keyword\">int</span> <span class=\"title\">Add</span><span class=\"params\">(<span class=\"keyword\">int</span> a, <span class=\"keyword\">int</span> b)</span></span>;</span><br><span class=\"line\"><span class=\"keyword\">extern</span> <span class=\"string\">\"C\"</span> <span class=\"function\">FOO_API <span class=\"keyword\">int</span> <span class=\"title\">Sub</span><span class=\"params\">(<span class=\"keyword\">int</span> a, <span class=\"keyword\">int</span> b)</span></span>;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight c++\"><figcaption><span>Foo.cpp</span></figcaption><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">\"Foo.h\"</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">Add</span><span class=\"params\">(<span class=\"keyword\">int</span> a, <span class=\"keyword\">int</span> b)</span> </span>&#123; <span class=\"keyword\">return</span> (a + b); &#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">Sub</span><span class=\"params\">(<span class=\"keyword\">int</span> a, <span class=\"keyword\">int</span> b)</span> </span>&#123; <span class=\"keyword\">return</span> (a - b); &#125;</span><br></pre></td></tr></table></figure>\n\n<p><code>dumpbin</code> 要從 VC 的 command prompt 才叫得出來。</p>\n<figure class=\"highlight plain\"><figcaption><span>export symbol</span></figcaption><table><tr><td class=\"code\"><pre><span class=\"line\">D:\\tmp\\FooLibrary\\Debug&gt;dumpbin &#x2F;EXPORTS FooLibrary.dll</span><br><span class=\"line\">Dump of file FooLibrary.dll</span><br><span class=\"line\"></span><br><span class=\"line\">File Type: DLL</span><br><span class=\"line\"></span><br><span class=\"line\">  Section contains the following exports for FooLibrary.dll</span><br><span class=\"line\"></span><br><span class=\"line\">    00000000 characteristics</span><br><span class=\"line\">    56507D3B time date stamp Sat Nov 21 22:18:35 2015</span><br><span class=\"line\">        0.00 version</span><br><span class=\"line\">           1 ordinal base</span><br><span class=\"line\">           2 number of functions</span><br><span class=\"line\">           2 number of names</span><br><span class=\"line\"></span><br><span class=\"line\">    ordinal hint RVA      name</span><br><span class=\"line\"></span><br><span class=\"line\">          1    0 0001107D ?Add@@YAHHH@Z &#x3D; @ILT+120(?Add@@YAHHH@Z)</span><br><span class=\"line\">          2    1 000110FA Sub &#x3D; @ILT+245(_Sub)</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"Test-program\"><a href=\"#Test-program\" class=\"headerlink\" title=\"Test program\"></a>Test program</h4><p>project 的 include file 中須包含 <code>Foo.h</code>，link library 需有 <code>FooLibrary.lib</code>，執行檔旁則需放 <code>FooLibrary.dll</code>。</p>\n<figure class=\"highlight c++\"><figcaption><span>main.cpp</span></figcaption><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">\"Foo.h\"</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span> &lt;&lt; Add(<span class=\"number\">1</span>, <span class=\"number\">2</span>) &lt;&lt; <span class=\"string\">\", \"</span> &lt;&lt; Sub(<span class=\"number\">1</span>, <span class=\"number\">2</span>) &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n<h2 id=\"Explicit-link\"><a href=\"#Explicit-link\" class=\"headerlink\" title=\"Explicit link\"></a>Explicit link</h2><p>在 runtime 時才 load DLL。因為 runtime 才 load，即使 load DLL 失敗也可以在程式裡處理錯誤並繼續執行下去。</p>\n<p>使用 library 的程式需要：</p>\n<ul>\n<li>call <code>LoadLibrary()</code> load DLL</li>\n<li>call <code>GetProcAddress()</code> 取得想要的 function 的 address</li>\n<li>用完 library 需 call <code>FreeLibrary()</code></li>\n<li>程式 compile 時不一定需要 library 的 header file（但需要知道要 call 的 function 的 prototype），link 時不需要 <code>.lib</code>，僅在執行時需要 <code>.dll</code></li>\n</ul>\n<p>用 <code>GetProcAddress()</code> 需指定的 function name 是 library export 出來的 symbol，不是 library source code 裡的 function name。經過 C++ 名稱修飾，需要指定的 function name 會變得難以理解，這種 interface 應該沒人想用。除了 <code>__declspec(dllexport)</code> 外，export function symbol 的另一個做法是使用 <code>.def</code> 模組定義檔來宣告名稱。實際上是指定 alias 給原本的 symbol。</p>\n<h3 id=\"Sample-load-DLL\"><a href=\"#Sample-load-DLL\" class=\"headerlink\" title=\"Sample load DLL\"></a>Sample load DLL</h3><p>library source code 同上。</p>\n<p>有加 <code>extern &quot;C&quot;</code> 的 <code>Sub()</code> 因為沒經過 C++ 名稱修飾，所以能直接用 function name，但 <code>Add()</code> 就得寫出 C++ 修飾後的 symbol name 才拿得到 function pointer。</p>\n<figure class=\"highlight c++\"><figcaption><span>main.cpp</span></figcaption><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;windows.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">typedef</span> <span class=\"title\">int</span><span class=\"params\">(*pfn)</span><span class=\"params\">(<span class=\"keyword\">int</span>, <span class=\"keyword\">int</span>)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    HINSTANCE dllHandle = LoadLibrary(<span class=\"string\">\"FooLibrary.dll\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (dllHandle != <span class=\"literal\">NULL</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"comment\">// Get address of function</span></span><br><span class=\"line\">        pfn pSubFunc = (pfn)GetProcAddress(dllHandle, <span class=\"string\">\"Sub\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!pSubFunc)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"Load Sub() fail\"</span> &lt;&lt; <span class=\"built_in\">std</span>::<span class=\"built_in\">endl</span>;  <span class=\"comment\">// handle the error</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span></span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span> &lt;&lt; pSubFunc(<span class=\"number\">2</span>, <span class=\"number\">3</span>) &lt;&lt; <span class=\"built_in\">std</span>::<span class=\"built_in\">endl</span>; <span class=\"comment\">// call the function</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        pfn pAddFunc = (pfn)GetProcAddress(dllHandle, <span class=\"string\">\"?Add@@YAHHH@Z\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!pAddFunc)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"Load Add() fail\"</span> &lt;&lt; <span class=\"built_in\">std</span>::<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span></span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span> &lt;&lt; pAddFunc(<span class=\"number\">2</span>, <span class=\"number\">3</span>) &lt;&lt; <span class=\"built_in\">std</span>::<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        FreeLibrary(dllHandle);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">else</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"Load FooLibrary.dll fail\"</span> &lt;&lt; <span class=\"built_in\">std</span>::<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n<h3 id=\"Sample-模組定義檔\"><a href=\"#Sample-模組定義檔\" class=\"headerlink\" title=\"Sample 模組定義檔\"></a>Sample 模組定義檔</h3><p>刪掉 <code>Foo.h</code> 裡的 <code>__declspec(dllexport)</code>。</p>\n<figure class=\"highlight plain\"><figcaption><span>Foo.def</span></figcaption><table><tr><td class=\"code\"><pre><span class=\"line\">LIBRARY FooLibrary</span><br><span class=\"line\">EXPORTS</span><br><span class=\"line\">Add</span><br><span class=\"line\">Sub</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">D:\\tmp\\FooLibrary\\Debug&gt;dumpbin &#x2F;EXPORTS FooLibrary.dll</span><br><span class=\"line\">Dump of file FooLibrary.dll</span><br><span class=\"line\"></span><br><span class=\"line\">File Type: DLL</span><br><span class=\"line\"></span><br><span class=\"line\">  Section contains the following exports for FooLibrary.dll</span><br><span class=\"line\"></span><br><span class=\"line\">    00000000 characteristics</span><br><span class=\"line\">    56516FE9 time date stamp Sun Nov 22 15:34:01 2015</span><br><span class=\"line\">        0.00 version</span><br><span class=\"line\">           1 ordinal base</span><br><span class=\"line\">           2 number of functions</span><br><span class=\"line\">           2 number of names</span><br><span class=\"line\"></span><br><span class=\"line\">    ordinal hint RVA      name</span><br><span class=\"line\"></span><br><span class=\"line\">          1    0 0001107D Add &#x3D; @ILT+120(?Add@@YAHHH@Z)</span><br><span class=\"line\">          2    1 000110FA Sub &#x3D; @ILT+245(_Sub)</span><br></pre></td></tr></table></figure>\n\n<p><code>main.cpp</code> 的 <code>GetProcAddress()</code> 可以直接寫 <code>Add</code> 跟 <code>Sub</code>。</p>\n<p><del>其實這是小實驗筆記吧…</del></p>\n<h2 id=\"Ref\"><a href=\"#Ref\" class=\"headerlink\" title=\"Ref\"></a>Ref</h2><ul>\n<li><a href=\"https://msdn.microsoft.com/zh-tw/library/d14wsce5%28v=vs.120%29.aspx\" target=\"_blank\" rel=\"noopener\">https://msdn.microsoft.com/zh-tw/library/d14wsce5%28v=vs.120%29.aspx</a></li>\n<li><a href=\"https://msdn.microsoft.com/zh-tw/library/784bt7z7%28v=vs.120%29.aspx\" target=\"_blank\" rel=\"noopener\">https://msdn.microsoft.com/zh-tw/library/784bt7z7%28v=vs.120%29.aspx</a></li>\n<li><a href=\"https://msdn.microsoft.com/zh-tw/library/zzk20sxw%28v=vs.120%29.aspx\" target=\"_blank\" rel=\"noopener\">https://msdn.microsoft.com/zh-tw/library/zzk20sxw%28v=vs.120%29.aspx</a></li>\n<li><a href=\"https://msdn.microsoft.com/zh-tw/library/windows/desktop/ms684175%28v=vs.85%29.aspx\" target=\"_blank\" rel=\"noopener\">https://msdn.microsoft.com/zh-tw/library/windows/desktop/ms684175%28v=vs.85%29.aspx</a></li>\n<li><a href=\"https://msdn.microsoft.com/zh-tw/library/windows/desktop/ms683212%28v=vs.85%29.aspx\" target=\"_blank\" rel=\"noopener\">https://msdn.microsoft.com/zh-tw/library/windows/desktop/ms683212%28v=vs.85%29.aspx</a></li>\n</ul>\n","tags":["C++","Programming","API","Windows"]},{"title":"Debian 10 Desktop 中文輸入","url":"/Debian-10-Desktop-Chinese/","content":"<p>先安裝 ibus：</p>\n<figure class=\"highlight routeros\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ sudo apt-<span class=\"builtin-name\">get</span> install ibus ibus-chewing</span><br></pre></td></tr></table></figure>\n\n<p>在 <code>~/.bashrc</code>  加入：</p>\n<figure class=\"highlight routeros\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"builtin-name\">export</span> <span class=\"attribute\">GTK_IM_MODULE</span>=ibus</span><br><span class=\"line\"><span class=\"builtin-name\">export</span> <span class=\"attribute\">XMODIFIERS</span>=@im=ibus</span><br><span class=\"line\"><span class=\"builtin-name\">export</span> <span class=\"attribute\">QT_IM_MODULE</span>=ibus</span><br></pre></td></tr></table></figure>\n\n<p>寫個 shell script：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#!/bin/bash</span></span><br><span class=\"line\">ibus-daemon -d -x</span><br></pre></td></tr></table></figure>\n\n<p>在 KDE Setting 的 Autostart 設定啟動時執行 shell script 來啟動 ibus</p>\n","tags":["Linux"]},{"title":"Dependency Injection - Constructor and Setter Injection","url":"/Dependency-Injection-Constructor-and-Setter-Injection/","content":"<p>接下來要 inject dependency object 啦～</p>\n<h2 id=\"Constructor-amp-Setter-Injection\"><a href=\"#Constructor-amp-Setter-Injection\" class=\"headerlink\" title=\"Constructor &amp; Setter Injection\"></a>Constructor &amp; Setter Injection</h2><h3 id=\"Constructor-Injection\"><a href=\"#Constructor-Injection\" class=\"headerlink\" title=\"Constructor Injection\"></a>Constructor Injection</h3><p>在被測試 class 加新的 constructor 或在原本的 constructor 加新參數，傳進剛抽出來的 interface 的 object，將它存在被測試 class 的 member，被測試 class 裡的程式邏輯使用這個 member 做事。</p>\n<a id=\"more\"></a>\n\n<figure class=\"highlight cpp\"><figcaption><span>IFoo.h</span></figcaption><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">pragma</span> once</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">IFoo</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"keyword\">virtual</span> ~IFoo() = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"keyword\">int</span> <span class=\"title\">bar</span><span class=\"params\">()</span> </span>= <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">inline</span> IFoo::~IFoo() &#123; &#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight cpp\"><figcaption><span>Foo.h</span></figcaption><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">pragma</span> once</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">\"IFoo.h\"</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Foo</span> :</span> <span class=\"keyword\">public</span> IFoo &#123;   <span class=\"comment\">// implement IFoo</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">bar</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// do something...</span></span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight cpp\"><figcaption><span>MyClass.h</span></figcaption><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">\"IFoo.h\"</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyClass</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    MyClass(IFoo *pFoo) : m_pFoo(pFoo) &#123;    <span class=\"comment\">// 增加參數</span></span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    ~MyClass() &#123;</span><br><span class=\"line\">        <span class=\"keyword\">delete</span> m_pFoo;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">DoSomething</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        m_pFoo-&gt;bar();      <span class=\"comment\">// 用 member 做事</span></span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    IFoo *m_pFoo;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight cpp\"><figcaption><span>FakeFoo.h</span></figcaption><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">pragma</span> once</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">\"IFoo.h\"</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">FakeFoo</span> :</span> <span class=\"keyword\">public</span> IFoo &#123;   <span class=\"comment\">// implement IFoo</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">bar</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">1</span>;   <span class=\"comment\">// fake something...</span></span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight cpp\"><figcaption><span>main.cpp</span></figcaption><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">\"MyClass.h\"</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">\"Foo.h\"</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">\"FakeFoo.h\"</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// Production code</span></span><br><span class=\"line\">    <span class=\"function\">MyClass <span class=\"title\">obj</span><span class=\"params\">(<span class=\"keyword\">new</span> Foo())</span></span>;</span><br><span class=\"line\">    obj.DoSomething();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Test code</span></span><br><span class=\"line\">    <span class=\"function\">MyClass <span class=\"title\">testObj</span><span class=\"params\">(<span class=\"keyword\">new</span> FakeFoo())</span></span>;</span><br><span class=\"line\">    testObj.DoSomething();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>不同語言對 function 參數以及 constructor 的支援不一，例如 function 參數能不能有預設值、能不能不傳部份參數、constructor 可以有幾個等等，會影響 constructor injection 的實作方式。</p>\n<p>如果 function 參數可以有預設值，以 PHP 為例，實作可以變形成在 constructor 加一個預設值為 <code>null</code> 的參數，在 constructor 中判斷該參數是否為 <code>null</code>，是則產生 depedency object，否則使用傳進來的 object。如此在 production 程式中產生 object 可以不傳參數（假設沒有其他非傳的參數），只在測試中才傳 stub 進被測試 class。這個作法可以不動到 production code 已經使用的被測試 class，在已經寫了 production code 後才加測試很好用。當然這讓 constructor 的參數有 optional 的意思，而非產生 object 的必須參數。</p>\n<figure class=\"highlight php\"><figcaption><span>MyClass.php</span></figcaption><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&lt;?php</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Foo</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">bar</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// Do sth.</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyClass</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> $foo;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">__construct</span><span class=\"params\">($foo = null)</span> </span>&#123;  <span class=\"comment\">// 預設 null</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> ($foo) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">$this</span>-&gt;foo = $foo;      <span class=\"comment\">// injection</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">$this</span>-&gt;foo = <span class=\"keyword\">new</span> Foo;   <span class=\"comment\">// 沒 injection 時使用 dependency object</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">DoSomething</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">$this</span>-&gt;foo-&gt;bar();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Production code</span></span><br><span class=\"line\">$myObj = <span class=\"keyword\">new</span> MyClass;       <span class=\"comment\">// 不需傳參數</span></span><br><span class=\"line\">$myObj-&gt;DoSomething();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Test code</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">FakeFoo</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">bar</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// Fake sth.</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">$testObj = <span class=\"keyword\">new</span> MyClass(<span class=\"keyword\">new</span> FakeFoo);    <span class=\"comment\">// inject stub</span></span><br><span class=\"line\">$testObj-&gt;DoSomething();</span><br></pre></td></tr></table></figure>\n\n<p>C++ 雖然也支援 function 參數預設值，但我不太喜歡用（它在繼承上沒寫好會有些問題），多個 constructor 的例子：</p>\n<figure class=\"highlight cpp\"><figcaption><span>MyClass.h</span></figcaption><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">\"IFoo.h\"</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">\"Foo.h\"</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyClass</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    MyClass() : m_pFoo(<span class=\"keyword\">new</span> Foo()) &#123;     <span class=\"comment\">// 一般 constructor</span></span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    MyClass(IFoo *pFoo) : m_pFoo(pFoo) &#123;    <span class=\"comment\">// constructor injection</span></span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    ~MyClass() &#123;</span><br><span class=\"line\">        <span class=\"keyword\">delete</span> m_pFoo;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">DoSomething</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        m_pFoo-&gt;bar();</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    IFoo *m_pFoo;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight cpp\"><figcaption><span>main.cpp</span></figcaption><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">\"MyClass.h\"</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">\"FakeFoo.h\"</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// Production code</span></span><br><span class=\"line\">    MyClass obj;</span><br><span class=\"line\">    obj.DoSomething();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Test code</span></span><br><span class=\"line\">    <span class=\"function\">MyClass <span class=\"title\">testObj</span><span class=\"params\">(<span class=\"keyword\">new</span> FakeFoo())</span></span>;</span><br><span class=\"line\">    testObj.DoSomething();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>這可以看到 constructor injection 的一個問題：當有愈來愈多 dependency，在 constructor 加入參數或加新的 constructor 會變得愈來愈困難，過多的參數或 constructor 也會降低可讀性。constructor 有愈多參數，參數間如果也有 dependency 關係，constructor 本身的邏輯可能會變得比較複雜。解決這個問題有幾種方式：用 parameter object refactoring 或 Inversion of Control (IoC) container。不過我比較喜歡從設計上就讓 class 間的相依關係不那麼複雜。</p>\n<h3 id=\"Setter-Injection\"><a href=\"#Setter-Injection\" class=\"headerlink\" title=\"Setter Injection\"></a>Setter Injection</h3><p>使用被測試 class 的 setter 來 inject 假物件。</p>\n<p>就……就是用 setter，有點懶得寫例子了。(欸</p>\n<h3 id=\"可測試性與-class-語意\"><a href=\"#可測試性與-class-語意\" class=\"headerlink\" title=\"可測試性與 class 語意\"></a>可測試性與 class 語意</h3><p>加 constructor、constructor 加參數、加 setter 都會稍微改變 class 的語意，目前我傾向以改變最小語意的方式增加可測試性，讓測試描述的被測試 class 使用情境跟 production code 一樣（因為先寫了 production code 才寫測試，會比較以 production code 為主）。如果 production code 不需要 setter 會優先使用 constructor injection，如果本來有 setter 則依照 class 使用方式用 setter injection。</p>\n<h2 id=\"以-factory-取得-dependency-object-的-class\"><a href=\"#以-factory-取得-dependency-object-的-class\" class=\"headerlink\" title=\"以 factory 取得 dependency object 的 class\"></a>以 factory 取得 dependency object 的 class</h2><p>如果被測試程式以 factory 的 static function 產生 dependency object，難以使用 constructor 跟 setter injection。</p>\n<p>怎麼辦咧？在 factory 增加 setter 設定 factory 回傳的物件好在測試中塞假物件到 factory。不過在 factory 加 setter 有些破壞封裝性，可以用些語言特性限制 setter 的 access 範圍（如 C# 的 internal），或者用 <code>#define</code> 跟 <code>#ifdef</code> 讓測試相關的 code 只存於 debug 模式（這寫法的 code 挺難看的），又或者把 setter 取名為 <code>SetXXXForTest()</code>。</p>\n<p>由於 factory 用了 static member（讓 setter 存 inject 的 object），test case 的前或後（setup 或 teardown）要還原 factory 的狀態，不然測試間可能會互相干擾。</p>\n<p>繼續用例子來看，一般使用 factory 取得 dependency object 的情況：</p>\n<figure class=\"highlight cpp\"><figcaption><span>FooFactory.h</span></figcaption><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">pragma</span> once</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">\"Foo.h\"</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">FooFactory</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">static</span> IFoo* <span class=\"title\">createFoo</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> Foo();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight cpp\"><figcaption><span>MyClass.h</span></figcaption><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">\"IFoo.h\"</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">\"FooFactory.h\"</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyClass</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    MyClass() &#123;</span><br><span class=\"line\">        m_pFoo = FooFactory::createFoo();   <span class=\"comment\">// 直接 call static function 難以 constructor injection</span></span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    ~MyClass() &#123;</span><br><span class=\"line\">        <span class=\"keyword\">delete</span> m_pFoo;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">DoSomething</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        m_pFoo-&gt;bar();</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    IFoo *m_pFoo;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>加 setter 的 factory：</p>\n<figure class=\"highlight cpp\"><figcaption><span>FooFactory.h</span></figcaption><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">pragma</span> once</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">\"Foo.h\"</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">FooFactory</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">static</span> IFoo* <span class=\"title\">createFoo</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (m_pFoo) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> m_pFoo;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> Foo();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">SetFoo</span><span class=\"params\">(IFoo *foo)</span> </span>&#123;</span><br><span class=\"line\">        m_pFoo = foo;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    <span class=\"keyword\">static</span> IFoo *m_pFoo;    <span class=\"comment\">// static member</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">IFoo* FooFactory::m_pFoo = <span class=\"literal\">NULL</span>;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight cpp\"><figcaption><span>main.cpp</span></figcaption><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">\"MyClass.h\"</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">\"FakeFoo.h\"</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// Test</span></span><br><span class=\"line\">    FooFactory::SetFoo(<span class=\"keyword\">new</span> FakeFoo());  <span class=\"comment\">// inject</span></span><br><span class=\"line\">    MyClass obj;</span><br><span class=\"line\">    obj.DoSomething();</span><br><span class=\"line\">    FooFactory::SetFoo(<span class=\"literal\">NULL</span>);       <span class=\"comment\">// reset factory (使用 test framework 可以用 teardown 機制)</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Production</span></span><br><span class=\"line\">    MyClass obj2;</span><br><span class=\"line\">    obj2.DoSomething();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"系列文章\"><a href=\"#系列文章\" class=\"headerlink\" title=\"系列文章\"></a>系列文章</h2><ul>\n<li><a href=\"/Dependency-Injection-Extract-Dependency-Object/\">Dependency Injection - Extract Dependency Object</a></li>\n<li><a href=\"/Dependency-Injection-Constructor-and-Setter-Injection/\">Dependency Injection - Constructor and Setter Injection</a></li>\n<li><a href=\"/Dependency-Injection-Extract-and-Override/\">Dependency Injection - Extract and Override</a></li>\n</ul>\n","tags":["Design Pattern","Unit Test"]},{"title":"Dependency Injection - Extract Dependency Object","url":"/Dependency-Injection-Extract-Dependency-Object/","content":"<p>External Dependency 是系統中與被測試程式互動但你無法控制的物件。被測試程式受到 external dependency 行為影響可能有不同結果，為了保持 unit test 穩定，不會一下結果該是 A、一下結果該是 B，我們希望能掌控 external dependency──藉由 <a href=\"/Stub-in-test/\">stub object</a> 模擬 external dependency 的行為並將其 inject 到被測試程式中，基本步驟如下：</p>\n<ol>\n<li>抽出 external dependency object 的 interface</li>\n<li>stub implement 該 interface 並實作 function</li>\n<li>inject stub 到被測試程式<ul>\n<li>Constructor Injection</li>\n<li>Setter Injection</li>\n<li>Extract and Override</li>\n</ul>\n</li>\n</ol>\n<p>本篇用例子說明步驟 1 跟 2：<code>MyClass</code> 是被測試程式，<code>Foo</code> 是 external dependency。（為了讓 code 短一點直接在 header 實作）</p>\n<a id=\"more\"></a>\n\n<figure class=\"highlight cpp\"><figcaption><span>Foo.h</span></figcaption><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">pragma</span> once</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Foo</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">bar</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// do something...</span></span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight cpp\"><figcaption><span>MyClass.h</span></figcaption><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">\"Foo.h\"</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyClass</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">DoSomething</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        Foo *foo = <span class=\"keyword\">new</span> Foo;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> x = foo-&gt;bar();</span><br><span class=\"line\">        <span class=\"comment\">// do something...</span></span><br><span class=\"line\">        <span class=\"keyword\">delete</span> foo;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>首先幫 external dependency <code>Foo</code> 加 interface（C++ 沒有 <code>interface</code> 所以用所有 function 都是 pure virtual function 的 class 當 interface）：</p>\n<figure class=\"highlight cpp\"><figcaption><span>IFoo.h</span></figcaption><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">pragma</span> once</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">IFoo</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"keyword\">virtual</span> ~IFoo() = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"keyword\">int</span> <span class=\"title\">bar</span><span class=\"params\">()</span> </span>= <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">inline</span> IFoo::~IFoo() &#123; &#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight cpp\"><figcaption><span>Foo.h</span></figcaption><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">pragma</span> once</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">\"IFoo.h\"</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Foo</span> :</span> <span class=\"keyword\">public</span> IFoo &#123;   <span class=\"comment\">// implement IFoo</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">bar</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// do something...</span></span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>被測試程式 <code>MyClass</code> 原本直接使用 <code>Foo</code> 的地方改用 interface：</p>\n<figure class=\"highlight cpp\"><figcaption><span>MyClass.h</span></figcaption><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">\"Foo.h\"</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyClass</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">DoSomething</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        IFoo *foo = <span class=\"keyword\">new</span> Foo;    <span class=\"comment\">// 改用 IFoo</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> x = foo-&gt;bar();</span><br><span class=\"line\">        <span class=\"comment\">// do something...</span></span><br><span class=\"line\">        <span class=\"keyword\">delete</span> foo;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>接下來寫個假 class 實作 <code>IFoo</code>，實作相關 function 回傳假資料。</p>\n<p>這個 class 可以以 <code>Fake</code> 開頭命名，表示它是類似某個 class 的假 class。以 <code>Fake</code> 開頭的 class 產生的 object 可以當作 stub 或 mock 使用。</p>\n<figure class=\"highlight cpp\"><figcaption><span>FakeFoo.h</span></figcaption><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">pragma</span> once</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">\"IFoo.h\"</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">FakeFoo</span> :</span> <span class=\"keyword\">public</span> IFoo &#123;   <span class=\"comment\">// implement IFoo</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">bar</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">1</span>;   <span class=\"comment\">// fake something...</span></span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>這邊的例子是 C++，必須 extract interface。在非 strong type 語言，例如 PHP，如果原本 production code 的 dependency object 沒有 interface、只有 unit test 需要的時候，我會偷懶不 extract interface（喂），只讓 fake class 跟原本 class 有一樣 function，甚至只有 test case 會用到的 function。</p>\n<p>有 fake class 後利用 dependency injection 將 stub object inject 進被測試程式，我們就能控制被測試程式的 external dependency，進而控制 test case 及預期被測試程式應有的行為。</p>\n<p>以上是 dependency injection 的前置作業，那我們下回見～（咦）</p>\n<h2 id=\"系列文章\"><a href=\"#系列文章\" class=\"headerlink\" title=\"系列文章\"></a>系列文章</h2><ul>\n<li><a href=\"/Dependency-Injection-Extract-Dependency-Object/\">Dependency Injection - Extract Dependency Object</a></li>\n<li><a href=\"/Dependency-Injection-Constructor-and-Setter-Injection/\">Dependency Injection - Constructor and Setter Injection</a></li>\n<li><a href=\"/Dependency-Injection-Extract-and-Override/\">Dependency Injection - Extract and Override</a></li>\n</ul>\n","tags":["Design Pattern","Unit Test"]},{"title":"Dependency Injection - Extract and Override","url":"/Dependency-Injection-Extract-and-Override/","content":"<p>Extract and Override 是另一種 injection 方式，它幾乎不會改變程式的語意（增加 constructor 的參數或者其他 public 介面等等），寫起來乾淨漂亮。它適合用於模擬回傳值或回傳 stub 或 mock object，不適合用在確認被測試程式與 dependency object 的互動。</p>\n<h2 id=\"Override-factory-method-to-inject-stub\"><a href=\"#Override-factory-method-to-inject-stub\" class=\"headerlink\" title=\"Override factory method to inject stub\"></a>Override factory method to inject stub</h2><ol>\n<li>在被測試 class 加入可被繼承並 override 的 factory method 來取得 dependency object。</li>\n<li>在測試裡新增一個 class 繼承被測試 class，override 該 factory method 回傳 stub object，接著使用測試 class 進行測試。</li>\n</ol>\n<a id=\"more\"></a>\n\n<p>一樣用例子來看，<code>MyClass</code> 是被測試 class，<code>Foo</code> 是 external dependency。</p>\n<p>首先是 <code>Foo</code> 相關的 class：</p>\n<figure class=\"highlight cpp\"><figcaption><span>IFoo.h</span></figcaption><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">pragma</span> once</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">IFoo</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"keyword\">virtual</span> ~IFoo() = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"keyword\">int</span> <span class=\"title\">bar</span><span class=\"params\">()</span> </span>= <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">inline</span> IFoo::~IFoo() &#123; &#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight cpp\"><figcaption><span>Foo.h</span></figcaption><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">pragma</span> once</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">\"IFoo.h\"</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Foo</span> :</span> <span class=\"keyword\">public</span> IFoo &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">bar</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// do something...</span></span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight cpp\"><figcaption><span>FakeFoo.h</span></figcaption><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">pragma</span> once</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">\"IFoo.h\"</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">FakeFoo</span> :</span> <span class=\"keyword\">public</span> IFoo &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">bar</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">1</span>;   <span class=\"comment\">// fake something...</span></span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>下面 <code>MyClass</code> 裡 <code>getFoo()</code> 是取得 <code>Foo</code> 的 factory method，是 <code>protected</code> 及 <code>virtual</code> 讓 derived class override。<code>MyClass</code> 其他部份程式都以 <code>getFoo()</code> 取得 instance 使用。</p>\n<figure class=\"highlight cpp\"><figcaption><span>MyClass.h</span></figcaption><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">\"Foo.h\"</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyClass</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    MyClass() : m_pFoo(<span class=\"literal\">NULL</span>) &#123;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    ~MyClass() &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (m_pFoo) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">delete</span> m_pFoo;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">DoSomething</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        getFoo()-&gt;bar();        <span class=\"comment\">// 使用 factory method 取得 instance</span></span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">protected</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">virtual</span> IFoo* <span class=\"title\">getFoo</span><span class=\"params\">()</span> </span>&#123;        <span class=\"comment\">// 可被 override 的 factory method</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (m_pFoo == <span class=\"literal\">NULL</span>) &#123;</span><br><span class=\"line\">            m_pFoo = <span class=\"keyword\">new</span> Foo();     <span class=\"comment\">// 使用一般 dependency object</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> m_pFoo;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">protected</span>:</span><br><span class=\"line\">    IFoo *m_pFoo;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>至於要有 member 存 dependency object 還是 factory method 直接 <code>return new Foo()</code>，我想是依使用情況跟語言而定。用 member 存的好處是不用 new 很多次，對大物件是好的，壞處則是 class 裡可能會有地方直接使用 member 而非 factory method。另一方面，沒有 garbage collection 的語言像 C++，就得存下來不然一直 new 會 leak 啊。</p>\n<p>最後是 production 以及 test code。</p>\n<p>在 unit test 裡加一個繼承 <code>MyClass</code> 的 class <code>TestableMyClass</code>，override <code>getFoo()</code> 回傳 stub object。一般 production code 使用 <code>MyClass</code>，unit test 使用 <code>TestableMyClass</code> 進行對 <code>MyClass</code> 的測試。</p>\n<figure class=\"highlight cpp\"><figcaption><span>main.cpp</span></figcaption><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">\"MyClass.h\"</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">\"FakeFoo.h\"</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TestableMyClass</span> :</span> <span class=\"keyword\">public</span> MyClass &#123;    <span class=\"comment\">// 繼承被測試 class</span></span><br><span class=\"line\"><span class=\"keyword\">protected</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">virtual</span> IFoo *<span class=\"title\">getFoo</span><span class=\"params\">()</span> </span>&#123;        <span class=\"comment\">// override factory method</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (m_pFoo == <span class=\"literal\">NULL</span>) &#123;</span><br><span class=\"line\">            m_pFoo = <span class=\"keyword\">new</span> FakeFoo();     <span class=\"comment\">// stub object</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> m_pFoo;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// Production code</span></span><br><span class=\"line\">    MyClass *obj = <span class=\"keyword\">new</span> MyClass;</span><br><span class=\"line\">    obj-&gt;DoSomething();</span><br><span class=\"line\">    <span class=\"keyword\">delete</span> obj;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Test code</span></span><br><span class=\"line\">    MyClass *obj2 = <span class=\"keyword\">new</span> TestableMyClass;</span><br><span class=\"line\">    obj2-&gt;DoSomething();</span><br><span class=\"line\">    <span class=\"keyword\">delete</span> obj2;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>如果一個 interface 的 stub 依據測試情境有很多個，例如這邊有 <code>FakeFooForA</code> 跟 <code>FakeFooForB</code>，會需要多個測試 class 繼承 <code>MyClass</code>、override factory method 回傳不同 stub，或者對 <code>TestableMyClass</code> 做 inject，讓它能回傳不同的 stub。</p>\n<h2 id=\"模擬假結果\"><a href=\"#模擬假結果\" class=\"headerlink\" title=\"模擬假結果\"></a>模擬假結果</h2><p>除了在 derived class 裡 override factory method 回傳 stub 外，也可以直接回傳假結果，不需要多抽一個 interface 跟製作 stub。</p>\n<figure class=\"highlight cpp\"><figcaption><span>Foo.h</span></figcaption><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">pragma</span> once</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Foo</span> &#123;</span>     <span class=\"comment\">// 不需要 interface IFoo</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">check</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// Do some check</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight cpp\"><figcaption><span>MyClass.h</span></figcaption><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">\"Foo.h\"</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyClass</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">DoSomething</span><span class=\"params\">()</span> </span>&#123;        <span class=\"comment\">// 被測試 function</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (checkSth()) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// Do something</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">protected</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"keyword\">bool</span> <span class=\"title\">checkSth</span><span class=\"params\">()</span> </span>&#123;   <span class=\"comment\">// 可被 override 的 function</span></span><br><span class=\"line\">        Foo foo;                <span class=\"comment\">// 使用真正的 dependency</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> foo.check();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight cpp\"><figcaption><span>main.cpp</span></figcaption><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">\"MyClass.h\"</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TestableMyClass</span> :</span> <span class=\"keyword\">public</span> MyClass &#123;</span><br><span class=\"line\"><span class=\"keyword\">protected</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"keyword\">bool</span> <span class=\"title\">checkSth</span><span class=\"params\">()</span> </span>&#123;   <span class=\"comment\">// override 直接回傳假結果</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// Production code</span></span><br><span class=\"line\">    MyClass *obj = <span class=\"keyword\">new</span> MyClass;</span><br><span class=\"line\">    obj-&gt;DoSomething();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Test code</span></span><br><span class=\"line\">    MyClass *obj2 = <span class=\"keyword\">new</span> TestableMyClass;</span><br><span class=\"line\">    obj2-&gt;DoSomething();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"系列文章\"><a href=\"#系列文章\" class=\"headerlink\" title=\"系列文章\"></a>系列文章</h2><ul>\n<li><a href=\"/Dependency-Injection-Extract-Dependency-Object/\">Dependency Injection - Extract Dependency Object</a></li>\n<li><a href=\"/Dependency-Injection-Constructor-and-Setter-Injection/\">Dependency Injection - Constructor and Setter Injection</a></li>\n<li><a href=\"/Dependency-Injection-Extract-and-Override/\">Dependency Injection - Extract and Override</a></li>\n</ul>\n<h2 id=\"延伸閱讀\"><a href=\"#延伸閱讀\" class=\"headerlink\" title=\"延伸閱讀\"></a>延伸閱讀</h2><ul>\n<li><a href=\"https://dotblogs.com.tw/hatelove/2015/11/26/unit-test-by-extract-and-override?fbclid=IwAR12Dv2kM0n3_0TT4kmGhJNmZnVoamUYrp5qIms0hm6PaburhO5d5wJagcM\" target=\"_blank\" rel=\"noopener\">[Unit Test Tricks] Extract and Override</a></li>\n</ul>\n","tags":["Design Pattern","Unit Test"]},{"title":"Design Pattern Overview","url":"/Design-Pattern-Overview/","content":"<p>Design Pattern <strong>提供某個情境下針對某問題的某種解決方法</strong>。這些解法通常是前人整理出來、經過驗證的。</p>\n<ul>\n<li>「情境」是某種不斷出現的狀況。</li>\n<li>「問題」是在某個情境下希望達到的目標，也可能是情境下的限制。</li>\n<li>「解決方法」希望是個 general 的設計，用來解決限制、達到目標。</li>\n</ul>\n<p>常用來描述 design pattern 的方式是 GoF 書裡使用的格式。</p>\n<h2 id=\"使用-Design-Pattern\"><a href=\"#使用-Design-Pattern\" class=\"headerlink\" title=\"使用 Design Pattern\"></a>使用 Design Pattern</h2><p><strong>能用簡單方法解決問題就用簡單方法。</strong>pattern 會為系統增加額外複雜度，只有需要的時候才使用。</p>\n<p>使用 pattern 要注意是否有意義以及是否對系統其他部分造成影響，不要為了用而用。如果預期系統在未來會有實際的改變，也可以用 pattern 預先加上彈性。不過要注意，必須是實際的改變，而不是假定的改變。自己覺得可能會改變就用一堆 pattern 也不對，至於什麼叫做「未來實際會有的改變」又是另一個故事了……(喂</p>\n<p>熟悉大部分 pattern 後，需要時大概會知道需要什麼 pattern，接著可以參考 pattern 的 motivation 確認想法對不對，再來要考量會不會對系統造成不良影響。設計上確認後，實作可以參考 UML 跟範例了解實作上的眉眉角角。</p>\n<p>GoF 把 design pattern 分成三大類：creational、structural、behavioral patterns。有時候不知道確切需要哪個 pattern，可以先對問題分類再從類別中找適合的 pattern。</p>\n<h2 id=\"Design-Pattern-分類\"><a href=\"#Design-Pattern-分類\" class=\"headerlink\" title=\"Design Pattern 分類\"></a>Design Pattern 分類</h2><h3 id=\"Creational-pattern\"><a href=\"#Creational-pattern\" class=\"headerlink\" title=\"Creational pattern\"></a>Creational pattern</h3><p>處理「產生 object」。主要的目的有二，一是希望封裝 concrete class，二是想封裝「如何產生並結合 concrete class 的 instance」的過程。</p>\n<ul>\n<li>Abstract Factory</li>\n<li>Builder</li>\n<li>Factory Method</li>\n<li>Prototype</li>\n<li><a href=\"/singleton\">Singleton</a></li>\n</ul>\n<h3 id=\"Structural-pattern\"><a href=\"#Structural-pattern\" class=\"headerlink\" title=\"Structural pattern\"></a>Structural pattern</h3><p>可以合成 class 跟 object 到更大的結構中。</p>\n<ul>\n<li><a href=\"/Adapter-Pattern\">Adapter</a></li>\n<li>Bridge</li>\n<li><a href=\"/Composite-Pattern\">Composite</a></li>\n<li>Decorator</li>\n<li><a href=\"/Facade-Pattern\">Facade</a></li>\n<li>Flyweight</li>\n<li><a href=\"/Proxy-Pattern\">Proxy</a></li>\n</ul>\n<h3 id=\"Behavior-pattern\"><a href=\"#Behavior-pattern\" class=\"headerlink\" title=\"Behavior pattern\"></a>Behavior pattern</h3><p>重點在 class 與 object 間的互動，以及各自的責任。</p>\n<ul>\n<li>Chain of Responsibility</li>\n<li>Command</li>\n<li>Interpreter</li>\n<li><a href=\"/Iterator-Pattern\">Iterator</a></li>\n<li>Mediator</li>\n<li>Memento</li>\n<li><a href=\"/Observer-Pattern\">Observer</a></li>\n<li><a href=\"/State-Pattern\">State</a></li>\n<li><a href=\"/Strategy-Pattern\">Strategy</a></li>\n<li><a href=\"/Template-Method-Pattern\">Template Method</a></li>\n<li>Visitor</li>\n</ul>\n<h2 id=\"Anti-pattern\"><a href=\"#Anti-pattern\" class=\"headerlink\" title=\"Anti-pattern\"></a>Anti-pattern</h2><p>anti-pattern 就是不好的 pattern，告訴大家什麼叫用不好的解決方式解決一個問題，好避免用到這些方法。一個好的 anti-pattern 除了說明不好的方法之外，會建議改用其他 pattern。<del>不然就沒建設性啦</del></p>\n<h2 id=\"pattern-世界\"><a href=\"#pattern-世界\" class=\"headerlink\" title=\"pattern 世界\"></a>pattern 世界</h2><p>除了 design pattern 之外，還有像特定領域如 concurrent 系統的 pattern、組織溝通上的 pattern、UI/UX 的 pattern 等等。pattern 是蠻 general 的概念，在蠻多領域都會出現的，共通的概念是「在面對某種重複出現的情境、狀況或問題時的應對方式」。</p>\n<h2 id=\"Ref\"><a href=\"#Ref\" class=\"headerlink\" title=\"Ref\"></a>Ref</h2><ul>\n<li>《Design Patterns: Elements of Reusable Object-Oriented Software》</li>\n<li>《Head First Design Patterns》</li>\n<li><a href=\"https://en.wikipedia.org/wiki/Software_design_pattern\" target=\"_blank\" rel=\"noopener\">https://en.wikipedia.org/wiki/Software_design_pattern</a></li>\n<li><a href=\"http://hillside.net/\" target=\"_blank\" rel=\"noopener\">http://hillside.net/</a></li>\n</ul>\n","tags":["Design Pattern"]},{"title":"Design Principle","url":"/Design-Principle/","content":"<ul>\n<li><a href=\"/encapsulate-change\">封裝會改變的東西</a></li>\n<li><a href=\"/Open-Closed-Principle\">Open Closed Principle（OCP）</a></li>\n<li><a href=\"/Single-Responsibility-Principle\">Single Responsibility Principle（SRP）</a></li>\n<li><a href=\"/Dont-Repeat-Yourself\">Don’t Repeat Yourself（DRY）</a></li>\n<li><a href=\"/liskov-substitution-principle\">Liskov Substitution Principle（LSP）</a></li>\n</ul>\n<h2 id=\"好萊塢守則\"><a href=\"#好萊塢守則\" class=\"headerlink\" title=\"好萊塢守則\"></a>好萊塢守則</h2><p>低階 component 可以掛到高階 component 上，但是由高階 component 決定何時 call 低階 component，低階 component 不該 call 高階 component。</p>\n<p>這是為了防止 component 之間的 dependency 爛掉，例如高階 component 使用低階 component 也就 depend on 低階 component，低階 component 如果又使用高階 component 就變成互相依賴，再多來幾個 component 就大家通通糊在一起。</p>\n<h2 id=\"Least-Knowledge\"><a href=\"#Least-Knowledge\" class=\"headerlink\" title=\"Least Knowledge\"></a>Least Knowledge</h2><p>系統中的 object 應該只跟它很有關係的 object 互動，不要讓太多 class 綁在一起，免得動一個就動到一大堆。動 A 會動到 B 往往是 bug 的來源……</p>\n<p>設計時要注意物件所互動的 class 有哪些以及是如何互動的。</p>\n<h2 id=\"針對-interface-寫-code，不針對-implement-寫-code\"><a href=\"#針對-interface-寫-code，不針對-implement-寫-code\" class=\"headerlink\" title=\"針對 interface 寫 code，不針對 implement 寫 code\"></a>針對 interface 寫 code，不針對 implement 寫 code</h2><p>想使用某一堆類似的 class 時，應該是讓這些 class 有個 interface 並透過 interface 使用 class，而不是針對特定某個 class 寫 code。如果針對 interface 寫 code，當 class 又增加時可以運用多型在一開始生新的 class 的 object，之後使用該 object 的 code 都可以不用改。</p>\n<h2 id=\"多用合成，少用繼承\"><a href=\"#多用合成，少用繼承\" class=\"headerlink\" title=\"多用合成，少用繼承\"></a>多用合成，少用繼承</h2><p>「合成」像是把東西組起來，是「有」，has-a。「繼承」則是「是」，is-a。</p>\n<p>這我還沒有很懂為什麼……只想到一個爛例子，如果 class A 需要某個功能，例如 parse json，假設已經有一個 json parser 的 class，那麼應該是讓 class A 以合成的方式使用 json parser，而不是去繼承 json parser。這個例子很明顯，用繼承會讓 class A 的語意變得很奇怪，不過不是每種狀況都那麼明顯……</p>\n","tags":["Design Pattern","OOAD"]},{"title":"Don't Repeat Yourself (DRY)","url":"/Dont-Repeat-Yourself/","content":"<p>名稱就說明了它的意思──不要重複。</p>\n<p>這也是概念上的原則。不僅限於不重複相同的程式碼，也包括不要重複相同的程式碼、相同的功能（例如多個軟體間不重複相同的功能）等等，確保一件事情、一項資訊只存在一個地方。</p>\n<p>遵守這個原則的好處是當一件事情需要修改的時候，只需要修改一個地方，不會因為需要改很多地方而漏掉、造成問題。</p>\n<p>DRY 也跟如何好好分解系統有關──如何將每項資訊、功能、程式碼放在單一且合理的地方。</p>\n","tags":["OOAD"]},{"title":"Eclipse and Qt Creator uses Visual C++ compiler and Windows SDK","url":"/Eclipse-and-Qt-Creator-uses-Visual-C++-compiler-and-Windows-SDK/","content":"<p>原本想說既然在 Windows 上開發，用 Visual Studio 好了，但打開網站看到價格，呃，我還是繼續用 Eclipse 跟 Qt Creator  吧！<em>謎版？找謎版的時間我都可以處理好了…</em></p>\n<h2 id=\"Install-Windows-SDK\"><a href=\"#Install-Windows-SDK\" class=\"headerlink\" title=\"Install Windows SDK\"></a>Install Windows SDK</h2><p>安裝 Windows 7 的。</p>\n<p><a href=\"http://www.microsoft.com/en-us/download/details.aspx?id=8279\" target=\"_blank\" rel=\"noopener\">Microsoft Windows SDK for Windows 7 and .NET Framework 4</a></p>\n<h3 id=\"Troubleshooting\"><a href=\"#Troubleshooting\" class=\"headerlink\" title=\"Troubleshooting\"></a>Troubleshooting</h3><p>裝 Windows SDK 失敗，像<a href=\"http://www.mathworks.com/matlabcentral/answers/95039-why-does-the-sdk-7-1-installation-fail-with-an-installation-failed-message-on-my-windows-system\" target=\"_blank\" rel=\"noopener\">這篇</a>的狀況。移掉 Microsoft Visual C++ 2010 redistributable packages 後再裝 Windows SDK 就可以了。</p>\n<p>compile 時遇到 <code>error C2059: syntax error : &#39;constant&#39;</code>，<a href=\"https://github.com/cjwind/patch/tree/master/WindowsSDK71\" target=\"_blank\" rel=\"noopener\">patch</a>。</p>\n<h2 id=\"Eclipse\"><a href=\"#Eclipse\" class=\"headerlink\" title=\"Eclipse\"></a>Eclipse</h2><h3 id=\"Install-CDT-Visual-C-Support\"><a href=\"#Install-CDT-Visual-C-Support\" class=\"headerlink\" title=\"Install CDT Visual C++ Support\"></a>Install CDT Visual C++ Support</h3><p>在 Eclipse 裝 CDT Visual C++ Support，才有 Visual C++ tool chain。我的 Eclipse 是 Juno。</p>\n<p>CDT site：<a href=\"http://download.eclipse.org/tools/cdt/releases/juno\" target=\"_blank\" rel=\"noopener\">http://download.eclipse.org/tools/cdt/releases/juno</a></p>\n<h3 id=\"Configuration\"><a href=\"#Configuration\" class=\"headerlink\" title=\"Configuration\"></a>Configuration</h3><p><strong>Project property</strong></p>\n<p>C/C++ Build -&gt; Tool Chain Editor 的 toolchain 設為 Microsoft Visual C++。</p>\n<p>C/C++ Build -&gt; Environment 增加 PATH C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\bin，這樣才找得到 Visual C++ compiler。</p>\n<p>C/C++ General -&gt; Paths and Symbols -&gt; Includes -&gt; GNU C++</p>\n<p><img src=\"/images/Eclipse_vc_config1.png\" alt=\"Eclipse Configuration\"></p>\n<h2 id=\"Qt-Creator\"><a href=\"#Qt-Creator\" class=\"headerlink\" title=\"Qt Creator\"></a>Qt Creator</h2><p>因為想到要有 GUI 介面，所以需要 Qt + Windows SDK，但現在 Eclipse 跟 Qt 的整合不太好，改用 Qt Creator + Windows SDK。</p>\n<p>直接裝 <a href=\"http://download.qt-project.org/official_releases/qt/5.3/5.3.1/qt-opensource-windows-x86-msvc2010_opengl-5.3.1.exe\" target=\"_blank\" rel=\"noopener\">Qt 5.3.1 for Windows 32-bit (VS 2010, OpenGL, 537 MB)</a></p>\n<h3 id=\"Kits\"><a href=\"#Kits\" class=\"headerlink\" title=\"Kits\"></a>Kits</h3><p>如果已經先裝其他版本的 Qt，應該可以在選項裡加 Kit：</p>\n<p><img src=\"/images/QtCreator_WinSDK_kit.png\" alt=\"Qt Creator Windows SDK Kits\"></p>\n<h3 id=\"pro-setting\"><a href=\"#pro-setting\" class=\"headerlink\" title=\"pro setting\"></a>pro setting</h3><p><code>INCLUDEPATH</code> 要加 Windows SDK 的路徑，如 Eclipse Configuration 圖中的路徑。</p>\n<h3 id=\"Troubleshooting-1\"><a href=\"#Troubleshooting-1\" class=\"headerlink\" title=\"Troubleshooting\"></a>Troubleshooting</h3><p>compile 時遇到 <code>LINK : fatal error LNK1123: failure during conversion to COFF: file invalid or corrupt</code> 的錯誤。</p>\n<p>Solution：<a href=\"http://qt-project.org/wiki/Category:Tools::msvc\" target=\"_blank\" rel=\"noopener\">http://qt-project.org/wiki/Category:Tools::msvc</a></p>\n","tags":["Eclipse","Qt Creator","Tip"]},{"title":"Executable Format（可執行檔格式）","url":"/Executable-Format/","content":"<p>Executable Format 主要有：</p>\n<ul>\n<li>Windows 下的 PE（Portable Executable）</li>\n<li>Linux 下的 ELF（Executable Linkable Format）</li>\n</ul>\n<p>其他還有 Intel/Microsoft 的 OMF（Object Module Format）、Unix 的 a.out 以及 MS-DOS COM 格式等等。</p>\n<p>除了可執行檔外，Dynamic Linking Library 跟 Static Linking Library 都是以 Executable Format 儲存。</p>\n<p>ELF 標準中將使用 ELF 格式的檔案分成：</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">ELF file type</th>\n<th align=\"center\">Example</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">Relocatable File</td>\n<td align=\"center\">Linux 的 .o、Windows 的 .obj</td>\n</tr>\n<tr>\n<td align=\"center\">Executable File</td>\n<td align=\"center\">/bin/bash、Windows 的 .exe</td>\n</tr>\n<tr>\n<td align=\"center\">Shared Object File</td>\n<td align=\"center\">Linux 的 .so、Windows 的 .dll</td>\n</tr>\n<tr>\n<td align=\"center\">Core Dump File</td>\n<td align=\"center\">Linux 的 core dump</td>\n</tr>\n</tbody></table>\n<h2 id=\"ELF-file-structure\"><a href=\"#ELF-file-structure\" class=\"headerlink\" title=\"ELF file structure\"></a>ELF file structure</h2><p>ELF 檔是由 header、一堆 section 及一堆 table 組成的，各 table 也是 section。</p>\n<p><img src=\"/images/elf_structure.png\" alt=\"ELF structure\"></p>\n<h3 id=\"ELF-Header\"><a href=\"#ELF-Header\" class=\"headerlink\" title=\"ELF Header\"></a>ELF Header</h3><p>描述整個 ELF 檔的屬性，可用 <code>readelf -h xxx</code> 查看。</p>\n<p>struct 定義在 <code>/usr/inclue/elf.h</code>，<code>Elf32_Ehdr</code> or <code>Elf64_Ehdr</code>。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">  <span class=\"keyword\">unsigned</span> <span class=\"keyword\">char</span> e_ident[EI_NIDENT]; <span class=\"comment\">/* Magic number and other info */</span></span><br><span class=\"line\">  Elf32_Half    e_type;         <span class=\"comment\">/* Object file type */</span></span><br><span class=\"line\">  Elf32_Half    e_machine;      <span class=\"comment\">/* Architecture */</span></span><br><span class=\"line\">  Elf32_Word    e_version;      <span class=\"comment\">/* Object file version */</span></span><br><span class=\"line\">  Elf32_Addr    e_entry;        <span class=\"comment\">/* Entry point virtual address */</span></span><br><span class=\"line\">  Elf32_Off e_phoff;        <span class=\"comment\">/* Program header table file offset */</span></span><br><span class=\"line\">  Elf32_Off e_shoff;        <span class=\"comment\">/* Section header table file offset */</span></span><br><span class=\"line\">  Elf32_Word    e_flags;        <span class=\"comment\">/* Processor-specific flags */</span></span><br><span class=\"line\">  Elf32_Half    e_ehsize;       <span class=\"comment\">/* ELF header size in bytes */</span></span><br><span class=\"line\">  Elf32_Half    e_phentsize;        <span class=\"comment\">/* Program header table entry size */</span></span><br><span class=\"line\">  Elf32_Half    e_phnum;        <span class=\"comment\">/* Program header table entry count */</span></span><br><span class=\"line\">  Elf32_Half    e_shentsize;        <span class=\"comment\">/* Section header table entry size */</span></span><br><span class=\"line\">  Elf32_Half    e_shnum;        <span class=\"comment\">/* Section header table entry count */</span></span><br><span class=\"line\">  Elf32_Half    e_shstrndx;     <span class=\"comment\">/* Section header string table index */</span></span><br><span class=\"line\">&#125; Elf32_Ehdr;</span><br></pre></td></tr></table></figure>\n\n<p><code>e_ident</code> 是 magic number 標示這是個 ELF 檔，前 4 個 byte 依序是 0x7f、0x45、0x4c、0x446，接著 3 個 byte 是 “ELF” 三個字母的 ASCII code。所有 ELF 檔前幾個 byte 都是這個內容。除此之外，幾乎所有可執行檔最開始幾個 byte 都是 magic number，供 OS 識別是哪種可執行檔。</p>\n<p><code>e_phoff</code> 表示程式執行時的入口位置，executable file 會填入 address，relocatable file 因為還會進行 relocate 所以值是 0。</p>\n<p>從 section header table file offset <code>e_shoff</code> 可以知道 section table 所在位置，由 <code>e_shentsize</code> 及 <code>e_shnum</code> 可以知道 section header table 的 element size 以及總共有多少 element。從 ELF header 可以找到 section header table，由於其他 table 也都是 section，可以再從 section header table 取得所有其他 section 及 table 的資訊。</p>\n<h3 id=\"Section-Header-Table\"><a href=\"#Section-Header-Table\" class=\"headerlink\" title=\"Section Header Table\"></a>Section Header Table</h3><p>描述各 section 的屬性，可用 <code>readelf -S xxx</code> 查看。</p>\n<p>一個以 struct <code>Elf32_Shdr</code>（又稱 section descriptor）為 element 的 array，array 的第一個 element 是 NULL，struct 定義在 <code>/usr/include/elf.h</code>。因為 section header table 是個 array，所以 ELF 檔有些地方會以 section 在 section table 中的 index 來 access 或表示該 section。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">  Elf32_Word    sh_name;        <span class=\"comment\">/* Section name (string tbl index) */</span></span><br><span class=\"line\">  Elf32_Word    sh_type;        <span class=\"comment\">/* Section type */</span></span><br><span class=\"line\">  Elf32_Word    sh_flags;       <span class=\"comment\">/* Section flags */</span></span><br><span class=\"line\">  Elf32_Addr    sh_addr;        <span class=\"comment\">/* Section virtual addr at execution */</span></span><br><span class=\"line\">  Elf32_Off sh_offset;      <span class=\"comment\">/* Section file offset */</span></span><br><span class=\"line\">  Elf32_Word    sh_size;        <span class=\"comment\">/* Section size in bytes */</span></span><br><span class=\"line\">  Elf32_Word    sh_link;        <span class=\"comment\">/* Link to another section */</span></span><br><span class=\"line\">  Elf32_Word    sh_info;        <span class=\"comment\">/* Additional section information */</span></span><br><span class=\"line\">  Elf32_Word    sh_addralign;       <span class=\"comment\">/* Section alignment */</span></span><br><span class=\"line\">  Elf32_Word    sh_entsize;     <span class=\"comment\">/* Entry size if section holds table */</span></span><br><span class=\"line\">&#125; Elf32_Shdr;</span><br></pre></td></tr></table></figure>\n\n<p>如果一個 section 存在 ELF 檔中，由 <code>sh_offset</code> 及 <code>sh_size</code> 可以知道其所在位置及大小。section 屬性主要由 section type <code>sh_type</code> 及 section flags <code>sh_flags</code> 決定。</p>\n<h3 id=\"String-Table\"><a href=\"#String-Table\" class=\"headerlink\" title=\"String Table\"></a>String Table</h3><p><code>.strtab</code> 以及 <code>.shstrtab</code> section。</p>\n<p>將 ELF 檔裡所用的字串，如 variable name、function name、section name 等存在一個 array 中，以 <code>&#39;\\0&#39;</code> 隔開，並以字串在 array 中的 offset 表示該字串。</p>\n<h3 id=\"Symbol-Table\"><a href=\"#Symbol-Table\" class=\"headerlink\" title=\"Symbol Table\"></a>Symbol Table</h3><p><code>.symtab</code> section，可用 <code>readelf -s xxx</code> 查看。</p>\n<p>記錄 object file 所用到的 symbol。每個 symbol 有其對應的 symbol value，variable 及 function 的 symbol value 是它們的 address。</p>\n<p>symbol table 是以 struct <code>Elf32_Sym</code> 為 element 的 array，<code>Elf32_Sym</code> 一樣定義在 <code>/usr/include/elf.h</code>。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">  Elf32_Word    st_name;        <span class=\"comment\">/* Symbol name (string tbl index) */</span></span><br><span class=\"line\">  Elf32_Addr    st_value;       <span class=\"comment\">/* Symbol value */</span></span><br><span class=\"line\">  Elf32_Word    st_size;        <span class=\"comment\">/* Symbol size */</span></span><br><span class=\"line\">  <span class=\"keyword\">unsigned</span> <span class=\"keyword\">char</span> st_info;        <span class=\"comment\">/* Symbol type and binding */</span></span><br><span class=\"line\">  <span class=\"keyword\">unsigned</span> <span class=\"keyword\">char</span> st_other;       <span class=\"comment\">/* Symbol visibility */</span></span><br><span class=\"line\">  Elf32_Section st_shndx;       <span class=\"comment\">/* Section index */</span></span><br><span class=\"line\">&#125; Elf32_Sym;</span><br></pre></td></tr></table></figure>\n\n<p>對 linking 較重要的兩種 symbol：global symbol 及 external symbol。global symbol 是定義在此 object file 中並且會讓其他 object file 使用到的 symbol，external symbol 則是此 object file reference 到的其他 object file 中的 symbol。簡單講就是給別人用跟用別人的 symbol，有點繞舌。</p>\n<h3 id=\"Relocation-tables\"><a href=\"#Relocation-tables\" class=\"headerlink\" title=\"Relocation tables\"></a>Relocation tables</h3><p>存 relocation 的資訊，<code>.rel.text</code> section。每個需要 relocate 的 section 都會有一個 relocation table。</p>\n<p>relocation 可參考 <a href=\"/Static-Link\">Static Link</a>。</p>\n<h2 id=\"Linking-View-and-Execuion-View\"><a href=\"#Linking-View-and-Execuion-View\" class=\"headerlink\" title=\"Linking View and Execuion View\"></a>Linking View and Execuion View</h2><p>上述以 <strong>section</strong> 來劃分 ELF 內容的角度是 <strong>Linking View</strong>。</p>\n<p>ELF 在 mapping 到 virtual address space 時是以 page 為單位，如果 section 的大小不是 page 大小的整數倍又以 section 為單位進行 mapping，會浪費許多 memory。load ELF 時 OS 只在乎 section 的屬性如可讀、可寫、可執行，OS 不在乎 section 的內容，為了節省記憶體空間延伸出<strong>「將屬性相同的 section 合併成一個 segment，再對應到 virtual address space」</strong>的方式。linker 在 link object file 時會盡量將相同屬性的 section 放在一起。</p>\n<p>segment 是以 load 的角度劃分 ELF，也就是 <strong>Execution View</strong>。</p>\n<h2 id=\"Ref\"><a href=\"#Ref\" class=\"headerlink\" title=\"Ref\"></a>Ref</h2><ul>\n<li><a href=\"http://refspecs.linuxbase.org/elf/elf.pdf\" target=\"_blank\" rel=\"noopener\">http://refspecs.linuxbase.org/elf/elf.pdf</a></li>\n<li><a href=\"http://en.wikipedia.org/wiki/Executable_and_Linkable_Format\" target=\"_blank\" rel=\"noopener\">http://en.wikipedia.org/wiki/Executable_and_Linkable_Format</a></li>\n<li>《程式設計師的自我修養》ch 3, 6</li>\n</ul>\n","tags":["System Software"]},{"title":"Facade Pattern","url":"/Facade-Pattern/","content":"<p>Facade 定義較簡單（抽象程度更高）的 interface 來讓 client 更容易使用複雜的 sub system。</p>\n<p>目的在簡化 sub system 的使用方式。</p>\n<h2 id=\"使用情境\"><a href=\"#使用情境\" class=\"headerlink\" title=\"使用情境\"></a>使用情境</h2><p>sub system 提供很多功能與 interface 但太複雜，希望有簡單的方式使用 sub system。</p>\n<h2 id=\"UML\"><a href=\"#UML\" class=\"headerlink\" title=\"UML\"></a>UML</h2><p><img src=\"/images/facade_pattern.png\" alt=\"Facade Pattern\"></p>\n<p>Facade 沒有封裝 sub system，只是提供簡化的 interface 方便使用。</p>\n<p>client 可以用 Facade 的簡單 interface，也可以使用原本 sub system 提供的 interface。就像有些軟體在設定頁只放一般常用設定，需要調整細部設定的使用者再按「進階」鈕進入設定。</p>\n<h2 id=\"相關-pattern\"><a href=\"#相關-pattern\" class=\"headerlink\" title=\"相關 pattern\"></a>相關 pattern</h2><ul>\n<li><a href=\"/Adapter-Pattern/\">Adapater</a></li>\n</ul>\n","tags":["Design Pattern"]},{"title":"Git diff & patch","url":"/Git-diff-and-patch/","content":"<p>用 Git diff 生 patch file</p>\n<p><code>$ git diff [file] &gt; [path_file]</code></p>\n<p>上 patch</p>\n<p><code>$ patch -p1 &lt; [path_file]</code></p>\n<ul>\n<li>加 <code>-d [dir path]</code> 可以切換 directory</li>\n</ul>\n<h2 id=\"Ref\"><a href=\"#Ref\" class=\"headerlink\" title=\"Ref\"></a>Ref</h2><ul>\n<li><a href=\"https://blog.longwin.com.tw/2013/08/linux-diff-patch-learn-note-2013/\" target=\"_blank\" rel=\"noopener\">https://blog.longwin.com.tw/2013/08/linux-diff-patch-learn-note-2013/</a></li>\n</ul>\n","tags":["Linux","Git"]},{"title":"Go 多維 array 與 slice","url":"/Go-multi-dimention-array-and-slice/","content":"<blockquote>\n<p>Array types are always one-dimensional but may be composed to form multi-dimensional types.</p>\n</blockquote>\n<p>from <a href=\"https://golang.org/ref/spec#Array_types\" target=\"_blank\" rel=\"noopener\">spec Array types</a></p>\n<blockquote>\n<p>A slice is a descriptor for a contiguous segment of an underlying array and provides access to a numbered sequence of elements from that array.<br>…<br>Like arrays, slices are always one-dimensional but may be composed to construct higher-dimensional objects.</p>\n</blockquote>\n<p>from <a href=\"https://golang.org/ref/spec#Slice_types\" target=\"_blank\" rel=\"noopener\">spec Slice types</a></p>\n<h1 id=\"Initialization\"><a href=\"#Initialization\" class=\"headerlink\" title=\"Initialization\"></a>Initialization</h1><h2 id=\"Slice\"><a href=\"#Slice\" class=\"headerlink\" title=\"Slice\"></a>Slice</h2><p>在多維的情況下，inner slice 只能一個個初始化，像這樣：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\">x := <span class=\"built_in\">make</span>([][]<span class=\"keyword\">byte</span>, <span class=\"number\">2</span>)</span><br><span class=\"line\"><span class=\"keyword\">for</span> i := <span class=\"keyword\">range</span> x &#123;</span><br><span class=\"line\">    x[i] = <span class=\"built_in\">make</span>([]<span class=\"keyword\">byte</span>, <span class=\"number\">1000</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>上面例子沒有迴圈直接去 access <code>x[0][0]</code> 的話會 <code>index out of range</code>。</p>\n<p>或者用 literal 直接寫：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\">a := [][]<span class=\"keyword\">uint8</span>&#123;</span><br><span class=\"line\">    &#123;<span class=\"number\">0</span>, <span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>&#125;,</span><br><span class=\"line\">    &#123;<span class=\"number\">4</span>, <span class=\"number\">5</span>, <span class=\"number\">6</span>, <span class=\"number\">7</span>&#125;,</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Array\"><a href=\"#Array\" class=\"headerlink\" title=\"Array\"></a>Array</h2><p>初始化成零值比較簡單：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\">c := [<span class=\"number\">5</span>][<span class=\"number\">5</span>]<span class=\"keyword\">uint8</span>&#123;&#125;</span><br><span class=\"line\"><span class=\"comment\">// [[0 0 0 0 0] [0 0 0 0 0] [0 0 0 0 0] [0 0 0 0 0] [0 0 0 0 0]]</span></span><br></pre></td></tr></table></figure>\n\n<h1 id=\"Memory-Size\"><a href=\"#Memory-Size\" class=\"headerlink\" title=\"Memory Size\"></a>Memory Size</h1><p>多維 array 的 size 是 <code>type size * element 數量</code> 。</p>\n<p>多維 slice 的 size 則要看多維 slice 是怎麼組成的。slice 由指向 underlying array 的 pointer、length、capacity 組成，多維 slice 不同的組合方式會造成有不同數量的 slice header 而有不同的 size，來個例子：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// x 是 2 x 1000 的 slice</span></span><br><span class=\"line\">x := <span class=\"built_in\">make</span>([][]<span class=\"keyword\">byte</span>, <span class=\"number\">2</span>)</span><br><span class=\"line\"><span class=\"keyword\">for</span> i := <span class=\"keyword\">range</span> x &#123;</span><br><span class=\"line\">    x[i] = <span class=\"built_in\">make</span>([]<span class=\"keyword\">byte</span>, <span class=\"number\">1000</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">fmt.Println(<span class=\"built_in\">len</span>(x), <span class=\"built_in\">len</span>(x)*<span class=\"built_in\">len</span>(x[<span class=\"number\">0</span>]))</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// y 是 1000 x 2 的 slice</span></span><br><span class=\"line\">y := <span class=\"built_in\">make</span>([][]<span class=\"keyword\">byte</span>, <span class=\"number\">1000</span>)</span><br><span class=\"line\"><span class=\"keyword\">for</span> i := <span class=\"keyword\">range</span> y &#123;</span><br><span class=\"line\">    y[i] = <span class=\"built_in\">make</span>([]<span class=\"keyword\">byte</span>, <span class=\"number\">2</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">fmt.Println(<span class=\"built_in\">len</span>(y), <span class=\"built_in\">len</span>(y)*<span class=\"built_in\">len</span>(y[<span class=\"number\">0</span>]))</span><br></pre></td></tr></table></figure>\n\n<p>output 是：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">2</span> <span class=\"number\">2000</span></span><br><span class=\"line\"><span class=\"number\">1000</span> <span class=\"number\">2000</span></span><br></pre></td></tr></table></figure>\n\n<p>x 跟 y 都是多維 slice 而且都有 2000 個 element。x 只有兩個 slice、每個 slice 有 1000 個 element byte，y 有 1000 個 slice、每個 slice 只有兩個 element。</p>\n<p>slice header 長這樣：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> SliceHeader <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">    Data <span class=\"keyword\">uintptr</span></span><br><span class=\"line\">    Len  <span class=\"keyword\">int</span></span><br><span class=\"line\">    Cap  <span class=\"keyword\">int</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>from <a href=\"https://golang.org/pkg/reflect/#SliceHeader\" target=\"_blank\" rel=\"noopener\">SliceHeader</a></p>\n<p>在 64-bit 平台上，一個 slice header 的 size 是 24 bytes。那麼 x 的總 size 是 2000 + 2 * 24 = 2048 bytes。而 y 的總 size 則是 2000 + 1000 * 24 = 26000 bytes。</p>\n<p>所以啦，考量 memory 使用的時候，需要注意多維 slice 是怎麼組的，像上面的 y，slice header 的 size 遠超過全部 element 的 size。</p>\n<h1 id=\"Inner-array-slice-length\"><a href=\"#Inner-array-slice-length\" class=\"headerlink\" title=\"Inner array/slice length\"></a>Inner array/slice length</h1><blockquote>\n<p>With arrays of arrays, the inner arrays are, by construction, always the same length; however with slices of slices (or arrays of slices), the inner lengths may vary dynamically. Moreover, the inner slices must be initialized individually.</p>\n</blockquote>\n<p>多維 array 的 inner array 都是相同 length 的。</p>\n<p>多維 slice 的 inner slice 可以是不同 length。另外，inner slice 必須要各自 initialize。</p>\n<h1 id=\"Ref\"><a href=\"#Ref\" class=\"headerlink\" title=\"Ref\"></a>Ref</h1><ul>\n<li><a href=\"https://stackoverflow.com/questions/39804861/what-is-a-concise-way-to-create-a-2d-slice-in-go\" target=\"_blank\" rel=\"noopener\">What is a concise way to create a 2D slice in Go?</a></li>\n<li><a href=\"https://stackoverflow.com/questions/39561140/how-is-two-dimensional-arrays-memory-representation\" target=\"_blank\" rel=\"noopener\">How is two dimensional array’s memory representation</a></li>\n</ul>\n","tags":["Go"]},{"title":"Hexo hacking","url":"/Hexo-hacking/","content":"<h2 id=\"前置作業\"><a href=\"#前置作業\" class=\"headerlink\" title=\"前置作業\"></a>前置作業</h2><p>安裝 <a href=\"http://nodejs.org/\" target=\"_blank\" rel=\"noopener\">Node.js</a></p>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> git <span class=\"built_in\">clone</span> https://github.com/hexojs/hexo</span></span><br><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> <span class=\"built_in\">cd</span> hexo</span></span><br><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> npm install</span></span><br><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> git submodule update --init</span></span><br></pre></td></tr></table></figure>\n\n<p><code>npm install</code> 應該是為了把需要的 node module 裝起來。</p>\n<p>修改後直接 run <code>bin/hexo</code> 即可。</p>\n<h2 id=\"改以-updated-排序-post\"><a href=\"#改以-updated-排序-post\" class=\"headerlink\" title=\"改以 updated 排序 post\"></a>改以 updated 排序 post</h2><p>抄 <a href=\"http://goo.gl/63S6ui\" target=\"_blank\" rel=\"noopener\">http://goo.gl/63S6ui</a> 的，可從 <code>_config.yml</code> 設定 post 以 date 或 updated 排序。如果 post 沒有設 updated，updated 時間會等於 date。</p>\n<p><a href=\"https://github.com/cjwind/Hexx/commit/f72a82107b4f325a4dfe23641aac78533a499bae\" target=\"_blank\" rel=\"noopener\">https://github.com/cjwind/Hexx/commit/f72a82107b4f325a4dfe23641aac78533a499bae</a><br><a href=\"https://github.com/cjwind/Hexx/commit/d115baf9e2d516684d637d79d22f0177129daa0b\" target=\"_blank\" rel=\"noopener\">https://github.com/cjwind/Hexx/commit/d115baf9e2d516684d637d79d22f0177129daa0b</a></p>\n<p><em>耍蠢所以變成兩個 commit</em></p>\n<h2 id=\"Ref\"><a href=\"#Ref\" class=\"headerlink\" title=\"Ref\"></a>Ref</h2><ul>\n<li><a href=\"http://hexo.io/docs/contributing.html\" target=\"_blank\" rel=\"noopener\">http://hexo.io/docs/contributing.html</a></li>\n<li><a href=\"https://github.com/tommy351/hexo/issues/376\" target=\"_blank\" rel=\"noopener\">https://github.com/tommy351/hexo/issues/376</a></li>\n</ul>\n","tags":["Hexo","Blog"]},{"title":"在多台電腦寫 Hexo blog","url":"/Hexo-in-multiple-machines/","content":"<p>簡單記錄一下。</p>\n<p>我把 <code>node_modules/</code>、<code>scaffolds/</code>、<code>source/</code>、<code>themes/</code>、<code>_config.yml</code>、<code>package.json</code> 放到 bitbucket 的 private git repository，另一台電腦裝 node.js 跟 hexo，clone repository 下來就可以了。</p>\n<p>原本順利弄完也就好了，我就手賤的做了 <code>npm update -g</code> 更新 hexo，然後 generate 就爛了。後來約莫是 <code>hexo init .</code> 再 <code>npm install</code>，然後 merge 一些改過的 theme 檔案跟 config，才總算好了。</p>\n","tags":["Hexo","Blog"]},{"title":"Google 模式","url":"/How-Google-Works/","content":"<p>不愧是技術出身的人創辦的公司，完全以技術為重。喜歡這本書所呈現的務實觀，以真正做出好用東西為最高原則的務實。 </p>\n<h2 id=\"職業生涯\"><a href=\"#職業生涯\" class=\"headerlink\" title=\"職業生涯\"></a>職業生涯</h2><blockquote>\n<p>思考五年後你希望從事的理想工作，你希望在哪裡工作？你想做什麼？希望賺多少錢？敘述這個職務：如果你在網路上看到這個工作機會，徵才內容會是什麼？現在，快轉到四、五年後，假設你在做這份工作，你這五年間的履歷表內容是什麼模樣？從現在起，你經過哪些途徑，到達那個時候的理想工作？</p>\n<p>持續想著這份理想工作，根據它來評估你目前的長處與缺點，你需要做出哪些改進？這一步需要外人提供的意見，因此和你的經理或同儕談談，徵詢他們的意見。最後，你要如何獲得這份理想工作？你需要哪些訓練？需要什麼工作經驗？</p>\n</blockquote>\n<p>我想補充，思考職涯前要先想生涯，因為工作是生活的一部份，是讓工作配合生活，而不是反過來。你重視的是什麼？想要的生活是什麼？現在有的是什麼？有什麼能力能幫助你獲得想要的？</p>\n<p>釐清生涯之後才去想怎麼樣的工作能配合？畢竟，有偉大的理想或願景很好，但那並不是每個人都想要的。每個人重要的事物都不同，本來就不該用一套標準套用在所有人。</p>\n<h2 id=\"共識跟搖鈴\"><a href=\"#共識跟搖鈴\" class=\"headerlink\" title=\"共識跟搖鈴\"></a>共識跟搖鈴</h2><p>所謂共識，在於找到最佳方法，而不是用自己的方法。 </p>\n<p>最佳方法應該是對團隊、對工作最有益的。</p>\n<p>然後呢，討論要有人拿捏什麼時候該喊停做出結論，會開得久但沒結論實在是很浪費。</p>\n<h2 id=\"歐普拉法則\"><a href=\"#歐普拉法則\" class=\"headerlink\" title=\"歐普拉法則\"></a>歐普拉法則</h2><blockquote>\n<p>科技人常犯一個錯，總認為如果根據資料和明智的分析提出一個聰明、考慮周到的論點，人們就會改變他們的看法。其實不然。如果你想改變人們的行為，你不能只在論點上勝出，你必須感動他們的心</p>\n</blockquote>\n<p>（狀態顯示為中箭）</p>\n<p>要說故事讓人家有 fu，才會想去做那件事……</p>\n<p>想想也是，人不是理性的生物呀~ˊ_&gt;ˋ</p>\n<h2 id=\"70-20-10-的資源分配法則\"><a href=\"#70-20-10-的資源分配法則\" class=\"headerlink\" title=\"70/20/10 的資源分配法則\"></a>70/20/10 的資源分配法則</h2><p>70% 資源用於核心事業，20% 資源用於有一些小成功的新產品，10% 資源分配給全新的計畫。</p>\n<p>這是資源分配喔，不是那個 20% 時間。這邊指的資源應該是人員，畢竟 Google 做軟體的，資源最主要就是人了。</p>\n<p>投資高風險的新東西要小心過度投資，過度投資會讓人想回收過去投注的資源而傾向只看好的、不容易承認失敗或錯誤，簡單講就是個賭徒的概念。(欸)</p>\n<h2 id=\"20-時間計畫\"><a href=\"#20-時間計畫\" class=\"headerlink\" title=\"20% 時間計畫\"></a>20% 時間計畫</h2><p>20% 時間計劃應該是 Google 有名的制度之一。</p>\n<p>重點在自由而不在時間，重點在可以自由地去做想做的事。</p>\n<blockquote>\n<p>根據自我決定理論，人類對於自主（根據自己的意志和抉擇而行為，而非受外界施壓而行為）、勝任能力，以及和其他人的關聯都有強烈的需求。自我決定理論認為，人們是否覺得他們的工作有動力且有成就感，有相當程度取決於工作能否滿足他們的這些需求。</p>\n</blockquote>\n<p>20% 時間計畫不需要金錢酬勞，因為他們不想讓外在獎酬取代內在獎酬而扼殺創造力。</p>\n<p>看起來也不是一個自己悶著頭做就行的，除了有點子之外也要能吸引其他人一起加入。</p>\n<p>從書中看起來，20% 時間要產生很棒的新產品不是很容易，它需要員工有足夠的自身動力，更需要有無數無數的時間與嘗試。如書中所說，20% 時間產生的產品或功能並非最重要的「產出」，真正重要的是在過程中得到經驗以及學習的智慧創作者，這些經驗會帶在這些人身上繼續下一次的發揮。比起產生新創產品，20% 時間或許更重要的反而是在教育訓練上。</p>\n<p>20% 時間與其說是 Google 的一個與眾不同的制度，不如說他們只是將那種鼓勵創新、不怕失敗的文化變成一個制度。先有文化才有制度，而不是想以這個制度去培養創新文化，先後順序不一樣的。 </p>\n<h2 id=\"詢問困難的問題\"><a href=\"#詢問困難的問題\" class=\"headerlink\" title=\"詢問困難的問題\"></a>詢問困難的問題</h2><p>「當這家公司的成功與獲利最仰賴的競爭優勢消失時，公司該怎麼辦？」</p>\n<p>在剛開始看到對手的時候，甚至在更早、還很順利的時候就詢問困難的問題，然後思考對策、解決方式。</p>\n<p>問這問題難，難在這樣的問題令人不安。回答這樣的問題也難，但沒有好的答案能問出問題總是一線希望。</p>\n<p>最後書中也列舉許多重要的問題，當作結語總結整本書。</p>\n","tags":["Reading"]},{"title":"Iterator Pattern","url":"/Iterator-Pattern/","content":"<p><strong>讓使用者能取得一個 collection 內的每個 element，而不需要暴露此 collection 的 implememtation。</strong></p>\n<p>Iterator Pattern 封裝了「拿出下一個 element」這件事，讓外部可以不需要知道 collection 實際上以什麼方式實作，如 array、list、stack 等等，就能以一致的方式取得 element。iterator 也讓 collection 的責任更簡單，collection 負責管理一群 object，而 iterator 負責 traverse element。</p>\n<h2 id=\"使用情境\"><a href=\"#使用情境\" class=\"headerlink\" title=\"使用情境\"></a>使用情境</h2><p>有多種 collection 一同使用，希望能用同樣方式 traverse element 時。</p>\n<h2 id=\"UML\"><a href=\"#UML\" class=\"headerlink\" title=\"UML\"></a>UML</h2><p><img src=\"/images/iterator_pattern.png\" alt=\"Iterator Pattern\"></p>\n<h2 id=\"library-及語言支援\"><a href=\"#library-及語言支援\" class=\"headerlink\" title=\"library 及語言支援\"></a>library 及語言支援</h2><p>C++ STL、Qt、Java 等等的 container 都有支援 iterator。用 iterator 要注意 iterate 過程中能不能更動該 container，因為 iterator 會直接或間接的 access container 內部資料，所以不同實作方式會影響 iterator 的使用。例如 Qt 對 container 用 <a href=\"http://doc.qt.io/qt-5/containers.html#implicit-sharing-iterator-problem\" target=\"_blank\" rel=\"noopener\">implicit sharing</a>，所以使用 iterator 期間 copy container 要注意會不會搞爛 iterator 或 iterator 指向的 container 跟預想不同。</p>\n<p>在某些語言，如 PHP，會提供 foreach 的語法，這進一步將 iterator 變成 syntax 了。</p>\n","tags":["Design Pattern"]},{"title":"Linux Desktop 2 中文環境","url":"/Linux-Desktop-Chinese/","content":"<p>用 Linux 桌面最麻煩的地方之一是中文介面。我已經放棄設語系為中文，畢竟 terminal 各種 message 顯示中文實在很奇怪，但還是需要輸入法跟能看一點的字型啊啊啊啊啊……</p>\n<ul>\n<li>distribution：Debian 8</li>\n<li>桌面環境：KDE</li>\n</ul>\n<h2 id=\"輸入法\"><a href=\"#輸入法\" class=\"headerlink\" title=\"輸入法\"></a>輸入法</h2><p>我先試了 scim，但用起來好像有點 bug，導致操作有點卡。後來換 hime，它的各種切換快捷鍵、符號輸入等等操作跟 windows 的中文輸入法差不多，就用它啦～</p>\n<p>裝完、修改完設定檔 <code>~/.xsessionrc</code> 讓 KDE 去用它，改完 relogin。</p>\n<figure class=\"highlight routeros\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ sudo apt-<span class=\"builtin-name\">get</span> install hime hime-chewing</span><br><span class=\"line\">$ cat ~/.xsessionrc</span><br><span class=\"line\"><span class=\"builtin-name\">export</span> <span class=\"attribute\">GTK_IM_MODULE</span>=hime</span><br><span class=\"line\"><span class=\"builtin-name\">export</span> <span class=\"attribute\">XMODIFIERS</span>=@im=hime</span><br><span class=\"line\"><span class=\"builtin-name\">export</span> <span class=\"attribute\">QT_IM_MODULE</span>=hime</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"中文字型\"><a href=\"#中文字型\" class=\"headerlink\" title=\"中文字型\"></a>中文字型</h2><p>比較喜歡沒襯線、像麥克筆寫的字體。</p>\n<p>目前覺得 Noto 系列跟 WenQuanYi Micro Hei 系列不錯。一般字體就挑順眼的，等寬字體是用 WenQuanYi Micro Hei Mono。WenQuanYi 還有正黑體的版本，但我覺得微米黑（Micro Hei）比較好看。</p>\n<figure class=\"highlight gauss\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ sudo apt-get install <span class=\"built_in\">fonts</span>-noto <span class=\"built_in\">fonts</span>-wqy-microhei <span class=\"built_in\">fonts</span>-wqy-zenhei</span><br></pre></td></tr></table></figure>\n\n<p>Ref：<a href=\"http://wiki.ubuntu.hk/w/%E4%B8%AD%E6%96%87%E5%AD%97%E5%9E%8B\" target=\"_blank\" rel=\"noopener\">http://wiki.ubuntu.hk/w/%E4%B8%AD%E6%96%87%E5%AD%97%E5%9E%8B</a></p>\n","tags":["Linux"]},{"title":"Linux Desktop 1 Install Nvidia driver","url":"/Linux-Desktop-Nvidia-driver/","content":"<p>裝 Linux 桌面系統來用用，為了避免以後可能重灌還要重找一次，記下些安裝過程。</p>\n<p>雖然有 open source 版的顯卡 driver，但我還是覺得裝 Nvidia 的比較好，而且不另外裝 driver 根本調不動螢幕解析度……</p>\n<p>原本想裝 LMDE 2 然後用<a href=\"/solve-servo-blank/\">這篇</a>的方法裝 Nvidia 的 driver，但不知道為什麼就是無法進文字模式。設開機進文字模式或不裝桌面開機會卡在半路開不了，直接關掉桌面系統還是停在無法操作的狀態。</p>\n<p>後來發現 Debian 蠻好裝 Nvidia driver 的，而且 Mint 不只顯卡需要額外 driver 連 audio 都要<del>搞到我有點崩潰</del>，就乾脆換用 Debian 8 Jessie了。</p>\n<h2 id=\"Nvidia-driver-installation-under-Debian-8\"><a href=\"#Nvidia-driver-installation-under-Debian-8\" class=\"headerlink\" title=\"Nvidia driver installation under Debian 8\"></a>Nvidia driver installation under Debian 8</h2><p>雖然 <a href=\"https://wiki.debian.org/NvidiaGraphicsDrivers#Version_367.44_.28via_jessie-backports.29\" target=\"_blank\" rel=\"noopener\">Debian wiki</a> 上都有，還是記錄一下。</p>\n<p>修改 <code>/etc/apt/sources.list</code>，增加：</p>\n<figure class=\"highlight nginx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># jessie-backports</span></span><br><span class=\"line\"><span class=\"attribute\">deb</span> http://httpredir.debian.org/debian jessie-backports main contrib non-free</span><br></pre></td></tr></table></figure>\n\n<p>安裝 linux headers</p>\n<figure class=\"highlight reasonml\"><table><tr><td class=\"code\"><pre><span class=\"line\"># apt-get install linux-headers-<span class=\"constructor\">$(<span class=\"params\">uname</span> -<span class=\"params\">r</span>|<span class=\"params\">sed</span> '<span class=\"params\">s</span>,[^-]<span class=\"operator\">*</span>-[^-]<span class=\"operator\">*</span>-,,')</span></span><br></pre></td></tr></table></figure>\n\n<p>安裝 Nvidia drier</p>\n<figure class=\"highlight vala\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\"># apt-get update</span></span><br><span class=\"line\"><span class=\"meta\"># apt-get install -t jessie-backports nvidia-driver</span></span><br></pre></td></tr></table></figure>\n\n<p>最後重開機，完成！</p>\n","tags":["Linux"]},{"title":"Load process","url":"/Load-process/","content":"<p>要執行一隻程式須將它的 instruction 跟 data load 到 memory。現代 OS 結合 virtual memory 以及 memory management 的 paging 機制來 load process。</p>\n<p>virtual memory 將 process 認知的 memory space 跟 physical memory 分離，藉此達到 process 不一定要在它認定的 physical memory address 上執行。如果實際有的記憶體比較少，virtual memory 也可以在記憶體不足的情況下讓 process 以為它有這麼多 memory 可用。</p>\n<p>每個 process 有自己的 virtual memory space，virtual memory space 的大小由平台的定址 bit 數決定，例如 32 bit 的平台可定址的 address 就從 0 到 2^32 - 1，總大小為 4 GB。process 在 32 bit 系統中的 virtual memory space 大小是 4GB，但不是 4GB 都可以為 process 使用，process 只能用 OS 分配給它的空間，亂用的話會被強制結束。</p>\n<p>paging 簡單來說是將 memory space 分成固定 size 的 page，現在 OS 大多使用 4K size 的 page。virtual memory space 跟 physical memory space 都以 page 切分，MMU（Memory Management Unit）負責 virtual page 與 physical page 的 mapping。virtual page 不存在 physical memory 而該 virtual page 又要被使用時會發生 page fault，此時 OS 負責將 virtual page 從 disk 中讀到 memory 並建立 virtual page 與 physical page 之間的 mapping。</p>\n<p>結合 virtual memory 跟 paging 的 load process 步驟：</p>\n<ol>\n<li>建立這個 process 的 virtual memory space，實際上是建立 virtual page 對應到 physical page 所需的 data structure。</li>\n<li>由 executable file header 的資訊建立 virtual space 與 executable file 的關係，也就是 process 的 virtual memory space 哪一塊對應到 executable file 的哪一塊。</li>\n<li>將 PC register 設到執行入口，process 開始執行。</li>\n<li>process 執行到的程式或需要的 data 沒有 load 進 physical memory，發生 page fault。OS 依照 virtual space 與 executable file 的對應關係知道要從 disk load 哪個 page 到 physical memory，load 進 physical memory 後建立 virtual apge 與該 physical page 的關係，這段即一般講 load 所指的動作。控制權還給 process 繼續跑。</li>\n</ol>\n<p>其中 step 4 會不斷發生。至於 physical memory 被用到需要換掉裡面的 page 才能放新 page 又是另一個故事了……</p>\n<h2 id=\"View\"><a href=\"#View\" class=\"headerlink\" title=\"View\"></a>View</h2><p>對 load 來說，executabl file 裡 section 內容是什麼不重要，重要的是權限。ELF 檔以 load 的角度被分為多個 segment，而一個 segment 裡會有多個屬性類似的 section。以不同角度劃分 executable file 在 ELF 中稱為不同 view，以 section 角度劃分是 linking view，以 segment 角度劃分是 execution view。</p>\n<p>之所以分了 section 又以 segment 再區分 ELF 檔，是因為以上述的 loading 方式，load 必須以 page 為單位。如果依據 section 區分 page 會使用太多 page 而且每個 page 又只用一點點，很浪費 memory。</p>\n<h2 id=\"Program-header-table\"><a href=\"#Program-header-table\" class=\"headerlink\" title=\"Program header table\"></a>Program header table</h2><p>executable file 用 program header table 保存 segment 的資訊，可以用 <code>readelf -l</code> 查看。</p>\n<p>program header table 中每個 segment 都有些欄位分別表示不同意義，其中 file size 跟 memory size 分別表示這個 segment 在 ELF file 中的 size 以及 load 到 memory 後佔用多少 virtual memory。正常來說 file size &lt;= memory size，兩個相等沒什麼好說的，就是 file 內容 load 進 memory。出現 file size &lt; memory size 其中一個可能是 bss section。</p>\n<p>bss section 是放 C 語言裡沒有初始化或初始化為 0 的 global variable，在 ELF 檔中只會記錄「有這個 variable」以及它的 size，不會給予該 variable 所需要的空間，因而能縮小 ELF 檔。到執行時當然要給這些 variable 其所需要的空間好讓它存 value，所以以 segment 角度來看包含 bss section 的 segment 會看到 memory size &gt; file size。另外，C 語言規定 bss section 的初始內容都是 0，不同系統會以不同方式實作。</p>\n<h2 id=\"Example\"><a href=\"#Example\" class=\"headerlink\" title=\"Example\"></a>Example</h2><p>用 <a href=\"/Static-Link\">Static link</a> 裡的例子看 segment。</p>\n<figure class=\"highlight routeros\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ readelf -l foo</span><br><span class=\"line\"></span><br><span class=\"line\">Elf file<span class=\"built_in\"> type </span>is EXEC (Executable file)</span><br><span class=\"line\">Entry point 0x40010d</span><br><span class=\"line\">There are 3 program headers, starting at offset 64</span><br><span class=\"line\"></span><br><span class=\"line\">Program Headers:</span><br><span class=\"line\"> <span class=\"built_in\"> Type </span>          Offset             VirtAddr           PhysAddr</span><br><span class=\"line\">                 FileSiz            MemSiz              Flags  Align</span><br><span class=\"line\">  LOAD           0x0000000000000000 0x0000000000400000 0x0000000000400000</span><br><span class=\"line\">                 0x0000000000000180 0x0000000000000180  R E    200000</span><br><span class=\"line\">  LOAD           0x0000000000000180 0x0000000000600180 0x0000000000600180</span><br><span class=\"line\">                 0x0000000000000018 0x0000000000000018  RW     200000</span><br><span class=\"line\">  GNU_STACK      0x0000000000000000 0x0000000000000000 0x0000000000000000</span><br><span class=\"line\">                 0x0000000000000000 0x0000000000000000  RW     10</span><br><span class=\"line\"></span><br><span class=\"line\"> Section <span class=\"keyword\">to</span> Segment mapping:</span><br><span class=\"line\">  Segment Sections<span class=\"built_in\">..</span>.</span><br><span class=\"line\">   00     .text .eh_frame </span><br><span class=\"line\">   01     .data </span><br><span class=\"line\">   02</span><br></pre></td></tr></table></figure>\n\n<p>type 是 LOAD 才是需要 load 的 segment（這句話怎麼聽起來像廢話）。有兩個 segment，分別是 <code>.text</code> section 所在的可讀可執行 segment 以及 <code>.data</code> section 所在的可讀可寫 segment，他們分別會 load 到 <code>0x400000</code> 跟 <code>0x600180</code>，執行後可以用 <code>cat /proc/&lt;pid&gt;/maps</code> 驗證。這個例子的 file size 跟 memory size 相等，因為裡面沒有 <code>.bss</code> section，加個未 initialize 的 global 變數就可以看到不一樣啦～</p>\n<h2 id=\"Ref\"><a href=\"#Ref\" class=\"headerlink\" title=\"Ref\"></a>Ref</h2><ul>\n<li><a href=\"https://en.wikipedia.org/wiki/Von_Neumann_architecture\" target=\"_blank\" rel=\"noopener\">Von Neumann architecture wiki</a></li>\n<li>《程式設計師的自我修養》ch 6</li>\n<li>《一步步寫嵌入式操作系統》ch 3</li>\n</ul>\n","tags":["System Software","Operating System"]},{"title":"MVC (Model-View-Controller)","url":"/MVC/","content":"<p>大名鼎鼎的 MVC（Model-View-Controller）是一種 compound pattern，要說是個架構也行，這篇主要用 design pattern 的角度去看 MVC。</p>\n<p>compound pattern 是一堆 design pattern 被結合起來使用以解決一般性問題。</p>\n<p>MVC 將 component 分成 model、view 以及 controller：</p>\n<ul>\n<li>model 包含商業邏輯、資料、狀態等等，真正的功能跟做事的 code 會放在 model。</li>\n<li>view 負責呈現各種資料跟畫面。</li>\n<li>controller 接收來自 view 的 input，解讀後要 model 做事。依據使用的 model 不同，controller 對 input 的解讀會不同。</li>\n</ul>\n<h2 id=\"MVC-中的-design-pattern\"><a href=\"#MVC-中的-design-pattern\" class=\"headerlink\" title=\"MVC 中的 design pattern\"></a>MVC 中的 design pattern</h2><p>MVC 中有 <a href=\"/Observer-Pattern\">Observer pattern</a>、<a href=\"/Strategy-Pattern\">Strategy pattern</a> 以及 <a href=\"/Composite-Pattern\">Composite pattern</a>。</p>\n<p>model 利用 observer pattern 通知 controller 及 view 狀態改變。如果 observer 使用 pull 的方式取得資料，model 會開 getter。如果用 push，model 會在 notify 時將 state 傳給 observer。view 一般只從 model 取得資料、不會改變 model。要 model 做事或改變 model 是 controller 的工作。有 controller 可以讓 model 跟 view 不要綁那麼緊。</p>\n<p>view 跟 controller 使用 strategy pattern，controller 是 view 的 strategy。view 負責管理呈現，任何操作與動作都交給 controller 處理。strategy 讓 view 只需要更換 controller 就能有不同動作。</p>\n<p>view 通常用 composite pattern 管理內部的顯示 component，例如 window、panel、widget、button 的階層式結構。</p>\n<p>另外，如果需要轉換某個 model 的 interface 就輪到 <a href=\"/Adapter-Pattern\">Adapter pattern</a> 上場啦。例如 db table 的 primary key 改了，新程式碼希望用新的 primary key 當參數又不想改舊 model，就可以用 adapter 轉換 interface。</p>\n<h2 id=\"Murmur\"><a href=\"#Murmur\" class=\"headerlink\" title=\"Murmur\"></a>Murmur</h2><p>最早遇到 MVC 是在網頁 framework，所以一直理解 model 為「資料」。後來發現 model 好像不只是資料，有文件說 model 包含商業邏輯，但我還是說不上來到底是什麼。現在的理解是絕大多數的程式都是 model，只是把 view 拆出去並且引進 controller 作為類似中介的角色。</p>\n","tags":["Design Pattern"]},{"title":"對 agile 精神的理解","url":"/Murmur-Agile-concept/","content":"<p>大學時因為很任性的理由沒有修軟體工程，所以 agile 是一直到開始工作才聽到。之前是聽過 XP 跟 pair programming，不過沒有很清楚在幹嘛。話說 pair programming 實在要看狀況用，像我這種基本上屬於內向害羞的類型，用 pair programming 大多數狀況下根本直接腦殘化…= =</p>\n<p>之前<del>被拐</del>去上 scrum 的課，說不定是因為講師一直強調 agile 本身精神很重要云云，有個想法一直在腦袋徘徊不去(?)，只好來 murmur 一下看能不能清爽些。阿不過這篇只講對 agile 精神的想法，scrum 方法我不會(欸)。</p>\n<p>我將 agile 精神類比為適應，因為根本上概念是共通的。適應就是因應改變，無論那改變來自外在環境抑或是自身變化。差別只在於生物上各種生物有不同的適應方式，人對於環境以及種種變化所做出的調整也是適應，而 agile 則是將這樣的想法套用於組織性的軟體開發。</p>\n<p>需求改變（外在環境）、內部人員的不同（內在改變）等等都是變化，有了基本精神後當然是以各種工具與方法達成。而現在有許多經過不少人<del>血淚斑斑的</del>試驗過、覺得還不錯的方法可以使用，但是最後依然要找出適合組織與情境的方式。</p>\n<p>我是從個人的角度出發去看「因應變化」這件事。因應變化常常帶著不確定性，所以有時候不太討喜，但是近年我喜歡這種會因應變化的觀念，因為這代表彈性、可能性以及選擇。我喜歡用「成長」的角度去看待改變，改變不見得是成長，但是沒有改變幾乎難以有所成長。有改變代表有新東西，有新東西代表有新選項，有新選項代表有不同未來的可能性。倘若不滿意現況，如果希冀有所不同，又怎麼能夠期望同樣的方式能帶來不同的結果？</p>\n<p>至於結果是更好還是更壞，如果以從個人角度出發來看，我是不太在意。因為覺得不好，再改就是了，這不正是彈性的好處？我傾向相信，終究會慢慢摸索出適合的方式。而那方式，也可能只適用於某一陣子，那只是一個暫時的答案，不是絕對。</p>\n","tags":["Murmur"]},{"title":"筆記這回事","url":"/Murmur-about-note/","content":"<p>很久很久以前，在那個網路只有撥接還常常撥不上去、撥上去也不能用太久的年代，我開始學寫網頁。那時候網路上的資源沒有現在豐富，搜尋引擎還在用蕃薯藤跟奇摩。當時覺得對初心者的教學好重要，所以一直想著如果之後能夠寫些跟技術有關的東西，要寫寫教學文章。後來高中在社團當教學，寫過社課的教學講義，不過沒放上網路，至於主題是什麼就別問了。</p>\n<p>就這樣，我對寫技術相關的文章或 blog，一直想以寫教學的角度撰寫。但是隨著年歲增長，學的東西越多，越發覺自己會的很少，要寫出好教學沒那麼簡單，小時候的豪氣干雲(?)也漸漸弱了下來。唉，還是小時候比較天不怕地不怕。</p>\n<p>開這個 blog 以前，我早就有個放<del>只有自己看得懂的</del>筆記的 wiki，但總覺得只有自己看得懂的東西 po 出來像在丟人現眼，也就一直放著自己看。後來慢慢弄了這個 blog，還是很想寫教學（這到底是什麼制約…），但是越這樣想我寫出來的語法就越奇怪，跟寫論文的狀況有點像（咦？）。就像把書上看不懂在寫什麼鬼的文字，再轉成另一種我自己也還是看不懂的句子，這樣寫筆記的意義到底是……？Orz</p>\n<p>到這幾天覺得其實沒必要那麼嚴肅，反正就是把從各種地方學來的知識技術，消化吸收後再用自己的話寫出來就好了。</p>\n<p>總之就是一個將知識與技術咀嚼消化後再吐出來(?)的過程。</p>\n","tags":["Murmur"]},{"title":"軟體擴充性","url":"/Murmur-software-flexibility/","content":"<p><del>這個人又來胡言亂語了，不是什麼正經筆記</del></p>\n<p>最近寫某個邏輯或定義常常不清楚或者 ambiguous 的東西（因為資料來源是給人看而且也沒整理過），但程式需要清楚的邏輯，感覺在試圖把模糊不清的東西轉成邏輯清晰的程式。似乎，在原本是人工作業而且沒有特別統一或整理過邏輯或步驟的事情上可能就有這種現象。</p>\n<p>工程師很喜歡「找 general 的方法」跟「確認出清楚的邏輯」，畢竟這樣程式比較好寫。但是這東西不只原本的邏輯可能不清楚，還「一定會變動但無法預期會如何變動」，以至於後來我放棄找 general 的方法，而是把問題切得更細再組起來，其實就是 divide and conquer。 甚至稍微放寬對清晰邏輯的要求，改用擴充性比較好的做法。只要變動的時候可以用比較低風險──不會影響到其他部分──的方式因應就好，如此，無論是現在邏輯可能再修正或者之後增加目前沒有的東西都能處理。</p>\n<p>這讓我更能體會為什麼很多設計都希望增加程式擴充性跟降低修改風險，這讓工程師在面對模糊或高度變動的狀況可以好過一點<del>，不然會改到崩潰</del>。</p>\n<p>至於，不能邏輯清楚了再寫嗎？不是不行，但有時候等回應實在太慢，要搞清楚完整邏輯需要花很多時間，而且仍然無法避免「找不到 general 方法」，那就弄個可以微調的辦法之後再慢慢調就好啦！</p>\n<p>另外，最近看了一篇文章讓我覺得相對於機器世界的邏輯分明，人類世界本來就沒有那麼清晰跟確定，而工程師剛好是兩者的翻譯官。</p>\n","tags":["Murmur"]},{"title":"trace code","url":"/Murmur-trace-code/","content":"<p>最近看了些 code，發現不同情況下有不同 trace code 的方式，來 murmur 一下。</p>\n<p>通常拿到一份 code 會先看它主要 component 的結構。如果有 UI 會先大概了解有哪些 component、分別叫什麼、彼此階層關係是什麼，例如哪個 container 裡放著什麼之類的。如果是網頁會先看資料夾結構是一般自己寫的還是用 framework。之後依照要做的事情不同而有不同的 trace 方式。</p>\n<p>第一種，debug 或者找特定功能。</p>\n<p>意識到這種 trace code 方式應該是大學在計中打工的時候，那時候想將 Wordpress 跟一個系統做簡單的整合連結，所以要找 Wordpress 裡相對應的功能。工作後 debug 也常常是用這種方式在看 code。</p>\n<ul>\n<li>如果有 UI 操作，從 UI 操作 trigger 的地方開始一路往下看。</li>\n<li>簡單的東西可能只需要找到特定 function，改一改或加一加功能就好。</li>\n<li>稍微複雜一點就得看懂整條路在幹嘛。</li>\n</ul>\n<p>這方式是單看程式裡某一條路徑、某一段特定邏輯，除非發現是架構上的 bug 才會再往外擴。要是對那份 code 很熟，是也不用從最開始往下找啦……</p>\n<p>第二種，想知道程式整體結構或運作之類的。</p>\n<p>想全面但不深入細節的了解結構跟 high level 的邏輯概念。著重架構及概念，會看大致的流程邏輯，但不會細看每個 function 怎麼實作。這是最近演化(?)出來的方式。</p>\n<ul>\n<li>找最主要的 component 當起點，通常那 project 叫什麼主要 component 就叫什麼，找不到就從 <code>main()</code> 開始。</li>\n<li>看 class name 猜用途<del>猜猜樂</del><ul>\n<li>看名字看不出來的就看 public function 來了解這 class 提供什麼功能</li>\n<li>function name 還是看不出來，找其他地方如何使用或者快速掃一下實作</li>\n<li>有時候會遇到「這個 class 就是這堆功能的集合，我也看不出來這名字跟這堆功能有啥關係」的狀況就是……</li>\n</ul>\n</li>\n<li>需要知道某些流程的時候<ul>\n<li>以類似第一種做法順著流程邏輯看，但只看概略，不細看實作。</li>\n<li>偶爾會看點實作，但比較像用大筆刷過去……第一種方式看實作比較像要刻字那樣精雕細琢…….<del>我到底在寫什麼…Orz…</del></li>\n</ul>\n</li>\n<li>了解各 object 的關係，通常看 member。<ul>\n<li>如果是 pointer 要注意是自己生的還是別人傳進來的。</li>\n</ul>\n</li>\n<li>遇到某些關鍵字，例如 XXXFactory、XXXObserver，直接套用已知概念。<ul>\n<li>只注意誰跟誰有這類的關係，不細看如何實作這些關係。當然也有人家有關鍵字但我不會那概念就沒東西套的狀況……XD</li>\n</ul>\n</li>\n<li>遇見某些常見寫法，直接套用那種寫法的概念。<ul>\n<li>例如 <code>select()</code> 常常就是一個 while loop、塞一塞 <code>fdset</code>、call <code>select()</code>、後面依照 <code>fdset</code> 做事。某些 event loop 做法也有相似性。</li>\n</ul>\n</li>\n</ul>\n<p>我覺得如果遇到關鍵字跟常見做法可以直接套用已知觀念，相對來說就會快很多，因為不需要特別再看實作去理解這部分在做什麼。有時候需要看實作是因為拼湊其他線索後還是不知道那段在幹嘛，只好透過實作細節重新抽象化成概念。</p>\n<p>至於如何找 code？find all 與 <code>grep --color -nr *</code> 萬歲！(欸)</p>\n<p>PS：寫這個是想知道自己怎麼 trace code 的，但怎麼寫一寫好像還是有點像要心領神會的難以言喻……Orz……</p>\n","tags":["Murmur"]},{"title":"設計架構","url":"/OOAD-Architecture/","content":"<blockquote>\n<p>Architecture is your <strong>design structure</strong>, and highlights the <strong>most important</strong> parts of your application, and the <strong>relationships</strong> between those parts.</p>\n</blockquote>\n<blockquote>\n<p>架構是系統的組織結構，包含分解開的各個元件、元件間的關係、互動機制，以及系統設計中使用的原則及決策。</p>\n</blockquote>\n<p>這次英文比中文好懂一點。</p>\n<p>就我的理解，architecture 是整個軟體的結構，有點像骨架。其他那些 requirement、class diagram、design pattern、use case 等等東西就像軟體的，呃，肉(?)，有骨架後就能把這些內容填進去。<del>（寫到這裡開始懷疑我到底是怎麼理解這些概念的…）</del></p>\n<p>設計 architecture 的階段會整理出那些 component 是重要的、建立處理順序，以及減少風險。</p>\n<h2 id=\"如何找出重要的事情？\"><a href=\"#如何找出重要的事情？\" class=\"headerlink\" title=\"如何找出重要的事情？\"></a>如何找出重要的事情？</h2><p>可以問幾個問題：</p>\n<ol>\n<li>它是系統本質的一部份嗎？<br>可以用「如果沒有這個功能，這系統還會是它應該是的東西嗎？」來思考。</li>\n<li>某個功能究竟是什麼意思？<br>理解功能真正的意思，不懂就問客戶，或者任何要你做這玩意的人。盡量避免你以為你知道那是什麼但其實你不知道的狀況（繞口令時間）。</li>\n<li>如何實作某個功能？<br>挑出最困難的部分。不過一項實作困難程度會因人而異。</li>\n</ol>\n<h2 id=\"從誰開始？\"><a href=\"#從誰開始？\" class=\"headerlink\" title=\"從誰開始？\"></a>從誰開始？</h2><p>找到最重要的幾件事情後，要決定從哪個部分開始。</p>\n<p>這裡的重點是「減少風險」。只要能減少風險，從誰開始都可以。所謂風險，諸如 schedule 來不及、做出不是客戶要的東西等等。</p>\n<p>在設計架構的階段要做可以減少風險的事，延後不能減少風險的事情。</p>\n<h3 id=\"如何減少風險？\"><a href=\"#如何減少風險？\" class=\"headerlink\" title=\"如何減少風險？\"></a>如何減少風險？</h3><ul>\n<li>用 scenario 找出大部分的重要 requirement<br>scenario 是穿過 use case 裡的一個路徑，也就是一段系統如何被使用的敘述。</li>\n<li>延後進入細節的時間，因為在架構階段進入細節無法減少風險。<ul>\n<li>不要在架構階段寫詳細的 use case。</li>\n<li>延後細節的 coding<br>可以先有個框，但不要開始寫邏輯細節。</li>\n</ul>\n</li>\n<li>有好的 design<ul>\n<li>一開始就把事情做對</li>\n<li>利用 commonality analysis（共通性分析）設計具有彈性的軟體</li>\n</ul>\n</li>\n<li>搞不清楚意思或軟體要幹嘛時去問客戶，以降低做出不是客戶要的東西的風險。</li>\n</ul>\n<p>寫好軟體的方式是先做好了解需求、規劃、組織、架構以及減少風險，盡可能延後 coding、避免在前期一頭栽進細節。</p>\n","tags":["OOAD"]},{"title":"OOAD 軟體開發週期","url":"/OOAD-software-develop-cycle/","content":"<p>看完《深入淺出物件導向分析與設計》的筆記，這篇概括整理用 OOAD 開發軟體的開發週期，沒有太多細節。</p>\n<h2 id=\"1-搞清楚客戶想要什麼\"><a href=\"#1-搞清楚客戶想要什麼\" class=\"headerlink\" title=\"1. 搞清楚客戶想要什麼\"></a>1. 搞清楚客戶想要什麼</h2><p>跟客戶聊天，<del>從模模糊糊中</del>搞清楚他想要什麼。或者問可以決定要做什麼的人，不管那個人是 PM、PL 還是其他各種頭銜…</p>\n<p>利用 <a href=\"/Commonality-and-Variability\">Commonality 及 Variability</a> 了解客戶想要什麼、軟體要做什麼。</p>\n<p>老實講，我覺得這真是門藝術。</p>\n<h2 id=\"2-建立-feature-list-及-use-case-diagram\"><a href=\"#2-建立-feature-list-及-use-case-diagram\" class=\"headerlink\" title=\"2. 建立 feature list 及 use case diagram\"></a>2. 建立 feature list 及 use case diagram</h2><p>跟客戶聊完天、了解系統要做什麼後建立 feature list，表示整個系統的功能概觀。畫張 use case diagram 呈現使用者或其他系統使用這個系統的藍圖，既然是藍圖，當然不會有太細節的東西啦！feature list 是以功能面的角度看整個系統，use case diagram 則是以「使用」的角度來看整個系統。feature list 裡的功能不管直接或間接，得要能跟 use case diagram 的 use case 互相對應。</p>\n<p>Use case diagram example：</p>\n<img src=\"../images/use_case_diagram.png\" width=\"600\">\n\n<p>到這裡，對整個軟體系統，還只有比較概略性的藍圖，還沒進到 detail，我們要盡可能延後 detail！</p>\n<h3 id=\"Domain-Analysis\"><a href=\"#Domain-Analysis\" class=\"headerlink\" title=\"Domain Analysis\"></a>Domain Analysis</h3><blockquote>\n<p>辨識、收集、組織及表示領域相關資訊的流程，根據既有系統與其開發歷程的研究、領域專家的知識、潛在理論、領域中的新興技術。</p>\n</blockquote>\n<p><del>是段看不懂在寫什麼的文言文…好吧這種時候我承認原文比較好懂…</del></p>\n<p>在我的理解裡，這部分包含 survey 相關技術，例如 framework 如何使用，包括分析、了解原有架構及既有程式碼、找出相關的物件、物件間關係與互動等等，也包含了解此系統相關的背景知識、相關流程等等，例如要做一個請假系統，得要了解請假流程。</p>\n<p>用客戶能理解的語言跟方式描述問題以及系統，不要跟他講什麼 class、variable 就對了。簡單來說──「講人話」。</p>\n<h2 id=\"3-設計架構\"><a href=\"#3-設計架構\" class=\"headerlink\" title=\"3. 設計架構\"></a>3. 設計架構</h2><p>根據 feature list、use case diagram 跟現有程式碼等等資訊將大問題分解成多個各自負責不同功能的 module。組織這些 module 並決定從哪個 module 開始動工。這個階段的重點是建立做事情的順序以及減少風險，<a href=\"/OOAD-Architecture\">更多細節</a>。</p>\n<p>如果有需要，套用 design pattern。design pattern 是解決特定問題的方式，能結構化程式，讓程式較易被理解、維護而且更有彈性。</p>\n<h2 id=\"4-一個個處理小功能\"><a href=\"#4-一個個處理小功能\" class=\"headerlink\" title=\"4. 一個個處理小功能\"></a>4. 一個個處理小功能</h2><p>將大問題分成許多小問題之後，準備各個擊破啦！</p>\n<p>不同的開發方式：<a href=\"/feature-driven-and-use-case-driven-development\">Feature driven &amp; Use case driven development</a>。</p>\n<h3 id=\"4-1-想小功能的-requirement，建立-requirement-list\"><a href=\"#4-1-想小功能的-requirement，建立-requirement-list\" class=\"headerlink\" title=\"4-1. 想小功能的 requirement，建立 requirement list\"></a>4-1. 想小功能的 requirement，建立 requirement list</h3><p>依照描述的需求建立需求清單。類似 feature list 的概念，只是小一點，著重在要處理的小功能有何需求，會比最開始的 feature 更進入細節事項。</p>\n<p>需求不只包含客戶想要的，也包含當事情不按正常狀況來時系統依然要能正常運作。畢竟客戶通常希望當事情不如預期時，系統仍然能正常運作。可以從兩方面著手：</p>\n<ol>\n<li>這個功能要拿來做什麼、該做什麼？</li>\n<li>在出錯的情況中，系統要做些什麼事？</li>\n</ol>\n<h3 id=\"4-2-寫-Use-case\"><a href=\"#4-2-寫-Use-case\" class=\"headerlink\" title=\"4-2. 寫 Use case\"></a>4-2. 寫 Use case</h3><img src=\"../images/requirement_and_usecase.png\" width=\"500\">\n\n<p>requirement 及 use case 要能互相對應，跟 feature 與 use case diagram 一樣。</p>\n<p>因為系統是跑在真實世界，不是只跑在預期狀況中，要考慮出錯的狀況。但是呢，有時候系統遇到出錯狀況時「如何反應才是正常」不見得是工程師能決定的，所以，請<del>騷擾</del>請教可以決定這件事的人。</p>\n<p><a href=\"/use-case\">更多跟 Use case 有關的細節</a></p>\n<h3 id=\"4-3-設計物件細節及物件間的關係\"><a href=\"#4-3-設計物件細節及物件間的關係\" class=\"headerlink\" title=\"4-3. 設計物件細節及物件間的關係\"></a>4-3. 設計物件細節及物件間的關係</h3><ul>\n<li>運用 <a href=\"/use-case\">Textual analysis</a> 分析 use case</li>\n<li><a href=\"/Class-Diagram\">Class Diagram</a></li>\n</ul>\n<h3 id=\"4-4-實作\"><a href=\"#4-4-實作\" class=\"headerlink\" title=\"4-4. 實作\"></a>4-4. 實作</h3><p>運用 OO 原則：</p>\n<ul>\n<li>操作 interface，而非操作 implementation。</li>\n<li>class 跟行為及功能性有關，有行為才加 class。</li>\n<li><a href=\"/encapsulate-change\">封裝會改變的東西</a></li>\n<li><a href=\"/delegate\">Delegate</a></li>\n<li><a href=\"/Open-Closed-Principle\">Open Closed Principle（OCP）</a></li>\n<li><a href=\"/Single-Responsibility-Principle\">Single Responsibility Principle（SRP）</a></li>\n<li><a href=\"/Dont-Repeat-Yourself\">Don’t Repeat Yourself（DRY）</a></li>\n<li><a href=\"/liskov-substitution-principle\">Liskov Substitution Principle（LSP）</a></li>\n</ul>\n<h2 id=\"5-測試\"><a href=\"#5-測試\" class=\"headerlink\" title=\"5. 測試\"></a>5. 測試</h2><p>測試所有能想到的可能使用狀況跟不按規矩來的使用狀況。</p>\n<p>unit test 已經有抽象上的「功能」觀念。unit test 一次只測一個小功能，但測一個小功能不等於測一個 function，也可能是測很多個 function 組合而成的「功能」。</p>\n<p>在測試中要模擬 code 真正被使用的狀況跟情境，而不是測試簡單 call function 但實際上並不會這麼使用的狀況。</p>\n<h2 id=\"Murmur\"><a href=\"#Murmur\" class=\"headerlink\" title=\"Murmur\"></a>Murmur</h2><p>這只是大通則，裡面很多細節是要依照 project 各自狀況不同有所改變的。雖然說是 OOAD 軟體開發週期，但以概念上來說我覺得前面的需求分析等等跟 OO 沒多大關係。</p>\n<p>現在理解到程式設計到處都是 divide and conquer，小時候(?)不懂以為 divide and conquer 只存在 algorithm 裡……</p>\n<p>最開始我很容易犯的毛病是一下子就想動手寫 code，然後搞得很崩潰，幾次之後就不會想這麼幹了。還有會一下子就掉進細節而且還出不來，難以維持以 big picture 的角度去看，就整個攪再一起，這點現在到底治好了沒我也不太確定…(欸)</p>\n<p>雖然目前我只用到裡面的部分方法，但是似乎有個開發週期的框架後變得比較知道自己在幹嘛，腦子比較不會像果醬糊成一團。</p>\n","tags":["OOAD"]},{"title":"Object File Overview","url":"/Object-File-Overview/","content":"<p>object file 是 source code compile 後但尚未 link 的 binary 中間檔，通常跟<a href=\"/Executable-Format\">可執行檔</a>使用相同格式。object file 包含 compile 後的 machine code、data、symbol table、debug 資訊及字串等等。</p>\n<p>object file 以不同 section 儲存不同資訊。</p>\n<p><img src=\"/images/ObjectFileOverview.png\" alt=\"Object File Overview\"></p>\n<ul>\n<li>File Header 描述檔案屬性、section table</li>\n<li><code>.text</code>（<code>.code</code>）section 裡放 code</li>\n<li><code>.data</code> section 放已經 initialize 的 global varible 及 static local variable</li>\n<li><code>.bss</code> section 記錄沒有 initialize 的 variable，先記著「有這個 variable」跟它的 size。但是因為 variable 還沒有 value，所以在 object file 裡不需要浪費空間去記錄 value。</li>\n</ul>\n<h2 id=\"Ref\"><a href=\"#Ref\" class=\"headerlink\" title=\"Ref\"></a>Ref</h2><ul>\n<li><a href=\"http://en.wikipedia.org/wiki/Object_file\" target=\"_blank\" rel=\"noopener\">http://en.wikipedia.org/wiki/Object_file</a></li>\n</ul>\n","tags":["Programming","System Software"]},{"title":"Observer Pattern","url":"/Observer-Pattern/","content":"<blockquote>\n<p>定義物件間一對多的關係，當一個物件改變狀態，其他相依者都會收到通知並自動被更新。</p>\n</blockquote>\n<h2 id=\"適用場合\"><a href=\"#適用場合\" class=\"headerlink\" title=\"適用場合\"></a>適用場合</h2><p>某個物件擁有某些 state，還有一堆其他物件很在乎這些 state 有沒有改變，這些物件在 state 改變時需要做些事情。這邊的 state 是抽象概念，舉凡一個 button 被 click、load data 的 progress、load data 完成與否、畫面是否被修改等等都可以看作 state。另外，一個 object 可能會有很多種 state。</p>\n<p>網路上很喜歡用的說法：observer 是一種訂報紙的概念。簡言之，有間報社（subject or observable），要訂報紙的人（observer）跟報社說他要訂報紙，之後報社有新報紙了（狀態改變）就會通知這些訂戶，訂戶拿到報紙後或許拿來看、或許拿來墊便當(?)，想幹嘛就幹嘛。如果一個訂戶不想收到新報紙了，就跟報社說一聲退出訂閱，之後報社就不會再通知他了。</p>\n<p>再舉另一個例子：UI 操作上滑鼠點了某個東西，程式其他部分需要因應點選做些事情時也適用 observer pattern。</p>\n<h2 id=\"UML\"><a href=\"#UML\" class=\"headerlink\" title=\"UML\"></a>UML</h2><p><img src=\"/images/observer_pattern.jpg\" alt=\"Observer Pattern\"></p>\n<p>Observable 中會有些 state，state 變化時 call NotifyXXX() 通知 observer 們 update。一種做法是 NotifyXXX() call observer 的 update()，而 obsever 會在各自的 update() 中 implement observable 狀態改變時要做的事。</p>\n<h2 id=\"observer-如何取得-observable-的資料？\"><a href=\"#observer-如何取得-observable-的資料？\" class=\"headerlink\" title=\"observer 如何取得 observable 的資料？\"></a>observer 如何取得 observable 的資料？</h2><p>observer 拿 observable 的資料有兩種方式：</p>\n<ul>\n<li>push：由 observable 在通知時一起傳給 observer。</li>\n<li>pull：observer 用 observable 提供的 getter 取得資料。</li>\n</ul>\n<p><em>我是還感覺不出來兩種方式的好壞啦……</em></p>\n<h2 id=\"有的沒的\"><a href=\"#有的沒的\" class=\"headerlink\" title=\"有的沒的\"></a>有的沒的</h2><ul>\n<li>observer 在 update 時不可以依賴被 notify 的順序，因為不同的 observable 實作可能導致結果不同。</li>\n<li>Java 裡有現成的 observer pattern API。</li>\n<li>Java 的 ActionListener 機制是種 observer pattern 的實作──當某件事發生時會 call ActionListener 相應的 function。</li>\n</ul>\n<h2 id=\"Qt-signal-slot-轉成-native-寫法\"><a href=\"#Qt-signal-slot-轉成-native-寫法\" class=\"headerlink\" title=\"Qt signal-slot 轉成 native 寫法\"></a>Qt signal-slot 轉成 native 寫法</h2><p>Qt 的 signal-slot 在用途是特定的狀況下，例如某些 signal-slot 是特別針對某個操作時，可以改成自己實作 observer 並取代之。什麼時候會這麼做？不想用 Qt 做某些 notify 甚至不想用 Qt 的時候…</p>\n<p>我覺得 observer 跟 listener 差不太多，這裡說的 listener 是稍微簡化的 observer，不會有如上述的 observable interface，而是 listenable 的 class 各自自行增加 listener 相關 member 及 function。</p>\n<p>如何將 Qt 的 signal-slot 改成 native 的 listener 寫法、自己處理 notify 呢？</p>\n<ol>\n<li>看懂原本 notify 的流程，區分誰是 listener 誰是 listenable。一般來說 signal 的 sender 是 listenable，signal 的 receiver 是 listener。確認要改哪些 signal、slot、connect()、disconnect()。</li>\n<li>在 listenable class 增加 listener list、add 跟 remove listener function。</li>\n<li>在 listener interface 增加 update function，也就是當某件事發生時會被 call 的 function。</li>\n<li>修改 listenable class 的 emit signal，改為 call listener 的 update function 或 NotifyXXX()，由 NotifyXXX() 再 call listener 的 update function。如果有多處需要通知 listener，建議寫成 NotifyXXX()。如果只有一個地方需要通知，也可以不用 NotifyXXX()。</li>\n<li>listener class 繼承 listener interface 並 implement update function。將原本的 slot 改為一般 function，接著看要由 update function call 還是直接 rename 為 update function。如果原本是 auto 或 queued connection 要注意 thread issue。</li>\n<li>修改 listener class，將 connect() 及 disconnect() 改為 call add 及 remove observer。</li>\n<li>需注意 listener 及 listenable object 的生命週期，如果 listenable 活得比 listener 久，listener 死之前要將自己從 listenable 的 listener list 中移除。</li>\n</ol>\n<p>Qt 的 signal connection 有些特殊功能也要一併處理：</p>\n<ul>\n<li>queued connection 可能隱含換 thread，需釐清原本程式是否意圖使用換 thread 機制。<br>如果有換 thread 就不是單純 observer pattern 可以處理的，可能要改用 thread + event loop，或 listener 的部分可以使用 Qt 則在 listener 以 signal-slot 換 thread。</li>\n<li>direct connection 幾乎等同直接 call function，不需要額外處理。</li>\n<li>unique connection 代換作法之一是在 register observer 時做 filter，已經是 observer 的 object 就不再加入 observer list。</li>\n</ul>\n<h2 id=\"Ref\"><a href=\"#Ref\" class=\"headerlink\" title=\"Ref\"></a>Ref</h2><ul>\n<li>《深入淺出設計模式》ch 2</li>\n<li><a href=\"http://openhome.cc/Gossip/DesignPattern/ObserverPattern.htm\" target=\"_blank\" rel=\"noopener\">http://openhome.cc/Gossip/DesignPattern/ObserverPattern.htm</a></li>\n<li><a href=\"http://kgsprogrammer.pixnet.net/blog/post/27955277-design-pattern----observer\" target=\"_blank\" rel=\"noopener\">http://kgsprogrammer.pixnet.net/blog/post/27955277-design-pattern----observer</a></li>\n</ul>\n","tags":["Design Pattern","Qt"]},{"title":"Open Closed Principle (OCP)","url":"/Open-Closed-Principle/","content":"<p>Software entities such as class, modules, functions should be <strong>open for extension, but closed for modification</strong>.</p>\n<p>直接英翻中就是「對擴展開放，對修改關閉。」</p>\n<p>換句話說，允許擴展但不允許修改原有的 code。在現有程式運作得好好、通過測試的狀況下，應該以擴展的方式新增系統功能，而非修改原有的 code。OCP 著重於軟體彈性，遵守這原則能在增加新功能時確保原本行為不會被更動，減少在原本運作良好的部分產生 bug 的風險。不過遵循 OCP 可能會引入新的抽象層、增加 code 的複雜度，所以並不是整個系統所有地方都該遵守，而是找出最有可能改變的地方才使用 OCP，沒必要的地方使用也是種浪費。</p>\n<p>OCP 是設計層次上的原則。</p>\n<p>舉個例子：較 high level 的 class 應該以 interface 使用較 low level 的 class，而非直接使用 low level 的 class。如此需要支援其他種 low level 實作時，便能直接實作 interface 並修改產生 instance 的地方，即可做到「不修改原本 high level 的 code，而能擴充 low level 實作」。</p>\n<p>另外像瀏覽器的 plugin、Linux kernel 的 module（即使 C 語言不是所謂的物件導向語言，依然能以物件導向的概念撰寫）同樣都運用了 OCP。</p>\n<h2 id=\"Related-Posts\"><a href=\"#Related-Posts\" class=\"headerlink\" title=\"Related Posts\"></a>Related Posts</h2><ul>\n<li><a href=\"/encapsulate-change\">封裝會改變的東西</a></li>\n<li><a href=\"/liskov-substitution-principle\">Liskov Substitution Principle（LSP）</a></li>\n</ul>\n","tags":["OOAD"]},{"title":"Open Street Map API","url":"/Open-Street-Map-API/","content":"<p>記錄開放街圖 Open Street Map（OSM） API 的基本使用跟文件。</p>\n<h2 id=\"Editing-API\"><a href=\"#Editing-API\" class=\"headerlink\" title=\"Editing API\"></a>Editing API</h2><p>RESTful API，data 格式為 XML，目前版本為 v0.6。</p>\n<p>文件：</p>\n<ul>\n<li><a href=\"http://wiki.openstreetmap.org/wiki/API\" target=\"_blank\" rel=\"noopener\">http://wiki.openstreetmap.org/wiki/API</a></li>\n<li><a href=\"http://wiki.openstreetmap.org/wiki/API_v0.6\" target=\"_blank\" rel=\"noopener\">http://wiki.openstreetmap.org/wiki/API_v0.6</a></li>\n</ul>\n<p>程式化編輯資料要注意的事情：</p>\n<ul>\n<li><a href=\"http://wiki.openstreetmap.org/wiki/API#Terms_of_use\" target=\"_blank\" rel=\"noopener\">http://wiki.openstreetmap.org/wiki/API#Terms_of_use</a></li>\n<li><a href=\"http://wiki.openstreetmap.org/wiki/Automated_Edits_code_of_conduct\" target=\"_blank\" rel=\"noopener\">http://wiki.openstreetmap.org/wiki/Automated_Edits_code_of_conduct</a></li>\n</ul>\n<p>OSM 有提供測試用 API，測試站跟正式網站的帳號是分開的。</p>\n<ul>\n<li>測試站：<a href=\"https://master.apis.dev.openstreetmap.org/\" target=\"_blank\" rel=\"noopener\">https://master.apis.dev.openstreetmap.org/</a></li>\n<li>測試用 API：<a href=\"https://master.apis.dev.openstreetmap.org/\" target=\"_blank\" rel=\"noopener\">https://master.apis.dev.openstreetmap.org/</a></li>\n<li>正式 API：<a href=\"http://api.openstreetmap.org/\" target=\"_blank\" rel=\"noopener\">http://api.openstreetmap.org/</a> </li>\n</ul>\n<p>編輯修改 element 必須 reference 到一個 changeset，可以想成修改 log。changeset 跟 element 一樣有 tag，文件建議包含 <code>comment=*</code> 以及 <code>created_by=*</code> tag，簡述改了什麼以及由誰修改。</p>\n<h3 id=\"API-使用流程\"><a href=\"#API-使用流程\" class=\"headerlink\" title=\"API 使用流程\"></a>API 使用流程</h3><ol>\n<li>生一個 changeset 得到 changeset id</li>\n<li>call API 修改 element，會帶 changeset id</li>\n<li>關閉 changeset</li>\n</ol>\n<p>changeset 如果沒有關掉，<a href=\"http://wiki.openstreetmap.org/wiki/API_v0.6#Changesets_2\" target=\"_blank\" rel=\"noopener\">OSM 有規則會自動關閉它</a>。</p>\n<h3 id=\"Authentication\"><a href=\"#Authentication\" class=\"headerlink\" title=\"Authentication\"></a>Authentication</h3><p>editing API 需要 authentication，可以用 <a href=\"https://en.wikipedia.org/wiki/Basic_access_authentication\" target=\"_blank\" rel=\"noopener\">HTTP basic authentication</a>，即在 http header 加上 <code>Authorization: Basic xxx</code>，其中 <code>xxx</code> 是 <code>user:password</code> 的 base64 字串。nodejs 下可以用 <code>new Buffer(&quot;Hello World&quot;).toString(&#39;base64&#39;);</code> 得到 base64 字串。</p>\n<p>以 <code>curl</code> 送 request：</p>\n<figure class=\"highlight awk\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ curl https:<span class=\"regexp\">//m</span>aster.apis.dev.openstreetmap.org<span class=\"regexp\">/api/</span>capabilities</span><br><span class=\"line\">$ curl -H <span class=\"string\">\"Authorization: Basic xxx\"</span> https:<span class=\"regexp\">//m</span>aster.apis.dev.openstreetmap.org<span class=\"regexp\">/api/</span><span class=\"number\">0.6</span><span class=\"regexp\">/permissions</span></span><br></pre></td></tr></table></figure>\n\n<p>除了 HTTP basic authentication 外也可以使用 <a href=\"http://wiki.openstreetmap.org/wiki/OAuth\" target=\"_blank\" rel=\"noopener\">OAuth</a>，這我沒研究。</p>\n<p>剩下 API 使用參考<a href=\"http://wiki.openstreetmap.org/wiki/API_v0.6#API_calls\" target=\"_blank\" rel=\"noopener\">文件定義</a>囉。</p>\n<h2 id=\"Overpass-API\"><a href=\"#Overpass-API\" class=\"headerlink\" title=\"Overpass API\"></a>Overpass API</h2><p>read only API</p>\n<ul>\n<li><a href=\"http://wiki.openstreetmap.org/wiki/Overpass_API\" target=\"_blank\" rel=\"noopener\">http://wiki.openstreetmap.org/wiki/Overpass_API</a></li>\n<li><a href=\"http://wiki.openstreetmap.org/wiki/Overpass_API/XAPI_Compatibility_Layer\" target=\"_blank\" rel=\"noopener\">http://wiki.openstreetmap.org/wiki/Overpass_API/XAPI_Compatibility_Layer</a></li>\n</ul>\n<p>Overpass API 有幾種 query 語法，大致分成 XML query format 跟 Overpass QL，相關文件：</p>\n<ul>\n<li><a href=\"http://wiki.openstreetmap.org/wiki/Overpass_API/Language_Guide\" target=\"_blank\" rel=\"noopener\">http://wiki.openstreetmap.org/wiki/Overpass_API/Language_Guide</a></li>\n<li><a href=\"http://wiki.openstreetmap.org/wiki/Overpass_API/Overpass_QL\" target=\"_blank\" rel=\"noopener\">http://wiki.openstreetmap.org/wiki/Overpass_API/Overpass_QL</a></li>\n</ul>\n<p>我只用 XAPI Compatibility Layer 做簡單的 map 讀取跟 tag query，沒使用上面比較複雜的 query 功能。</p>\n<p>XAPI Compatibility Layer 基本 HTTP GET：</p>\n<figure class=\"highlight markdown\"><table><tr><td class=\"code\"><pre><span class=\"line\">http://www.overpass-api.de/api/xapi?map?bbox=left,bottom,right,top</span><br><span class=\"line\">http://www.overpass-api.de/api/xapi?map?bbox=121.53828,25.045,121.540,25.05</span><br><span class=\"line\">http://www.overpass-api.de/api/xapi?node[<span class=\"string\">bbox=121.53828,25.045,121.55,25.06</span>][<span class=\"symbol\">highway=traffic_signals</span>]</span><br></pre></td></tr></table></figure>\n\n<p>tag 可以串很多，會被 and 起來，其中 node 也可以改成 way 跟 relation。</p>\n","tags":["API","Open Street Map"]},{"title":"OpenAPI PSR-7 Message Validator required field","url":"/OpenAPI-PSR-7-Message-Validator/","content":"<ul>\n<li><a href=\"https://github.com/thephpleague/openapi-psr7-validator\" target=\"_blank\" rel=\"noopener\">https://github.com/thephpleague/openapi-psr7-validator</a></li>\n</ul>\n<p>如果要驗證 response「要有某個欄位」，在 api 定義（yaml 或 json 檔）裡該欄位要設 <code>required</code>：</p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">paths:</span></span><br><span class=\"line\">  <span class=\"string\">/general/test:</span></span><br><span class=\"line\">    <span class=\"attr\">get:</span></span><br><span class=\"line\">      <span class=\"attr\">summary:</span> <span class=\"string\">test</span></span><br><span class=\"line\">      <span class=\"attr\">responses:</span></span><br><span class=\"line\">        <span class=\"attr\">200:</span></span><br><span class=\"line\">          <span class=\"attr\">description:</span> <span class=\"string\">test</span></span><br><span class=\"line\">          <span class=\"attr\">content:</span></span><br><span class=\"line\">            <span class=\"attr\">application/json:</span></span><br><span class=\"line\">              <span class=\"attr\">schema:</span></span><br><span class=\"line\">                <span class=\"attr\">type:</span> <span class=\"string\">object</span></span><br><span class=\"line\">                <span class=\"attr\">properties:</span></span><br><span class=\"line\">                  <span class=\"attr\">id:</span></span><br><span class=\"line\">                    <span class=\"attr\">type:</span> <span class=\"string\">integer</span></span><br><span class=\"line\">                  <span class=\"attr\">username:</span></span><br><span class=\"line\">                    <span class=\"attr\">type:</span> <span class=\"string\">string</span></span><br><span class=\"line\">                <span class=\"attr\">required:</span>    <span class=\"comment\"># 沒有這個的話, response 有或沒有這些欄位都會過</span></span><br><span class=\"line\">                  <span class=\"bullet\">-</span> <span class=\"string\">id</span></span><br><span class=\"line\">                  <span class=\"bullet\">-</span> <span class=\"string\">username</span></span><br></pre></td></tr></table></figure>\n\n<p>用 component 的版本：</p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">paths:</span></span><br><span class=\"line\">  <span class=\"string\">/general/test:</span></span><br><span class=\"line\">    <span class=\"attr\">get:</span></span><br><span class=\"line\">      <span class=\"attr\">summary:</span> <span class=\"string\">test</span></span><br><span class=\"line\">      <span class=\"attr\">responses:</span></span><br><span class=\"line\">        <span class=\"attr\">200:</span></span><br><span class=\"line\">          <span class=\"attr\">description:</span> <span class=\"string\">test</span></span><br><span class=\"line\">          <span class=\"attr\">content:</span></span><br><span class=\"line\">            <span class=\"attr\">application/json:</span></span><br><span class=\"line\">              <span class=\"attr\">schema:</span></span><br><span class=\"line\">                <span class=\"string\">\\$ref:</span> <span class=\"string\">'#/components/schemas/User'</span></span><br><span class=\"line\"><span class=\"attr\">components:</span></span><br><span class=\"line\">  <span class=\"attr\">schemas:</span></span><br><span class=\"line\">    <span class=\"attr\">User:</span></span><br><span class=\"line\">      <span class=\"attr\">type:</span> <span class=\"string\">object</span></span><br><span class=\"line\">      <span class=\"attr\">properties:</span></span><br><span class=\"line\">        <span class=\"attr\">id:</span></span><br><span class=\"line\">          <span class=\"attr\">type:</span> <span class=\"string\">integer</span></span><br><span class=\"line\">        <span class=\"attr\">username:</span></span><br><span class=\"line\">          <span class=\"attr\">type:</span> <span class=\"string\">string</span></span><br><span class=\"line\">      <span class=\"attr\">required:</span> <span class=\"comment\"># 這裡</span></span><br><span class=\"line\">        <span class=\"bullet\">-</span> <span class=\"string\">id</span></span><br><span class=\"line\">        <span class=\"bullet\">-</span> <span class=\"string\">username</span></span><br></pre></td></tr></table></figure>","tags":["OpenAPI"]},{"title":"Pack gem and publish to RubyGems","url":"/Pack-gem-and-publish-to-RubyGems/","content":"<p>這篇記錄寫完 Ruby 程式後如何包成 gem 並丟到 RubyGems 上分享。</p>\n<p>基本流程：</p>\n<ol>\n<li>source code 放到 <code>lib/</code><br><code>lib/</code> 底下通常有 <code>&lt;gem_name&gt;.rb</code> 及 <code>&lt;gem_name&gt;/</code>。<br><code>&lt;gem_name&gt;.rb</code> 放此 gem 最主要的 class 及 <code>require</code>，其餘 source code 放在 <code>&lt;gem_name&gt;/</code>。</li>\n<li>test 放到 <code>test/</code></li>\n<li>在根目錄新增 <code>&lt;gem_name&gt;.gemspec</code></li>\n<li><code>gem build xxx.gemspec</code> 生出 <code>xxx-x.x.x.gem</code></li>\n<li><code>gem push xxx-x.x.x.gem</code> publish 到 RubyGems</li>\n</ol>\n<p>以下以玩具 <code>booksr</code> 為例。</p>\n<p>檔案結構：</p>\n<figure class=\"highlight crystal\"><table><tr><td class=\"code\"><pre><span class=\"line\">│  booksr.gemspec</span><br><span class=\"line\">│  Gemfile</span><br><span class=\"line\">│</span><br><span class=\"line\">├─<span class=\"class\"><span class=\"keyword\">lib</span>/</span></span><br><span class=\"line\">│  │  booksr.rb</span><br><span class=\"line\">│  │</span><br><span class=\"line\">│  └─booksr/</span><br><span class=\"line\">│          api_handler.rb</span><br><span class=\"line\">│          book.rb</span><br><span class=\"line\">│          parser.rb</span><br><span class=\"line\">│</span><br><span class=\"line\">└─test/</span><br><span class=\"line\">        tc_search_isbn.rb</span><br><span class=\"line\">        tc_search_title.rb</span><br><span class=\"line\">        ts_google_api.rb</span><br></pre></td></tr></table></figure>\n\n<p><code>booksr.rb</code> 的內容：</p>\n<figure class=\"highlight ruby\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">require</span> <span class=\"string\">'json'</span></span><br><span class=\"line\"><span class=\"keyword\">require</span> <span class=\"string\">'rest-client'</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">require</span> <span class=\"string\">'booksr/api_handler'</span></span><br><span class=\"line\"><span class=\"keyword\">require</span> <span class=\"string\">'booksr/parser'</span></span><br><span class=\"line\"><span class=\"keyword\">require</span> <span class=\"string\">'booksr/book'</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Booksr</span></span></span><br><span class=\"line\">    ...</span><br><span class=\"line\"><span class=\"keyword\">end</span></span><br></pre></td></tr></table></figure>\n\n<p><code>booksr.gemspec</code> 內容：</p>\n<figure class=\"highlight ruby\"><table><tr><td class=\"code\"><pre><span class=\"line\">Gem::Specification.new <span class=\"keyword\">do</span> <span class=\"params\">|s|</span></span><br><span class=\"line\">    s.name = <span class=\"string\">'booksr'</span></span><br><span class=\"line\">    s.version = <span class=\"string\">'0.1.0'</span></span><br><span class=\"line\">    s.date = <span class=\"string\">'2015-01-21'</span></span><br><span class=\"line\">    s.summary = <span class=\"string\">'A simple book searcher'</span></span><br><span class=\"line\">    s.description = <span class=\"string\">'Search book with title, author, isbn or keyword by Google Book API.'</span></span><br><span class=\"line\">    s.authors = [<span class=\"string\">'cjwind'</span>]</span><br><span class=\"line\">    s.email = <span class=\"string\">'cwentsai@gmail.com'</span></span><br><span class=\"line\">    s.files = Dir[<span class=\"string\">'lib/*.rb'</span>, <span class=\"string\">'lib/booksr/*.rb'</span>, <span class=\"string\">'Gemfile'</span>, <span class=\"string\">'README.md'</span>, <span class=\"string\">'Rakefile'</span>, <span class=\"string\">'*.gemspec'</span>, <span class=\"string\">'test/*.rb'</span>]    <span class=\"comment\"># 此 gem 包含的 source file</span></span><br><span class=\"line\">    s.homepage = <span class=\"string\">'https://github.com/cjwind/booksr'</span></span><br><span class=\"line\">    s.license = <span class=\"string\">'MIT'</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\"># depend 的 gem</span></span><br><span class=\"line\">    s.add_runtime_dependency <span class=\"string\">'bundler'</span></span><br><span class=\"line\">    s.add_runtime_dependency <span class=\"string\">'rest-client'</span></span><br><span class=\"line\"></span><br><span class=\"line\">    s.add_development_dependency <span class=\"string\">'rake'</span></span><br><span class=\"line\">    s.add_development_dependency <span class=\"string\">'test-unit'</span></span><br><span class=\"line\"><span class=\"keyword\">end</span></span><br></pre></td></tr></table></figure>\n\n<p>runtime dependency 跟 development dependency 的差別是預設上不會安裝 development dependency 的 gem。</p>\n<p>如果有 <code>Gemfile</code>，要改寫成吃 <code>.gemspec</code>：</p>\n<figure class=\"highlight ruby\"><table><tr><td class=\"code\"><pre><span class=\"line\">source <span class=\"string\">'https://rubygems.org'</span></span><br><span class=\"line\">gemspec</span><br></pre></td></tr></table></figure>\n\n<p>它會將 runtime dependency 當作基本的 dependency，development dependency 則會開個 development group。</p>\n<p>生 gem：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ gem build booksr.gemspec`</span><br><span class=\"line\">  Successfully built RubyGem</span><br><span class=\"line\">  Name: booksr</span><br><span class=\"line\">  Version: 0.1.0</span><br><span class=\"line\">  File: booksr-0.1.0.gem</span><br></pre></td></tr></table></figure>\n\n\n<p>要 publish 到 <a href=\"https://rubygems.org\" target=\"_blank\" rel=\"noopener\">RubyGems.org</a> 前要先註冊帳號，publish 時需要輸入 Email 跟密碼驗證。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ gem push booksr-0.1.0.gem</span><br><span class=\"line\">Enter your RubyGems.org credentials.</span><br><span class=\"line\">Don<span class=\"string\">'t have an account yet? Create one at https://rubygems.org/sign_up</span></span><br><span class=\"line\"><span class=\"string\">   Email:</span></span><br></pre></td></tr></table></figure>\n\n\n<h2 id=\"Troubleshooting\"><a href=\"#Troubleshooting\" class=\"headerlink\" title=\"Troubleshooting\"></a>Troubleshooting</h2><p>在 win7 底下 publish 遇到以下錯誤：</p>\n<figure class=\"highlight subunit\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">ERROR:  </span>While executing gem ... (Gem::RemoteFetcher::FetchError)</span><br><span class=\"line\">    SSL_connect returned=1 errno=0 state=SSLv3 read server certificate B: certif</span><br><span class=\"line\">icate verify failed (https://rubygems.org/api/v1/api_key)</span><br></pre></td></tr></table></figure>\n\n<p>Solution：抓 <a href=\"http://curl.haxx.se/ca/cacert.pem\" target=\"_blank\" rel=\"noopener\">cacert.pem</a> 放到 <code>C:\\Users\\&lt;username&gt;</code> 底下，並且增加檔案 <code>.gemrc</code>，內容為：</p>\n<figure class=\"highlight asciidoc\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">:ssl_ca_cert:</span> c:\\users\\xxx\\cacert.pem</span><br></pre></td></tr></table></figure>\n\n\n<h2 id=\"碎念時間\"><a href=\"#碎念時間\" class=\"headerlink\" title=\"碎念時間\"></a>碎念時間</h2><p>我是先寫好 code 才開始調這些檔案結構<del>（真相是寫 code 的時候根本不知道這些結構）</del>，跟 require 啊、bundler 啊、gem 啊不熟到爆炸，中間 unit test 還亂入，混亂了好一陣子。弄完稍微多懂一點，希望這篇沒有漏掉什麼，漏掉就再補囉！</p>\n<h2 id=\"Ref\"><a href=\"#Ref\" class=\"headerlink\" title=\"Ref\"></a>Ref</h2><ul>\n<li><a href=\"http://guides.rubygems.org/make-your-own-gem/\" target=\"_blank\" rel=\"noopener\">http://guides.rubygems.org/make-your-own-gem/</a></li>\n<li><a href=\"http://guides.rubygems.org/specification-reference\" target=\"_blank\" rel=\"noopener\">http://guides.rubygems.org/specification-reference</a></li>\n<li><a href=\"http://guides.rubygems.org/name-your-gem/\" target=\"_blank\" rel=\"noopener\">http://guides.rubygems.org/name-your-gem/</a></li>\n<li><a href=\"http://guides.rubygems.org/publishing/\" target=\"_blank\" rel=\"noopener\">http://guides.rubygems.org/publishing/</a></li>\n<li><a href=\"http://bundler.io/rubygems.html\" target=\"_blank\" rel=\"noopener\">http://bundler.io/rubygems.html</a></li>\n</ul>\n","tags":["Ruby"]},{"title":"PhpStorm + Docker in Win10","url":"/PhpStorm-Docker-in-Win10/","content":"<p>跟主題無關的 murmur：來嘗試一種筆記方式，以「解決某個問題」或「達到某個目標」為主，記錄中間的試驗跟操作等過程。因為是過程記錄，路途中可能歪掉(?)、出現好像有關但最後跟解決方式無關的東西。</p>\n<hr>\n<h2 id=\"目標\"><a href=\"#目標\" class=\"headerlink\" title=\"目標\"></a>目標</h2><p>目標是 Win10 下的 PhpStorm 可以用不同版本 PHP 執行程式。</p>\n<p>一個方式是裝多個版本的 PHP <del>（覺得把環境弄得很亂不蘇胡）</del>，既然 PhpStorm 的 CLI Interpreter 可以用 Docker，乾脆來玩一下 Docker～</p>\n<p>雖然是在 Win10，但除了安裝 Docker 的版本不同，其他 Docker 操作基本在 Linux 應該是可以用的（畢竟這沒有牽涉到更細節的什麼 linux container、windows container 之類的，我也不確定那有沒有關係）。</p>\n<h2 id=\"Win10-Docker-Installation\"><a href=\"#Win10-Docker-Installation\" class=\"headerlink\" title=\"Win10 Docker Installation\"></a>Win10 Docker Installation</h2><p>google it，裝完就忘了，大概是 Hyper-V 要開、Win10 要某個版本之後，然後去裝 Docker for Windows，可以參考<a href=\"http://marcus116.blogspot.com/2019/01/docker-docker-for-windows.html\" target=\"_blank\" rel=\"noopener\">這篇</a>。</p>\n<h2 id=\"Docker-的-Image-amp-Container-極簡概念\"><a href=\"#Docker-的-Image-amp-Container-極簡概念\" class=\"headerlink\" title=\"Docker 的 Image &amp; Container 極簡概念\"></a>Docker 的 Image &amp; Container 極簡概念</h2><ul>\n<li>image：類似 VM image 的東西，而且 image 可以一層層疊起來。</li>\n<li>container：依據 image 開起來的 instance，container 的環境是互相隔離的。</li>\n</ul>\n<a id=\"more\"></a>\n\n<h2 id=\"Docker-Command-Line-Usage\"><a href=\"#Docker-Command-Line-Usage\" class=\"headerlink\" title=\"Docker Command Line Usage\"></a>Docker Command Line Usage</h2><figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 跑起一個 ubuntu container 並且用 foreground 模式進入 bash</span></span><br><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> docker run -it ubuntu bash</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 列出 <span class=\"built_in\">local</span> 有的 image</span></span><br><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> docker images</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 在 Docker Hub 搜尋 image</span></span><br><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> docker search &lt;term&gt;</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"利用-image-tag-執行不同-PHP-版本的-container\"><a href=\"#利用-image-tag-執行不同-PHP-版本的-container\" class=\"headerlink\" title=\"利用 image tag 執行不同 PHP 版本的 container\"></a>利用 image tag 執行不同 PHP 版本的 container</h3><figure class=\"highlight elixir\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"variable\">$ </span>docker run [OPTIONS] IMAGE[<span class=\"symbol\">:TAG|</span><span class=\"variable\">@DIGEST</span>] [COMMAND] [ARG...]</span><br><span class=\"line\"><span class=\"variable\">$ </span>docker run <span class=\"symbol\">php:</span>&lt;version&gt;-cli</span><br></pre></td></tr></table></figure>\n\n<p>不加 <code>:&lt;version&gt;-cli</code> 就能執行最新版。這裡有 <a href=\"https://hub.docker.com/_/php?tab=tags\" target=\"_blank\" rel=\"noopener\">PHP image 支援的 tag</a>。</p>\n<h3 id=\"跑-phpunit-image（需要-login-Docker-Hub）\"><a href=\"#跑-phpunit-image（需要-login-Docker-Hub）\" class=\"headerlink\" title=\"跑 phpunit image（需要 login Docker Hub）\"></a>跑 phpunit image（需要 login Docker Hub）</h3><p><code>$ docker run phpunit/phpunit</code></p>\n<h3 id=\"以-php-container-執行本機的-php-file\"><a href=\"#以-php-container-執行本機的-php-file\" class=\"headerlink\" title=\"以 php container 執行本機的 php file\"></a>以 php container 執行本機的 php file</h3><p><code>$ docker run -it --rm --name my-running-script -v D:\\tmp:/usr/src/myapp -w /usr/src/myapp php php hello.php</code></p>\n<ul>\n<li><code>-t</code> : Allocate a pseudo-tty</li>\n<li><code>-i</code> : Keep STDIN open even if not attached<ul>\n<li><code>-i</code> 跟 <code>-t</code> 可以合寫成 <code>-it</code>，需要 <code>-it</code> 才能跟 interactive process 互動。</li>\n</ul>\n</li>\n<li><code>-rm</code>：預設上 container 的 file system 在 container 結束後仍會保留。<code>-rm</code> 可以在 container 結束後自動 clean up container 以及刪除其 file system。</li>\n<li><code>--name</code> 指定 container 的名字</li>\n<li><code>-w</code> 指定 container 中跑執行檔的 working directory，預設是 root directory (<code>/</code>)</li>\n<li><code>-v</code> 是做 shared volume<ul>\n<li><code>-v, --volume=[host-src:]container-dest[:&lt;options&gt;]: Bind mount a volume.</code></li>\n<li>最簡單的用法是 host 跟 container 的 file system mapping，將 host 的某個路徑 mapping 到 container 的某個路徑。<a href=\"https://docs.docker.com/engine/reference/run/#volume-shared-filesystems\" target=\"_blank\" rel=\"noopener\">更詳細的說明</a>。</li>\n</ul>\n</li>\n</ul>\n<p><code>docker run</code> 可以指定 container 中要執行的指令，也就是上面指令的第二個 <code>php</code>（第一個 <code>php</code> 是 image 名稱），當然也可以不指定、直接執行 image 預設的指令。</p>\n<p>總結一下，這個指令是把 host 的 <code>D:\\tmp</code> mapping 到 container 的 <code>/usr/src/myapp</code>，並將 container working directory 改為 <code>/usr/src/myapp</code>，以 <code>php</code> 執行 <code>hello.php</code>（<code>hello.php</code> 當然是放在 host 的 <code>D:\\tmp\\</code>）。</p>\n<h2 id=\"Docker-Build-Image\"><a href=\"#Docker-Build-Image\" class=\"headerlink\" title=\"Docker Build Image\"></a>Docker Build Image</h2><p>開個資料夾，在裡面建立檔案 <code>Dockerfile</code>，內容如下：</p>\n<figure class=\"highlight dockerfile\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># Use an official PHP runtime as a parent image</span></span><br><span class=\"line\"><span class=\"keyword\">FROM</span> php</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># Set the working directory to /app</span></span><br><span class=\"line\"><span class=\"keyword\">WORKDIR</span><span class=\"bash\"> /app</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># Copy the current directory contents into the container at /app</span></span><br><span class=\"line\"><span class=\"keyword\">COPY</span><span class=\"bash\"> . /app</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># Run app.py when the container launches</span></span><br><span class=\"line\"><span class=\"keyword\">CMD</span><span class=\"bash\"> [<span class=\"string\">\"php\"</span>, <span class=\"string\">\"hello.php\"</span>]</span></span><br></pre></td></tr></table></figure>\n\n<p>新增 <code>hello.php</code>，裡面隨意寫點 PHP code。最後在 command line 切到該資料夾，執行：</p>\n<p><code>$ docker build -t myhelloworld:first .</code></p>\n<p>如此即建立一個名稱為 <code>myhelloworld</code>、tag 為 <code>first</code>（不加 tag 也可以）的 image，可以用 <code>docker image ls</code> 看到。也可以不指定名稱，每個 image 都有 id。</p>\n<h2 id=\"PhpStorm-Docker\"><a href=\"#PhpStorm-Docker\" class=\"headerlink\" title=\"PhpStorm + Docker\"></a>PhpStorm + Docker</h2><p>在 PhpStorm 裡要先設定 Docker Server。</p>\n<ol>\n<li>Docker daemon 開啟 <code>localhost:2375</code></li>\n</ol>\n<img src=\"https://i.imgur.com/Z8L0D9M.png\" class=\"\" width=\"800\">\n\n<ol start=\"2\">\n<li>PhpStorm 設定 Docker server</li>\n</ol>\n<img src=\"https://i.imgur.com/tHnVCLa.png\" class=\"\" width=\"800\">\n\n<h3 id=\"用-Docker-當-CLI-interpreter\"><a href=\"#用-Docker-當-CLI-interpreter\" class=\"headerlink\" title=\"用 Docker 當 CLI interpreter\"></a>用 Docker 當 CLI interpreter</h3><ol>\n<li>進 PHP 設定，點 CLI Interpreter 右邊的 <code>...</code></li>\n</ol>\n<img src=\"https://i.imgur.com/yvtJNK4.png\" class=\"\" width=\"800\">\n\n<ol start=\"2\">\n<li>增加 CLI Interpreter From Docker</li>\n</ol>\n<img src=\"https://i.imgur.com/IlNFxsJ.png\" class=\"\" width=\"800\">\n\n<ol start=\"3\">\n<li>選擇 Docker server 及 Image</li>\n</ol>\n<img src=\"https://i.imgur.com/98YX11z.png\" class=\"\" width=\"800\">\n\n<ol start=\"4\">\n<li>Load 到 PHP 相關資訊啦～</li>\n</ol>\n<img src=\"https://i.imgur.com/TchnKCP.png\" class=\"\" width=\"800\">\n\n<ol start=\"5\">\n<li>選擇剛剛新增的 interpreter</li>\n</ol>\n<img src=\"https://i.imgur.com/zyZOLjx.png\" class=\"\" width=\"800\">\n\n<p>設定完就能用 Docker container 的 php 執行 code 啦～</p>\n<p>需要多個 PHP 版本可以設定多個 interpreter 來切換，不會搞得 host 環境裝一堆不同版本 PHP 難以管理。</p>\n<h3 id=\"Build-amp-Run-Dockerfile\"><a href=\"#Build-amp-Run-Dockerfile\" class=\"headerlink\" title=\"Build &amp; Run Dockerfile\"></a>Build &amp; Run Dockerfile</h3><ol>\n<li>在 project 裡建立 Dockerfile，<a href=\"#Docker-Build-Image\">如上</a></li>\n<li>編輯 Run configuration</li>\n</ol>\n<img src=\"https://i.imgur.com/hxkVPlV.png\" class=\"\" width=\"800\">\n\n<ol start=\"3\">\n<li>增加 Dockerfile configuration</li>\n</ol>\n<img src=\"https://i.imgur.com/fCz0HBw.png\" class=\"\" width=\"800\">\n\n<ol start=\"4\">\n<li>選擇 Dockerfile 檔案</li>\n</ol>\n<img src=\"https://i.imgur.com/S2Hietl.png\" class=\"\" width=\"800\">\n\n<ol start=\"5\">\n<li>執行！</li>\n</ol>\n<img src=\"https://i.imgur.com/FAE2e4r.png\" class=\"\" width=\"800\">\n\n<p>執行一次會產生一個 image，它會先 build 一個 image 再去 run 它。</p>\n<h3 id=\"Build-Docker-image\"><a href=\"#Build-Docker-image\" class=\"headerlink\" title=\"Build Docker image\"></a>Build Docker image</h3><p>也可以直接在 <code>Dockerfile</code> build image：</p>\n<img src=\"https://i.imgur.com/vz9mIV2.png\" class=\"\" width=\"800\">","tags":["Docker","PhpStorm"]},{"title":"Linux 下 PhpStorm 輸入中文","url":"/PhpStorm-input-chinese-in-Linux/","content":"<p>問題：Linux 下的 PhpStorm 無法切換輸入法輸入中文。</p>\n<p>在 PhpStorm 啟動 script <code>bin/phpstorm.sh</code> 的 <code>Run the IDE</code> 前加入：</p>\n<figure class=\"highlight routeros\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"attribute\">XMODIFIERS</span>=<span class=\"string\">\"@im=fcitx\"</span></span><br><span class=\"line\"><span class=\"builtin-name\">export</span> XMODIFIERS</span><br></pre></td></tr></table></figure>\n\n<p>這樣用 shell 啟動 PhpStorm 就能切到中文輸入法（前提當然是已經有裝好了），不過從 launcher 啟動 PhpStorm 還是不行。</p>\n","tags":["Linux","PhpStorm"]},{"title":"Program by constract and Defensive programming","url":"/Program-by-constract-and-Defensive-programming/","content":"<p>program by constract（按契約程式設計）就是寫 code 跟用那份 code 的人說好，這些 function 要做什麼、負責什麼、使用的人要怎麼用，大家照說好的去做。</p>\n<p>defensive programming（防禦性程式設計）則是大家互相不信任，會做許多檢查以確保自己不會當掉、使用的人用錯也不會當。defensive programming 會產生許多用於檢查的 code，讓 code 變得冗長、效率也可能較差，所以一般建議在 input 要進入系統時做檢查，系統內部互相 call 時就不再做檢查。當檢查發現問題、出現不該出現的錯誤時，較建議盡快讓程式 fail 好找出錯誤，而非忽略錯誤、繼續讓系統執行下去。</p>\n<h2 id=\"Ref\"><a href=\"#Ref\" class=\"headerlink\" title=\"Ref\"></a>Ref</h2><ul>\n<li>《深入淺出物件導向分析與設計》ch 9</li>\n<li><a href=\"https://ihower.tw/blog/archives/7259\" target=\"_blank\" rel=\"noopener\">https://ihower.tw/blog/archives/7259</a></li>\n</ul>\n","tags":["Programming"]},{"title":"Proxy Pattern","url":"/Proxy-Pattern/","content":"<p>讓某個物件有個替身，藉以控制外界對物件的接觸。<del>就是個經紀人的概念。(欸)</del></p>\n<p>Proxy pattern 主要目的在於「控制存取」，被代理的物件可以是遠端主機上的物件、建立成本高（例如需要時間下載）的物件、或者需要做存取權限管控的物件。</p>\n<h2 id=\"UML\"><a href=\"#UML\" class=\"headerlink\" title=\"UML\"></a>UML</h2><p><img src=\"/images/proxy_pattern.png\" alt=\"Proxy Pattern\"></p>\n<p>很簡單的 UML，client 透過 interface Subject 使用物件，所以它不用知道使用的是真正有功能的物件 RealSubject 還是只是代理人 Proxy。Proxy 依據型態不同會用不同方式取得 RealSubject、使用 RealSubject 的功能，再將結果丟回給 client。</p>\n<p>除了操作 interface 外，要讓 client 使用 proxy 而非真正的 object，有個方法是用 factory 產生物件、傳回給 client，不然 client 自己 new 了個 XXXProxy，看也知道不是真正的 object 啊 XD。不過，是不是真有必要再加一層 factory 隱藏使用 proxy 的事實倒是依情況而定，簡單的情境下讓 client 自己去生 XXXProxy 也不會怎麼樣，不見得非得用 factory 增加複雜度。</p>\n<h2 id=\"Proxy-與它的變種們\"><a href=\"#Proxy-與它的變種們\" class=\"headerlink\" title=\"Proxy 與它的變種們\"></a>Proxy 與它的變種們</h2><h3 id=\"Remote-Proxy\"><a href=\"#Remote-Proxy\" class=\"headerlink\" title=\"Remote Proxy\"></a>Remote Proxy</h3><p>代理另一台電腦上的物件或 service 等等的代理人。使用 proxy 的 client 基本上不會知道 proxy 多做了網路連線、傳遞資料等等的事情，例如 Java 的 RMI（Remote Method Invocation）（這東西應該有點年代了，就當作是個簡單的例子就好）。</p>\n<h3 id=\"Virtual-Proxy\"><a href=\"#Virtual-Proxy\" class=\"headerlink\" title=\"Virtual Proxy\"></a>Virtual Proxy</h3><p>代理建立成本很高的 object，所謂成本很高可能是需要比較多時間等等，例如 video object 需要從網路抓影片、回應很慢的 API 等等。等待過程中但又不希望卡到 UI 操作，這時候就可以透過 virtual proxy 先回一個 loading 畫面，等到 video 抓好或 API 回來之後，就由真正的 object 做事。</p>\n<h3 id=\"Protection-Proxy\"><a href=\"#Protection-Proxy\" class=\"headerlink\" title=\"Protection Proxy\"></a>Protection Proxy</h3><p>顧名思義，保護真正 object 的 proxy，它會根據權限決定外部可不可以存取真正的 object。</p>\n<h3 id=\"Dynamic-Proxy\"><a href=\"#Dynamic-Proxy\" class=\"headerlink\" title=\"Dynamic Proxy\"></a>Dynamic Proxy</h3><p>Java 把事情搞得更複雜，弄了個 dynamic proxy 出來，在 package <code>java.lang.reflect</code>。</p>\n<p>簡單來說，Java 讓 programmer 連 proxy 都不用寫了，只要寫個 <code>InvocationHandler</code> 讓 proxy object call，runtime 才依據要代理的 object 生出 proxy object。<del>除了讓人更懶之外不太懂為什麼要搞這個出來…</del></p>\n<h3 id=\"其他奇奇怪怪的-Proxy-們\"><a href=\"#其他奇奇怪怪的-Proxy-們\" class=\"headerlink\" title=\"其他奇奇怪怪的 Proxy 們\"></a>其他奇奇怪怪的 Proxy 們</h3><p>放關鍵字，需要用再查。</p>\n<p>Firewall proxy、Caching proxy、Synchronization proxy、Smart Reference proxy、Complexity Hiding proxy、Copy-On-Wrtie proxy。</p>\n<p>網路上常說的 proxy server，就有 cache 跟控制網頁存取的功能。</p>\n<h2 id=\"Proxy-與其他-pattern-的不同\"><a href=\"#Proxy-與其他-pattern-的不同\" class=\"headerlink\" title=\"Proxy 與其他 pattern 的不同\"></a>Proxy 與其他 pattern 的不同</h2><h3 id=\"Decorator\"><a href=\"#Decorator\" class=\"headerlink\" title=\"Decorator\"></a>Decorator</h3><p>proxy 跟 decorator 都是對一個物件包裝，有點像，但是兩者的意圖不同。proxy 的目的是控制存取，decorator 則是增加功能。而且 proxy 通常不會一直包一直包、像洋蔥一樣好多層，decorator 會依據想要的功能一直包。</p>\n<h3 id=\"Adapter\"><a href=\"#Adapter\" class=\"headerlink\" title=\"Adapter\"></a>Adapter</h3><p>proxy 看到一半，我就想，啊這跟 <a href=\"/Adapter-Pattern\">adapter</a> 不是一樣嗎！不都是在使用的 client 跟真正的 objec 之間加一層！！！（施主冷靜）</p>\n<p>還是不一樣啦。adapter 會改變 interface，例如 function 參數不一樣，proxy 會 implement 同樣的 interface。</p>\n","tags":["Design Pattern"]},{"title":"Qt d-pointer & q-pointer","url":"/Qt-d-pointer-and-q-pointer/","content":"<p>每次看 Qt source code 都不知道 <code>d-&gt;</code> 跟 <code>q-&gt;</code> 到底在幹嘛，翻到 <a href=\"https://wiki.qt.io/D-Pointer\" target=\"_blank\" rel=\"noopener\">D-Pointer</a> 這篇解釋就來看一下。<del>但是我原本不是要追究這個的ㄚㄚㄚ……</del></p>\n<h2 id=\"d-pointer-pattern\"><a href=\"#d-pointer-pattern\" class=\"headerlink\" title=\"d-pointer pattern\"></a>d-pointer pattern</h2><p>d-pointer 是個 design pattern，也叫 Opaque pointer 或 Pimpl idiom。它分開給外面看的公開 class interface 跟實作的 class。做法是在公開 class 放個實作 class 的 pointer，公開 class 各 function 只是 call implementation class 的 function。公開 class 中跟實作相關的 member 只有那個 pointer，所以 size 會固定是 pointer 的 size。<del>老覺得在哪看過類似的東西……</del></p>\n<p>Qt 用 d-pointer 主要是為了保持 binary compatibility。</p>\n<h2 id=\"Binary-Compatibility\"><a href=\"#Binary-Compatibility\" class=\"headerlink\" title=\"Binary Compatibility\"></a>Binary Compatibility</h2><p>有 binary compatibility 表示 application 在以舊版 library compile 後，新版 library binary 可以直接取代舊版 library 而不需要重新 compile application。要達到 binary compatibility 就不能改變已經公開出去的 C++ class 的 size 或 memory  layout，即不能增加 member 或者更改 function 跟 member 的順序。如果改了，application 認定的 library class size 或 memory layout 跟新版 library 不同，會把 memory 踩爛掉。</p>\n<p>Qt 使用 d-pointer 達到不修改既有公開 class 還能增加 feature 或修改實作細節。</p>\n<h2 id=\"Qt-的實作\"><a href=\"#Qt-的實作\" class=\"headerlink\" title=\"Qt 的實作\"></a>Qt 的實作</h2><p>基於保持 binary compatibility，Qt 幾乎所有 class 都用 d-pointer 指向真正實作的 class。實作 class 叫 <code>QXXXPrivate</code>，例如 <code>QWidget</code> 就有 <code>QWidgetPrivate</code>，通常定義在 <code>xxx_p.h</code>，例如 <code>qwidget_p.h</code>。<code>QXXX</code> 以及 <code>QXXXPrivate</code> 的實作會寫在 <code>qxxx.cpp</code>。</p>\n<p>為了減少 memory allocation 的次數，<code>QXXXPrivate</code> 的 class 也會有繼承關係。其繼承關係會依循一般 class 的繼承關係，例如 <code>QLabel</code> 繼承 <code>QFrame</code>，<code>QLabelPrivate</code> 就會繼承 <code>QFramePrivate</code>。<code>QXXXPrivate</code> 大多繼承自 <code>QObjectPrivate</code>。</p>\n<p>以下 code 擷取自 Qt 5.7.0。</p>\n<h3 id=\"d-pointer-amp-q-pointer\"><a href=\"#d-pointer-amp-q-pointer\" class=\"headerlink\" title=\"d-pointer &amp; q-pointer\"></a>d-pointer &amp; q-pointer</h3><figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Q_CORE_EXPORT</span> <span class=\"title\">QObject</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">    ...</span><br><span class=\"line\"><span class=\"keyword\">protected</span>:</span><br><span class=\"line\">    QScopedPointer&lt;QObjectData&gt; d_ptr;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Q_CORE_EXPORT</span> <span class=\"title\">QObjectData</span> </span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    QObject *q_ptr;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Q_CORE_EXPORT</span> <span class=\"title\">QObjectPrivate</span> :</span> <span class=\"keyword\">public</span> QObjectData &#123; ... &#125;;</span><br></pre></td></tr></table></figure>\n\n<p>好啦～上面是 d-pointer，<code>QObjectPrivate</code> 繼承 <code>QObjectData</code>，而 <code>QObject</code> 有 <code>d_ptr</code> 指向 <code>QObjectData</code>。</p>\n<p>有時候實作 class 需要使用公開 class，因此實作 class 會存公開 class 的 pointer，稱為 q-pointer。如上，<code>QObjectData</code> 有 <code>QObject</code> 的 pointer <code>q_ptr</code>。</p>\n<p>在 Qt 裡 d-pointer 跟 q-pointer 基本上是繼承自 base class，不過也有例外。</p>\n<h3 id=\"Q-D-amp-Q-Q-macro\"><a href=\"#Q-D-amp-Q-Q-macro\" class=\"headerlink\" title=\"Q_D() &amp; Q_Q () macro\"></a>Q_D() &amp; Q_Q () macro</h3><p><code>qtbase/src/corelib/global/qglobal.h</code> 定義了這些 function 跟 macro：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> T&gt; <span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">inline</span> T *<span class=\"title\">qGetPtrHelper</span><span class=\"params\">(T *ptr)</span> </span>&#123; <span class=\"keyword\">return</span> ptr; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> Q_DECLARE_PRIVATE(Class) \\</span></span><br><span class=\"line\">    <span class=\"keyword\">inline</span> Class##<span class=\"function\">Private* <span class=\"title\">d_func</span><span class=\"params\">()</span> </span>&#123; <span class=\"keyword\">return</span> <span class=\"keyword\">reinterpret_cast</span>&lt;Class##Private *&gt;(qGetPtrHelper(d_ptr)); &#125; \\</span><br><span class=\"line\">    <span class=\"keyword\">inline</span> <span class=\"keyword\">const</span> Class##<span class=\"function\">Private* <span class=\"title\">d_func</span><span class=\"params\">()</span> <span class=\"keyword\">const</span> </span>&#123; <span class=\"keyword\">return</span> <span class=\"keyword\">reinterpret_cast</span>&lt;<span class=\"keyword\">const</span> Class##Private *&gt;(qGetPtrHelper(d_ptr)); &#125; \\</span><br><span class=\"line\">    <span class=\"keyword\">friend</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Class</span>##<span class=\"title\">Private</span>;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> Q_DECLARE_PUBLIC(Class)                                    \\</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">inline</span> Class* <span class=\"title\">q_func</span><span class=\"params\">()</span> </span>&#123; <span class=\"keyword\">return</span> <span class=\"keyword\">static_cast</span>&lt;Class *&gt;(q_ptr); &#125; \\</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">const</span> Class* <span class=\"title\">q_func</span><span class=\"params\">()</span> <span class=\"keyword\">const</span> </span>&#123; <span class=\"keyword\">return</span> <span class=\"keyword\">static_cast</span>&lt;<span class=\"keyword\">const</span> Class *&gt;(q_ptr); &#125; \\</span><br><span class=\"line\">    <span class=\"keyword\">friend</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Class</span>;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> Q_D(Class) Class##Private * const d = d_func()</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> Q_Q(Class) Class * const q = q_func()</span></span><br></pre></td></tr></table></figure>\n\n<p>在 class 內會用 <code>Q_DECLARE_PRIVATE()</code>，以 <code>QStandardItem</code> 為例：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Q_GUI_EXPORT</span> <span class=\"title\">QStandardItem</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">    ...</span><br><span class=\"line\"><span class=\"keyword\">protected</span>:</span><br><span class=\"line\">    QScopedPointer&lt;QStandardItemPrivate&gt; d_ptr;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    Q_DECLARE_PRIVATE(QStandardItem)</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">QStandardItem::QStandardItem() : d_ptr(<span class=\"keyword\">new</span> QStandardItemPrivate)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    Q_D(QStandardItem);</span><br><span class=\"line\">    d-&gt;q_ptr = <span class=\"keyword\">this</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">QStandardItem::setChild</span><span class=\"params\">(<span class=\"keyword\">int</span> row, <span class=\"keyword\">int</span> column, QStandardItem *item)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    Q_D(QStandardItem);</span><br><span class=\"line\">    d-&gt;setChild(row, column, item, <span class=\"literal\">true</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><code>QStandardItem</code> 裡有兩個 inline 的 private function 分別為 <code>QStandardItemPrivate* d_func()</code> 以及 <code>const QStandardItemPrivate* d_fun() const</code>，並且 <code>QStandardItemPrivate</code> 是 <code>QStandardItem</code> 的 friend class，可以 access <code>QStandardItem</code> 的 private member。constructor 生了 <code>QStandardItemPrivate</code> 並將 <code>d_ptr</code> 指過去。</p>\n<p>依據 macro 的定義，<code>d</code> 是 <code>QStandardItemPrivate*</code>，<code>d_func()</code> 將 <code>qGetPtrHelper(d_ptr)</code> 轉型成 <code>QStandardItemPrivate*</code> 丟出來。<code>d_ptr</code> 是個 <code>QScopedPointer&lt;QStandardItemPrivate&gt;</code>，<code>qGetPtrHelper()</code> 將 smart pointer 轉成單純的 pointer（參考<a href=\"http://stackoverflow.com/questions/8015718/what-is-the-use-of-qgetptrhelper-in-this-example\" target=\"_blank\" rel=\"noopener\">這篇</a>）。<del>還沒有看得很懂怎麼轉的，不過先這樣理解吧…</del> 總之 <code>d</code> 是指向 construct 時塞進來的 <code>QStandardItemPrivate</code> 的 pointer。所以最後 <code>QStandardItem::setChild()</code> 是用 <code>QStandardItemPrivate::setChild()</code> 實際做事。</p>\n<p>反過來的 <code>Q_Q()</code> 比較簡單。<del>這 macro 的名字真好笑(離題</del></p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">QStandardItemPrivate</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">    Q_DECLARE_PUBLIC(QStandardItem)</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    QStandardItem *q_ptr;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">QStandardItemPrivate::setChild</span><span class=\"params\">(<span class=\"keyword\">int</span> row, <span class=\"keyword\">int</span> column, QStandardItem *item,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                                    <span class=\"keyword\">bool</span> emitChanged)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    Q_Q(QStandardItem);</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (rows &lt;= row)</span><br><span class=\"line\">        q-&gt;setRowCount(row + <span class=\"number\">1</span>);</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>透過 <code>q_func()</code> 拿到的 <code>q</code> 是轉型成 <code>QStandardItem*</code> 的 pointer。</p>\n<p>這個例子裡，因為 <code>QStandardItem</code> 跟 <code>QStandardItemPrivate</code> 沒有繼承別人，它們自己分別記錄了 <code>d_ptr</code> 跟 <code>q_ptr</code>，所以 <code>d_func()</code> 跟 <code>q_func()</code> 有沒有轉型根本沒差。但其他繼承 <code>QObjectPrivate</code> 的 class，<code>q_ptr</code> 是從 <code>QObjectData</code> 來的，type 是 <code>QObject*</code>，如果要直接使用 sub class 的 member 就得轉型，<code>d_ptr</code> 同理。除非用 virtual function 做多型，不過這個狀況用 virtual function 很怪，因為這樣 base class <code>QObject</code> 得有所有 sub class 會用到的 interface，這邊顯然不是這個意思，用 virtual function 不合理。</p>\n<p>這樣看過之後，對 Qt source code 的結構比較理解了，才不會每次看到 <code>Q_D()</code> 啊 <code>Q_Q()</code> 啊都想 Q_Q 了。</p>\n","tags":["C++","Design Pattern","Qt"]},{"title":"工程師碎碎念 1","url":"/RD-murmur-1/","content":"<p>想不到標題只好亂寫。跟<a href=\"/Murmur-software-flexibility\">這篇</a>有點相關，但講點別的。</p>\n<p>因為某些邏輯有點複雜，修改程式很容易會改壞東西，而且改的那個人也不見得會測到所有該測的條件。</p>\n<p>這種問題的解法之一是 unit test，用充分的測試保護那個 module，就能確保之後的修改比較不會改壞原本好的東西。但是那個 project 還沒裝 unit test framework，我也不熟，而且有點時間壓力，我認為先做出一個堪用的版本比架起 unit test framework 重要。</p>\n<p>不過我也真的覺得要是之後改了一點 code，就可能會<del>山崩</del>，阿不是，是壞一堆沒想到的地方啊啊啊。光想到可能會 bug 相連到天邊、牽一髮動全身就覺得可怕。</p>\n<p>後來我用比較彈性的做法，讓之後可以用新增 class 或一小段 code 而不修改原本 code 的方式加新的邏輯。咦？好眼熟喔！阿不就<a href=\"/Open-Closed-Principle/\">OCP</a>？真是突然體會了為什麼那些 principle 那麼討厭「修改原有 code」，因為改原本的 code 就有風險、有可能造成意想不掉的 bug。這種事就是工程師最討厭的──我明明沒動那裡為什麼那邊會壞。</p>\n<p>修改意味著可能有 bug，而且蠻高的機率需要修改，來不及架測試安全網，至少以遵守 OCP 的方式避免之後生 bug，也是一個方法。無法降低風險至零，但應該要能降低到能夠掌控。</p>\n<p>設計原則也好，自動測試也好，它們只是方法不同，最終的目標是一樣的──完成一個有品質的軟體、系統。漸漸覺得，好像是看情況使用，而不見得非得如何。當然，有好設計以及自動測試的軟體是更好的。</p>\n","tags":["Murmur"]},{"title":"Reactor pattern","url":"/Reactor-pattern/","content":"<p>看<a href=\"http://www.cs.wustl.edu/~schmidt/PDF/reactor-siemens.pdf\" target=\"_blank\" rel=\"noopener\">這篇 paper</a>。</p>\n<h2 id=\"問題-amp-情境\"><a href=\"#問題-amp-情境\" class=\"headerlink\" title=\"問題 &amp; 情境\"></a>問題 &amp; 情境</h2><p>Reactor pattern 處理一個 application 收到從一個或多個 client 同時（concurrently）送 request 的情況。</p>\n<p>分散式環境的 server 必須處理多個送 request 過來的 client。為了處理 request，server 必須 demultiplex 以及 dispatch request 給對應的 service。設計 demultiplexing 及 dispatching 需考量：</p>\n<ul>\n<li>Availability<br>server 在等待某些 request 時（例如 server 與 client 間需要多步驟溝通，server 正在等 client 的某個步驟），server 依然能處理收到的 request，不能因為處理某個 request 而 block 住，不然會卡到對其他 request 的 response。</li>\n<li>Efficiency<br>server 要最小化 latency、最大化 throughput 以及避免不必要的 CPU 使用。</li>\n<li>Programming simplicity<br>顧名思義，程式寫得愈簡單愈好。</li>\n<li>Adaptability<br>容易新增或改進 service，修改最少現有的 code 就能加新功能或改進功能，例如新增 service 不用修改底層的 dispatching 機制。</li>\n<li>Portability<br>容易 porting 到其他 OS 平台等。</li>\n</ul>\n<a id=\"more\"></a>\n\n<h2 id=\"Solution\"><a href=\"#Solution\" class=\"headerlink\" title=\"Solution\"></a>Solution</h2><p>整合 demultiplexing 以及 dispatching 並且 decouple 通用的 event demultiplexing &amp; dispatching 以及處理 request 的 service 實作邏輯、屬於應用邏輯的部份。讓 dispatch 歸 dispatch，應用邏輯歸應用邏輯，兩邊別混在一起。</p>\n<h3 id=\"Structure\"><a href=\"#Structure\" class=\"headerlink\" title=\"Structure\"></a>Structure</h3><p>看圖說故事比較容易，<a href=\"http://www.cs.wustl.edu/~schmidt/PDF/reactor-siemens.pdf\" target=\"_blank\" rel=\"noopener\">圖片出處</a>。</p>\n<p><img src=\"/images/reactor.png\" alt=\"Reactor\"></p>\n<ul>\n<li>Handle<ul>\n<li>代表由 OS 管理的 resource，例如 network、file 等 resource。</li>\n<li>像 Linux 用 file descriptor 代表 file、socket 等等，Windows 用各種 handle 代表 resource。</li>\n</ul>\n</li>\n<li>Synchronous Event Demultiplexer<ul>\n<li>負責看一堆 handle 有沒有人有 event、可以動作了。</li>\n<li>如果沒人可以動會 block 住，有人可以動時會 return，例如處理 IO event 的 <code>select()</code>。</li>\n</ul>\n</li>\n<li>Initiation Dispatcher<ul>\n<li>提供 register、remove event handler 以及 dispatch event 的介面。</li>\n<li>Synchronous Event Demultiplexer 收到 event 時會通知 Initiation Dispatcher，Initiation Dispatcher dispatch event 給處理的 event handler。</li>\n</ul>\n</li>\n<li>Event Handler<ul>\n<li>定義 event handler 的介面。</li>\n</ul>\n</li>\n<li>Concrete Event Handler<ul>\n<li>繼承 Event Handler，實際實作處理 event 的邏輯。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"流程\"><a href=\"#流程\" class=\"headerlink\" title=\"流程\"></a>流程</h3><ol>\n<li>application 向 Initiation Dispatcher 註冊 Concrete Event Handler，告訴 Initiation Dispatcher 這個 handler 處理哪種 event。</li>\n<li>application call Initiation Dispatcher 的 <code>handle_events()</code> 進入 event loop。Initiation Dispatcher 由 Event Handler 取得 Handle 交給 Synchronous Event Demultiplexer 等待 event。</li>\n<li>event 發生時 Synchronous Event Demultiplexer 通知 Initiation Dispatcher（以 <code>select()</code> 來說是 return）。</li>\n<li>Initiation Dispatcher call 對應 Event Handler 的 function 來處理 event。</li>\n</ol>\n<p><img src=\"/images/reactor2.png\" alt=\"Reactor\"></p>\n<h2 id=\"優缺點\"><a href=\"#優缺點\" class=\"headerlink\" title=\"優缺點\"></a>優缺點</h2><h3 id=\"優點\"><a href=\"#優點\" class=\"headerlink\" title=\"優點\"></a>優點</h3><ul>\n<li>decouple 了 application 功能上的實作邏輯以及與 application 無關的 demultiplexing &amp; dispatching 機制，各自負責各自的事。</li>\n<li>區分多個 service、各 service 負責自己相關的事情，讓 event-driven application 有較好的模組化並且能重複使用模組。</li>\n<li>增加 portability。Initiation Dispatcher 的 interface 不受限於特定 OS，可在不同的 demultiplexing system call 重複使用。</li>\n<li>Initiation Dispatcher 的 event loop 依序 call event handler 減少複雜的 synchronization 機制。</li>\n</ul>\n<h3 id=\"缺點\"><a href=\"#缺點\" class=\"headerlink\" title=\"缺點\"></a>缺點</h3><ul>\n<li>只在有提供 Handle 的 OS 上有效率。</li>\n<li>non-preemptive：single thread application 中 Event Handler 執行時是無法被中斷、改去做其他事的，所以 Event Handler 處理 event 時不能被 block 住，不然整個 process 就卡住了。所以需要較長時間處理 event 的 application 不適合 reactor pattern。</li>\n<li>reactor pattern 會用在 framework 裡，導致 control flow 在 application 的 handler 及 framework 間跳來跳去，對於寫 application  、不熟悉 framework 運作或者根本看不到 framework 的 code 的開發者較難以 debug。</li>\n</ul>\n<h2 id=\"實作細節\"><a href=\"#實作細節\" class=\"headerlink\" title=\"實作細節\"></a>實作細節</h2><p>流程上雖然一開始就向 Dispatcher 註冊完 event handler，但也可能是某種 event handler 處理 event 時才生另外的 event handler 並且註冊，即註冊及移除 event handler 是動態的。例如 Linux 處理 accept socket connection 的 event handler 在 <code>accept()</code> 後才生處理 client request 的 event handler 並向 Dispatcher 註冊，之後由該 event handler 處理 client 的 request。</p>\n","tags":["Design Pattern"]},{"title":"Reentrancy and Thread-safety","url":"/Reentrancy-and-Thread-safety/","content":"<p>常常聽到看到 reentrancy 但老是跟 thread-safety 搞得不是太清楚。</p>\n<h2 id=\"Reentrancy\"><a href=\"#Reentrancy\" class=\"headerlink\" title=\"Reentrancy\"></a>Reentrancy</h2><p>reentrancy 是 function 可以在執行過程中被中斷，在上一次執行還沒完成前可以再次進入這個 function 執行而不會有問題，也就是第二次進入 function 執行結束後，第一次的執行仍能正確完成。中斷可以是 jump 或 call，也可以是系統的 interrupt 或 signal。</p>\n<p>reentrancy 是 single thread 環境下就有的概念。像是被系統 interrupt 中斷時 interrupt handler 是不是能夠再 call 剛剛執行到一半的 function？反過來說，interrupt handler 能 call 的只有 reentrant function。另外，recursive function 一般會是 reentrancy，但如果它使用了 global 變數就不一定。</p>\n<p>reentrancy function 可以是 thread-safe 但不一定是 thread-safe。thread-safe function 可以是 reentrancy 也可以不是（繞口令時間）。function 是 thread-safe 但不是 reentrancy 的例子：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">function <span class=\"title\">foo</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    mutex_lock();</span><br><span class=\"line\">    <span class=\"comment\">//blah...</span></span><br><span class=\"line\">    mutex_unlock();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在 single thread 的環境下，如果 <code>foo()</code> 執行到一半被 interrupt 打斷，interrupt handler 又 call <code>foo()</code> 會永遠等不到 mutex unlock，整個卡在那。</p>\n<p>達成 reentrancy 的基本原則：</p>\n<ul>\n<li>不使用 global（或 static）的變數<br>但如果執行過程確保 global 變數或 state 能在執行前後保持一致，是可以用的。</li>\n<li>不修改自身的 code</li>\n<li>不 call non-reentrant function</li>\n</ul>\n<h2 id=\"Thread-safety\"><a href=\"#Thread-safety\" class=\"headerlink\" title=\"Thread-safety\"></a>Thread-safety</h2><p>thread-safety 是在 multiple thread 的環境下，thread 間的 shared data 可以在任意執行順序下依然保持正確。</p>\n<p>達到 thread-safety 的方式分兩大類，一是避免 race condition，二是 synchronization。</p>\n<ol>\n<li>避免 race condition<ul>\n<li>寫成不使用 global 變數的 reentrancy code<br>這種 reentrancy code 的寫法可以達成 thread-safety，但不是所有 reentrancy code 都是 thread-safety。反之，因為有很多達成 thread-safety 的方式，不是所有 thread-safety 都是 reentrancy。</li>\n<li>使用 thread-local storage（TLS）<br>存在 TLS 裡的 data 是屬於某個 thread 的，不會在 thread 間共享。</li>\n<li>shared data 使用 immutable object<br>data 不會變當然就沒有 race condition 的問題啦！XD</li>\n</ul>\n</li>\n<li>synchronization<ul>\n<li>mutual exclusion 以及其變形們<br>要注意 dead-lock 或 resource starvation 等等問題</li>\n<li>atomic operation<br>確保 operation 不會被打斷的，通常有賴 instruction 層級的支援。高階 mutual exclusion 也是需要靠 atomic operation 實作的。</li>\n</ul>\n</li>\n</ol>\n<h2 id=\"不同的-terminology\"><a href=\"#不同的-terminology\" class=\"headerlink\" title=\"不同的 terminology\"></a>不同的 terminology</h2><p>不同的 library、系統或語言可能自己定義 thread-safe 跟 reentrant。</p>\n<p>例如 <a href=\"http://doc.qt.io/qt-5/threads-reentrancy.html\" target=\"_blank\" rel=\"noopener\">Qt</a> 將 reentrant 以及 thread-safe 都定義在 multiple thread 的環境下。針對 class 來說，Qt 的 thread-safe class 是 multiple thread 可以 call 同一個 class instance 的 member function，而 reentrant class 則是 multiple thread 只要使用不同的 class instance 就能同時 call member function。</p>\n","tags":["Concurrency"]},{"title":"美國的電氣化過程：系統建構者","url":"/STS1-01/","content":"<p>《科技渴望社會》的第一篇。這本書集結了科技與社會有關的文章與演講稿等等的翻譯，是 STS (Science, Technology and Society) 領域的讀本。</p>\n<p>這篇描述三個在美國電氣化過程中十分活耀的人：愛迪生、英瑟爾、密契爾，分別在電氣化不同階段扮演不同角色。愛迪生主要技術但跨越了管理以及財務等等，讓電氣化得以開始推展。英瑟爾有技術知識也是財務專家，但長處在於管理，透過管理將電力事業的規模擴大。而密契爾則是以金融策略使電力事業進一步擴大為區域系統。三位都對多個領域有所涉獵與了解，綜合各種因素以不同所長推展美國的電力發展。</p>\n<p>其中愛迪生的篇幅是我看得最能理解在幹嘛的部分……</p>\n<p>從這篇文章的研究中，可以看到愛迪生的思考脈絡以及因果邏輯。因目的是取代煤氣燈，所以先考量經濟效益，才結合科學上的靈感，繼而搜尋與試驗特定目標，而非如給小朋友看的故事所述──只是不斷地嘗試。姑且不論從眾多文獻中回推因果是否真是當年愛迪生所想，但看到回推出有邏輯的思考脈絡，才能認為這是合理、可行可能的，而非如神話般的不可思議。</p>\n<p>科學歷史應該要呈現這樣的部份，呈現科學發展的交錯跟曲折性，呈現當時人們的思考脈絡，而非講得科學猶如直升飛機筆直上升，各個有所成果的科學家不是天才就是堅忍不拔云云。像是《科學發現幕後的黑色喜劇》跟《電的旅程》就有這種交(ㄨㄞ)錯(ㄑ一)曲(ㄋ一ㄡˇ)折(ㄅㄚ)但比較真實的科學史。</p>\n<p>至於英瑟爾跟密契爾因為又是管理又是金融的，我實在看不太懂到底在寫什麼……Orz</p>\n<p>總之，可以說是三個人都有跨領域的能力，一步步推展電力發展。從一間公司需要技術的不斷改良以突破擴大的障礙，接著公司開始變大、變多而需要管理才能繼續擴大，之後需要用金融方式讓系統進一步擴張到區域等級，每個時期有不同的關鍵知識跟能力。</p>\n<p>要說有 fu 的感想……應該是「只會技術很難完整建立或推展一個事業系統」。</p>\n","tags":["Reading","STS"]},{"title":"科技物有政治性嗎？","url":"/STS1-04/","content":"<p>《科技渴望社會》第四篇。這篇在說「技術物」如何對人及其生活方式產生影響，「技術物」指的是各種各樣具體的技術或系統，例如核能電廠、鐵路、各種通訊方式、公路網、飛機等等，將「技術」這個較為廣義的詞定義得比較狹義但具體。整篇常常提到政治性、權威、權力、社會組織，我理解為在試圖說明技術物對人的生活以及社會產生的影響。</p>\n<blockquote>\n<p>最偉大的權力不在於君臨天下的帝國威望，而在於權力內化成人們的「生活方式」而無法察覺，更因是生活方式而成為價值觀而為其辯護與效命，從而促成了權力的再生產。而權力的社會運作在於使人們無法思考「另類生活方式」的可能性。</p>\n</blockquote>\n<blockquote>\n<p>技術作為一種對內的控制性力量，就在於讓我們覺得「只有」一種生活方式。</p>\n</blockquote>\n<p>導讀以汽車作為一種生活方式、一種「必須」舉例。因為認為汽車是必須，所以道路規劃等等就以汽車為主，人們出門以考量汽車可及性與停車便利為主。汽車作為生活方式的一部分，於是很難想像以其他交通方式生活，例如芬蘭的單車與大眾運輸。即使有所想像，甚至會受限於當前硬體設施而較難實現其他交通方式。</p>\n<p>引入一個技術的原因不見得是表面上的原因，如引入新技術帶動進步，而可能是達到其他政治或操弄的目的……例如本篇文章提到的低架橋設計，高度故意不足以讓公車通過，使得較依靠公車作為交通手段的族群變得較難前往某些區域，達到了某個程度的隔離目的。</p>\n<p>以低架橋這個例子來說，我會認為這是人「刻意」將技術用於較壞的方向。我的想法偏向技術本身是中立的，可以用在好的方向，也可以用到壞的方向，技術本身並不帶有其原生的影響，是好是壞端看人如何使用。</p>\n<p>文章後面提到，有時候技術的影響並不見得是當事人的本意與意圖。當事人可能並無將技術用於好或壞的動機，但技術本身仍然帶來某些影響，或好或壞。例如早期公共設施較沒有無障礙設施，這不見得是誰特意為之，但結果讓身心障礙者較難以前往某些地方，而在某個程度上遭到排除。這觀點稍微改變了我認為技術是中立的想法。</p>\n<p>技術物甚至會影響圍繞其的社會組織結構與運作方式，例如有了自動化生產系統，原本員工做的事是生產、製造某個東西，但有自動化生產系統後，員工變成是去維護這個系統的運作，而可能為了配合機器而在工作上得要更制式、更機械化。講難聽點，人從做重複性的生產作業，變成機器系統的活零件。</p>\n<p>要維持一個龐大的系統順暢運作，組織上就變得需要有階層與管理，需要管理階層去確定每個部分都有人確實的做好維護與運作。但接著要問的是，維持一個系統，是否必然要使用中央集權式的方式予以管理才能有效率並安全的運作？又如，在這個資訊科技講究創新的時代，由上而下、中央集權式的階層管理是否還適用？看到這我有點訝異，雖然有淺淺的想過一項技術會帶來些影響，可是沒有想那麼深。</p>\n<p>而當「進步」成為主流，對於技術大多只考慮實用性時，拒絕技術之引進容易被扣上「反進步」的帽子，或許使技術的影響性反而變得不被考量。</p>\n<p>murmur：這其實是拉哩拉紮的整理跟心得，目前來說無法更有條理了。看這書大概有四五成是每個字都看得懂但整個句子看起來其實不懂那些字詞真正想表達的意義……</p>\n","tags":["Reading","STS"]},{"title":"Single Responsibility Principle (SRP)","url":"/Single-Responsibility-Principle/","content":"<p>class 應該只負責一件事、只有一個改變的理由，class 聚焦於實作該責任。避免一個 class 有多重責任，或者一個責任分散在多個 class 中。SRP 的主要目的是增加 class 的 cohesion（內聚力）。</p>\n<p>OO 中會以 class 為單位，但可以提升到 process level。舉例來說，將多個 process 啟動與結束的控制分散在各個 process 以及 watch dog，就讓「控制 process 的啟動與結束」這個責任分散在多個地方。這會導致較難理解控制流程、不知道某個時間點是誰在控制，修改時也容易出 bug。</p>\n<p>一個 class 可以負責一個「大」責任。運用 SRP 應該會讓系統中的 class 比較少但比較大，因為會將功能性集中在負責該功能的 class。在思考一個 class 應該負責什麼時，用較抽象的方式去想會比較好，想這 class 要做什麼？它的名稱顯示它該負責什麼？某件事究竟關不關它的事？</p>\n<p>我覺得區分 class 的責任蠻困難的，取決於設計者怎麼想、怎麼看待一個 class 以及其想法的合理性。</p>\n<h2 id=\"SRP-分析\"><a href=\"#SRP-分析\" class=\"headerlink\" title=\"SRP 分析\"></a>SRP 分析</h2><p>分析一個 class 是否符合 SRP。把 class 跟 method 名稱套到以下句子，用人類語言看看通不通順。</p>\n<p><code>The [class] [method] itself.</code><br><code>The [class] [method] [arg] itself.</code><br><code>該 [class] [method] 它自己</code><br><code>該 [class] 自己 [method]</code></p>\n<p>想起來順表示該 method 屬於這個 class、符合 SRP，反之則表示這 method 應該移到其他地方。</p>\n<p>分析時要注意參數可能在 construct 已先傳入，不一定是 method 的 argument。</p>\n<h2 id=\"Related-Posts\"><a href=\"#Related-Posts\" class=\"headerlink\" title=\"Related Posts\"></a>Related Posts</h2><ul>\n<li><a href=\"/Open-Closed-Principle\">Open Closed Principle（OCP）</a></li>\n<li><a href=\"/Dont-Repeat-Yourself\">Don’t Repeat Yourself（DRY）</a></li>\n<li><a href=\"/encapsulate-change\">封裝會改變的東西</a></li>\n</ul>\n","tags":["OOAD"]},{"title":"State Pattern","url":"/State-Pattern/","content":"<p>將狀態封裝成獨立的類別，並把動作 delegate 到目前的狀態物件，讓物件行為隨著內在狀態改變而改變。</p>\n<h2 id=\"使用情境\"><a href=\"#使用情境\" class=\"headerlink\" title=\"使用情境\"></a>使用情境</h2><p>系統中有些狀態以及操作，而操作會依據狀態不同而不同，通常這時候能畫出 state machine。</p>\n<p>依據 state machine，我們可能就會寫出這樣的 code：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F; pseudo code</span><br><span class=\"line\">function operation() &#123;</span><br><span class=\"line\">    if (state &#x3D;&#x3D; STATE_A) &#123;</span><br><span class=\"line\">        &#x2F;&#x2F; do sth.</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    else if (state &#x3D;&#x3D; STATE_B) &#123;</span><br><span class=\"line\">        &#x2F;&#x2F; do other thing</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    &#x2F;&#x2F; ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><code>operation()</code> 通常是 state machine 裡的動作。</p>\n<p>不只 <code>operation()</code> 裡有很多 if，還可能有很多像 <code>operation()</code> 的 function。如果其中有 state 需求變動，或者要加入新的 state，改這段 code 頭就痛了……</p>\n<p>State Pattern 是將 state 封裝成一個個 class（封裝會變動的部份）。將在不同 state 要做的操作，分別放到每個 state class 中，並透過將操作 delegate 給 state object 做，來消除原本 code 裡一堆的 if。</p>\n<h2 id=\"來點例子\"><a href=\"#來點例子\" class=\"headerlink\" title=\"來點例子\"></a>來點例子</h2><p>用《深入淺出設計模式》的例子，糖果機與狀態 class 們的 code 擷取如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">State</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">insertQuater</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">ejectQuater</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">turnCrank</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">dispense</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">NoQuarterState</span> <span class=\"keyword\">implements</span> <span class=\"title\">State</span> </span>&#123;</span><br><span class=\"line\">    GumballMachine gumballMachine;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">NoQuarterState</span><span class=\"params\">(GumballMachine machine)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.gumballMachine = machine;  <span class=\"comment\">// 擁有糖果機的參考</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">insertQuater</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// do sth.</span></span><br><span class=\"line\">        <span class=\"comment\">// 改變糖果機的 state</span></span><br><span class=\"line\">        gumballMachine.setState(gumballMachine.getHasQuarterState());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">ejectQuater</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// do sth.</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">turnCrank</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// do sth.</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">dispense</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// do sth.</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>其他的 state class 就不一一列舉啦～依此推類。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">GumballMachine</span> </span>&#123;</span><br><span class=\"line\">    State soldOutState;</span><br><span class=\"line\">    State noQuarterState;</span><br><span class=\"line\">    State hasQuarterState;</span><br><span class=\"line\">    State soldState;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 不需要用表示 state 的 const 來紀錄狀態，直接用 state object 就可以了</span></span><br><span class=\"line\">    State state = soldOutState;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> count = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">GumballMachine</span><span class=\"params\">(<span class=\"keyword\">int</span> numberGumballs)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 先把所有 state object 生出來</span></span><br><span class=\"line\">        soldOutState = <span class=\"keyword\">new</span> SoldOutState(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">        noQuarterState = <span class=\"keyword\">new</span> NoQuarterState(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">        hasQuarterState = <span class=\"keyword\">new</span> HasQuarterState(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">        soldState = <span class=\"keyword\">new</span> SoldState(<span class=\"keyword\">this</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 初始化 member</span></span><br><span class=\"line\">        <span class=\"keyword\">this</span>.count = numberGumballs;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (numberGumballs &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            state = noQuarterState;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">insertQuarter</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 將操作 delegate 給 state object</span></span><br><span class=\"line\">        state.insertQuarter();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">ejectQuarter</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        state.ejectQuarter();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// other operations</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> State <span class=\"title\">getHasQuarterState</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.hasQuarterState;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// other getters for State</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>糖果機將操作 delegate 給 state object 做，state object 會做事並且改變糖果機的狀態。</p>\n<h2 id=\"UML\"><a href=\"#UML\" class=\"headerlink\" title=\"UML\"></a>UML</h2><img src='data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiIHN0YW5kYWxvbmU9Im5vIj8+PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHhtbG5zOnhsaW5rPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rIiBjb250ZW50U2NyaXB0VHlwZT0iYXBwbGljYXRpb24vZWNtYXNjcmlwdCIgY29udGVudFN0eWxlVHlwZT0idGV4dC9jc3MiIGhlaWdodD0iMjM0cHgiIHByZXNlcnZlQXNwZWN0UmF0aW89Im5vbmUiIHN0eWxlPSJ3aWR0aDo0ODBweDtoZWlnaHQ6MjM0cHg7IiB2ZXJzaW9uPSIxLjEiIHZpZXdCb3g9IjAgMCA0ODAgMjM0IiB3aWR0aD0iNDgwcHgiIHpvb21BbmRQYW49Im1hZ25pZnkiPjxkZWZzPjxmaWx0ZXIgaGVpZ2h0PSIzMDAlIiBpZD0iZjFkZzAyNHU1OWEzZXUiIHdpZHRoPSIzMDAlIiB4PSItMSIgeT0iLTEiPjxmZUdhdXNzaWFuQmx1ciByZXN1bHQ9ImJsdXJPdXQiIHN0ZERldmlhdGlvbj0iMi4wIi8+PGZlQ29sb3JNYXRyaXggaW49ImJsdXJPdXQiIHJlc3VsdD0iYmx1ck91dDIiIHR5cGU9Im1hdHJpeCIgdmFsdWVzPSIwIDAgMCAwIDAgMCAwIDAgMCAwIDAgMCAwIDAgMCAwIDAgMCAuNCAwIi8+PGZlT2Zmc2V0IGR4PSI0LjAiIGR5PSI0LjAiIGluPSJibHVyT3V0MiIgcmVzdWx0PSJibHVyT3V0MyIvPjxmZUJsZW5kIGluPSJTb3VyY2VHcmFwaGljIiBpbjI9ImJsdXJPdXQzIiBtb2RlPSJub3JtYWwiLz48L2ZpbHRlcj48L2RlZnM+PGc+PCEtLU1ENT1bNjc1NDM1NDM2NTkxN2FiZjhmMWE1NmFmMWI3ZTM0NGNdCmNsYXNzIENvbnRleHQtLT48cmVjdCBjb2RlTGluZT0iMSIgZmlsbD0iI0ZFRkVDRSIgZmlsdGVyPSJ1cmwoI2YxZGcwMjR1NTlhM2V1KSIgaGVpZ2h0PSI2MC44MDQ3IiBpZD0iQ29udGV4dCIgc3R5bGU9InN0cm9rZTogI0E4MDAzNjsgc3Ryb2tlLXdpZHRoOiAxLjU7IiB3aWR0aD0iNzgiIHg9IjciIHk9IjEzLjUiLz48ZWxsaXBzZSBjeD0iMjIiIGN5PSIyOS41IiBmaWxsPSIjQUREMUIyIiByeD0iMTEiIHJ5PSIxMSIgc3R5bGU9InN0cm9rZTogI0E4MDAzNjsgc3Ryb2tlLXdpZHRoOiAxLjA7Ii8+PHBhdGggZD0iTTI0LjM0MzgsMjUuMTcxOSBDMjMuNDA2MywyNC43MzQ0IDIyLjgxMjUsMjQuNTkzOCAyMS45Mzc1LDI0LjU5MzggQzE5LjMxMjUsMjQuNTkzOCAxNy4zMTI1LDI2LjY3MTkgMTcuMzEyNSwyOS4zOTA2IEwxNy4zMTI1LDMwLjUxNTYgQzE3LjMxMjUsMzMuMDkzOCAxOS40MjE5LDM0Ljk4NDQgMjIuMzEyNSwzNC45ODQ0IEMyMy41MzEzLDM0Ljk4NDQgMjQuNjg3NSwzNC42ODc1IDI1LjQzNzUsMzQuMTQwNiBDMjYuMDE1NiwzMy43MzQ0IDI2LjM0MzgsMzMuMjgxMyAyNi4zNDM4LDMyLjg5MDYgQzI2LjM0MzgsMzIuNDM3NSAyNS45NTMxLDMyLjA0NjkgMjUuNDg0NCwzMi4wNDY5IEMyNS4yNjU2LDMyLjA0NjkgMjUuMDYyNSwzMi4xMjUgMjQuODc1LDMyLjMxMjUgQzI0LjQyMTksMzIuNzk2OSAyNC40MjE5LDMyLjc5NjkgMjQuMjM0NCwzMi44OTA2IEMyMy44MTI1LDMzLjE1NjMgMjMuMTI1LDMzLjI4MTMgMjIuMzU5NCwzMy4yODEzIEMyMC4zMTI1LDMzLjI4MTMgMTkuMDE1NiwzMi4xODc1IDE5LjAxNTYsMzAuNDg0NCBMMTkuMDE1NiwyOS4zOTA2IEMxOS4wMTU2LDI3LjYwOTQgMjAuMjY1NiwyNi4yOTY5IDIyLDI2LjI5NjkgQzIyLjU3ODEsMjYuMjk2OSAyMy4xODc1LDI2LjQ1MzEgMjMuNjU2MywyNi43MDMxIEMyNC4xNDA2LDI2Ljk4NDQgMjQuMzEyNSwyNy4yMDMxIDI0LjQwNjMsMjcuNjA5NCBDMjQuNDY4OCwyOC4wMTU2IDI0LjUsMjguMTQwNiAyNC42NDA2LDI4LjI2NTYgQzI0Ljc4MTMsMjguNDA2MyAyNS4wMTU2LDI4LjUxNTYgMjUuMjM0NCwyOC41MTU2IEMyNS41LDI4LjUxNTYgMjUuNzY1NiwyOC4zNzUgMjUuOTM3NSwyOC4xNTYzIEMyNi4wNDY5LDI4IDI2LjA3ODEsMjcuODEyNSAyNi4wNzgxLDI3LjM5MDYgTDI2LjA3ODEsMjUuOTY4OCBDMjYuMDc4MSwyNS41MzEzIDI2LjA2MjUsMjUuNDA2MyAyNS45Njg4LDI1LjI1IEMyNS44MTI1LDI0Ljk4NDQgMjUuNTMxMywyNC44NDM4IDI1LjIzNDQsMjQuODQzOCBDMjQuOTM3NSwyNC44NDM4IDI0LjczNDQsMjQuOTM3NSAyNC41MTU2LDI1LjI1IEwyNC4zNDM4LDI1LjE3MTkgWiAiLz48dGV4dCBmaWxsPSIjMDAwMDAwIiBmb250LWZhbWlseT0ic2Fucy1zZXJpZiIgZm9udC1zaXplPSIxMiIgbGVuZ3RoQWRqdXN0PSJzcGFjaW5nQW5kR2x5cGhzIiB0ZXh0TGVuZ3RoPSI0NiIgeD0iMzYiIHk9IjMzLjY1NDMiPkNvbnRleHQ8L3RleHQ+PGxpbmUgc3R5bGU9InN0cm9rZTogI0E4MDAzNjsgc3Ryb2tlLXdpZHRoOiAxLjU7IiB4MT0iOCIgeDI9Ijg0IiB5MT0iNDUuNSIgeTI9IjQ1LjUiLz48bGluZSBzdHlsZT0ic3Ryb2tlOiAjQTgwMDM2OyBzdHJva2Utd2lkdGg6IDEuNTsiIHgxPSI4IiB4Mj0iODQiIHkxPSI1My41IiB5Mj0iNTMuNSIvPjxlbGxpcHNlIGN4PSIxOCIgY3k9IjY0LjUiIGZpbGw9IiM4NEJFODQiIHJ4PSIzIiByeT0iMyIgc3R5bGU9InN0cm9rZTogIzAzODA0ODsgc3Ryb2tlLXdpZHRoOiAxLjA7Ii8+PHRleHQgZmlsbD0iIzAwMDAwMCIgZm9udC1mYW1pbHk9InNhbnMtc2VyaWYiIGZvbnQtc2l6ZT0iMTEiIGxlbmd0aEFkanVzdD0ic3BhY2luZ0FuZEdseXBocyIgdGV4dExlbmd0aD0iNTIiIHg9IjI3IiB5PSI2Ny43MTA0Ij5yZXFldXN0KCk8L3RleHQ+PCEtLU1ENT1bNjBkNmI5MjQwOGY5OGFlZDhkZjk0ZDVjNmUwNGFhNjNdCmNsYXNzIFN0YXRlLS0+PHJlY3QgY29kZUxpbmU9IjUiIGZpbGw9IiNGRUZFQ0UiIGZpbHRlcj0idXJsKCNmMWRnMDI0dTU5YTNldSkiIGhlaWdodD0iNzMuNjA5NCIgaWQ9IlN0YXRlIiBzdHlsZT0ic3Ryb2tlOiAjQTgwMDM2OyBzdHJva2Utd2lkdGg6IDEuNTsiIHdpZHRoPSI5NSIgeD0iMjcwLjUiIHk9IjciLz48ZWxsaXBzZSBjeD0iMjk5LjQ1IiBjeT0iMjMiIGZpbGw9IiNCNEE3RTUiIHJ4PSIxMSIgcnk9IjExIiBzdHlsZT0ic3Ryb2tlOiAjQTgwMDM2OyBzdHJva2Utd2lkdGg6IDEuMDsiLz48cGF0aCBkPSJNMzAwLjQwMzEsMTkuNzgxMyBMMzAyLjEyMTksMTkuNzgxMyBDMzAyLjUxMjUsMTkuNzgxMyAzMDIuNywxOS43NSAzMDIuODI1LDE5LjY3MTkgQzMwMy4wOTA2LDE5LjUxNTYgMzAzLjIzMTMsMTkuMjM0NCAzMDMuMjMxMywxOC45Mzc1IEMzMDMuMjMxMywxOC42NzE5IDMwMy4xMjE5LDE4LjQwNjMgMzAyLjg4NzUsMTguMjM0NCBDMzAyLjcxNTYsMTguMTI1IDMwMi41NzUsMTguMDkzOCAzMDIuMTIxOSwxOC4wOTM4IEwyOTYuOTgxMywxOC4wOTM4IEMyOTYuNTQzOCwxOC4wOTM4IDI5Ni40MTg4LDE4LjEwOTQgMjk2LjI2MjUsMTguMjAzMSBDMjk2LjAxMjUsMTguMzU5NCAyOTUuODU2MywxOC42NTYzIDI5NS44NTYzLDE4LjkzNzUgQzI5NS44NTYzLDE5LjIxODggMjk1Ljk5NjksMTkuNDY4OCAyOTYuMjE1NiwxOS42NDA2IEMyOTYuMzcxOSwxOS43NSAyOTYuNTU5NCwxOS43ODEzIDI5Ni45ODEzLDE5Ljc4MTMgTDI5OC43LDE5Ljc4MTMgTDI5OC43LDI2LjI5NjkgTDI5Ni45ODEzLDI2LjI5NjkgQzI5Ni41NDM4LDI2LjI5NjkgMjk2LjQxODgsMjYuMzEyNSAyOTYuMjYyNSwyNi40MjE5IEMyOTYuMDEyNSwyNi41NzgxIDI5NS44NTYzLDI2Ljg1OTQgMjk1Ljg1NjMsMjcuMTU2MyBDMjk1Ljg1NjMsMjcuNDA2MyAyOTUuOTk2OSwyNy42NzE5IDI5Ni4yMTU2LDI3LjgyODEgQzI5Ni4zNzE5LDI3Ljk1MzEgMjk2LjU3NSwyOCAyOTYuOTgxMywyOCBMMzAyLjEyMTksMjggQzMwMi44NzE5LDI4IDMwMy4yMzEzLDI3LjcxODggMzAzLjIzMTMsMjcuMTU2MyBDMzAzLjIzMTMsMjYuODc1IDMwMy4xMjE5LDI2LjYyNSAzMDIuODg3NSwyNi40NTMxIEMzMDIuNzE1NiwyNi4zMjgxIDMwMi41NzUsMjYuMjk2OSAzMDIuMTIxOSwyNi4yOTY5IEwzMDAuNDAzMSwyNi4yOTY5IEwzMDAuNDAzMSwxOS43ODEzIFogIi8+PHRleHQgZmlsbD0iIzAwMDAwMCIgZm9udC1mYW1pbHk9InNhbnMtc2VyaWYiIGZvbnQtc2l6ZT0iMTIiIGZvbnQtc3R5bGU9Iml0YWxpYyIgbGVuZ3RoQWRqdXN0PSJzcGFjaW5nQW5kR2x5cGhzIiB0ZXh0TGVuZ3RoPSIzMiIgeD0iMzE2LjU1IiB5PSIyNy4xNTQzIj5TdGF0ZTwvdGV4dD48bGluZSBzdHlsZT0ic3Ryb2tlOiAjQTgwMDM2OyBzdHJva2Utd2lkdGg6IDEuNTsiIHgxPSIyNzEuNSIgeDI9IjM2NC41IiB5MT0iMzkiIHkyPSIzOSIvPjxsaW5lIHN0eWxlPSJzdHJva2U6ICNBODAwMzY7IHN0cm9rZS13aWR0aDogMS41OyIgeDE9IjI3MS41IiB4Mj0iMzY0LjUiIHkxPSI0NyIgeTI9IjQ3Ii8+PGVsbGlwc2UgY3g9IjI4MS41IiBjeT0iNTgiIGZpbGw9IiM4NEJFODQiIHJ4PSIzIiByeT0iMyIgc3R5bGU9InN0cm9rZTogIzAzODA0ODsgc3Ryb2tlLXdpZHRoOiAxLjA7Ii8+PHRleHQgZmlsbD0iIzAwMDAwMCIgZm9udC1mYW1pbHk9InNhbnMtc2VyaWYiIGZvbnQtc2l6ZT0iMTEiIGxlbmd0aEFkanVzdD0ic3BhY2luZ0FuZEdseXBocyIgdGV4dExlbmd0aD0iNjkiIHg9IjI5MC41IiB5PSI2MS4yMTA0Ij5vcGVyYXRpb24xKCk8L3RleHQ+PGVsbGlwc2UgY3g9IjI4MS41IiBjeT0iNzAuODA0NyIgZmlsbD0iIzg0QkU4NCIgcng9IjMiIHJ5PSIzIiBzdHlsZT0ic3Ryb2tlOiAjMDM4MDQ4OyBzdHJva2Utd2lkdGg6IDEuMDsiLz48dGV4dCBmaWxsPSIjMDAwMDAwIiBmb250LWZhbWlseT0ic2Fucy1zZXJpZiIgZm9udC1zaXplPSIxMSIgbGVuZ3RoQWRqdXN0PSJzcGFjaW5nQW5kR2x5cGhzIiB0ZXh0TGVuZ3RoPSI2OSIgeD0iMjkwLjUiIHk9Ijc0LjAxNTEiPm9wZXJhdGlvbjIoKTwvdGV4dD48IS0tTUQ1PVs4Y2U4NzU0ZWFlNDE2ZTk5Y2VlYjE3MmZmMWI0Nzc3YV0KY2xhc3MgQ29uY3JldGVTdGF0ZUEtLT48cmVjdCBjb2RlTGluZT0iMTAiIGZpbGw9IiNGRUZFQ0UiIGZpbHRlcj0idXJsKCNmMWRnMDI0dTU5YTNldSkiIGhlaWdodD0iNzMuNjA5NCIgaWQ9IkNvbmNyZXRlU3RhdGVBIiBzdHlsZT0ic3Ryb2tlOiAjQTgwMDM2OyBzdHJva2Utd2lkdGg6IDEuNTsiIHdpZHRoPSIxMjYiIHg9IjE3NCIgeT0iMTQyIi8+PGVsbGlwc2UgY3g9IjE4OSIgY3k9IjE1OCIgZmlsbD0iI0FERDFCMiIgcng9IjExIiByeT0iMTEiIHN0eWxlPSJzdHJva2U6ICNBODAwMzY7IHN0cm9rZS13aWR0aDogMS4wOyIvPjxwYXRoIGQ9Ik0xOTEuMzQzOCwxNTMuNjcxOSBDMTkwLjQwNjMsMTUzLjIzNDQgMTg5LjgxMjUsMTUzLjA5MzggMTg4LjkzNzUsMTUzLjA5MzggQzE4Ni4zMTI1LDE1My4wOTM4IDE4NC4zMTI1LDE1NS4xNzE5IDE4NC4zMTI1LDE1Ny44OTA2IEwxODQuMzEyNSwxNTkuMDE1NiBDMTg0LjMxMjUsMTYxLjU5MzggMTg2LjQyMTksMTYzLjQ4NDQgMTg5LjMxMjUsMTYzLjQ4NDQgQzE5MC41MzEzLDE2My40ODQ0IDE5MS42ODc1LDE2My4xODc1IDE5Mi40Mzc1LDE2Mi42NDA2IEMxOTMuMDE1NiwxNjIuMjM0NCAxOTMuMzQzOCwxNjEuNzgxMyAxOTMuMzQzOCwxNjEuMzkwNiBDMTkzLjM0MzgsMTYwLjkzNzUgMTkyLjk1MzEsMTYwLjU0NjkgMTkyLjQ4NDQsMTYwLjU0NjkgQzE5Mi4yNjU2LDE2MC41NDY5IDE5Mi4wNjI1LDE2MC42MjUgMTkxLjg3NSwxNjAuODEyNSBDMTkxLjQyMTksMTYxLjI5NjkgMTkxLjQyMTksMTYxLjI5NjkgMTkxLjIzNDQsMTYxLjM5MDYgQzE5MC44MTI1LDE2MS42NTYzIDE5MC4xMjUsMTYxLjc4MTMgMTg5LjM1OTQsMTYxLjc4MTMgQzE4Ny4zMTI1LDE2MS43ODEzIDE4Ni4wMTU2LDE2MC42ODc1IDE4Ni4wMTU2LDE1OC45ODQ0IEwxODYuMDE1NiwxNTcuODkwNiBDMTg2LjAxNTYsMTU2LjEwOTQgMTg3LjI2NTYsMTU0Ljc5NjkgMTg5LDE1NC43OTY5IEMxODkuNTc4MSwxNTQuNzk2OSAxOTAuMTg3NSwxNTQuOTUzMSAxOTAuNjU2MywxNTUuMjAzMSBDMTkxLjE0MDYsMTU1LjQ4NDQgMTkxLjMxMjUsMTU1LjcwMzEgMTkxLjQwNjMsMTU2LjEwOTQgQzE5MS40Njg4LDE1Ni41MTU2IDE5MS41LDE1Ni42NDA2IDE5MS42NDA2LDE1Ni43NjU2IEMxOTEuNzgxMywxNTYuOTA2MyAxOTIuMDE1NiwxNTcuMDE1NiAxOTIuMjM0NCwxNTcuMDE1NiBDMTkyLjUsMTU3LjAxNTYgMTkyLjc2NTYsMTU2Ljg3NSAxOTIuOTM3NSwxNTYuNjU2MyBDMTkzLjA0NjksMTU2LjUgMTkzLjA3ODEsMTU2LjMxMjUgMTkzLjA3ODEsMTU1Ljg5MDYgTDE5My4wNzgxLDE1NC40Njg4IEMxOTMuMDc4MSwxNTQuMDMxMyAxOTMuMDYyNSwxNTMuOTA2MyAxOTIuOTY4OCwxNTMuNzUgQzE5Mi44MTI1LDE1My40ODQ0IDE5Mi41MzEzLDE1My4zNDM4IDE5Mi4yMzQ0LDE1My4zNDM4IEMxOTEuOTM3NSwxNTMuMzQzOCAxOTEuNzM0NCwxNTMuNDM3NSAxOTEuNTE1NiwxNTMuNzUgTDE5MS4zNDM4LDE1My42NzE5IFogIi8+PHRleHQgZmlsbD0iIzAwMDAwMCIgZm9udC1mYW1pbHk9InNhbnMtc2VyaWYiIGZvbnQtc2l6ZT0iMTIiIGxlbmd0aEFkanVzdD0ic3BhY2luZ0FuZEdseXBocyIgdGV4dExlbmd0aD0iOTQiIHg9IjIwMyIgeT0iMTYyLjE1NDMiPkNvbmNyZXRlU3RhdGVBPC90ZXh0PjxsaW5lIHN0eWxlPSJzdHJva2U6ICNBODAwMzY7IHN0cm9rZS13aWR0aDogMS41OyIgeDE9IjE3NSIgeDI9IjI5OSIgeTE9IjE3NCIgeTI9IjE3NCIvPjxsaW5lIHN0eWxlPSJzdHJva2U6ICNBODAwMzY7IHN0cm9rZS13aWR0aDogMS41OyIgeDE9IjE3NSIgeDI9IjI5OSIgeTE9IjE4MiIgeTI9IjE4MiIvPjxlbGxpcHNlIGN4PSIxODUiIGN5PSIxOTMiIGZpbGw9IiM4NEJFODQiIHJ4PSIzIiByeT0iMyIgc3R5bGU9InN0cm9rZTogIzAzODA0ODsgc3Ryb2tlLXdpZHRoOiAxLjA7Ii8+PHRleHQgZmlsbD0iIzAwMDAwMCIgZm9udC1mYW1pbHk9InNhbnMtc2VyaWYiIGZvbnQtc2l6ZT0iMTEiIGxlbmd0aEFkanVzdD0ic3BhY2luZ0FuZEdseXBocyIgdGV4dExlbmd0aD0iNjkiIHg9IjE5NCIgeT0iMTk2LjIxMDQiPm9wZXJhdGlvbjEoKTwvdGV4dD48ZWxsaXBzZSBjeD0iMTg1IiBjeT0iMjA1LjgwNDciIGZpbGw9IiM4NEJFODQiIHJ4PSIzIiByeT0iMyIgc3R5bGU9InN0cm9rZTogIzAzODA0ODsgc3Ryb2tlLXdpZHRoOiAxLjA7Ii8+PHRleHQgZmlsbD0iIzAwMDAwMCIgZm9udC1mYW1pbHk9InNhbnMtc2VyaWYiIGZvbnQtc2l6ZT0iMTEiIGxlbmd0aEFkanVzdD0ic3BhY2luZ0FuZEdseXBocyIgdGV4dExlbmd0aD0iNjkiIHg9IjE5NCIgeT0iMjA5LjAxNTEiPm9wZXJhdGlvbjIoKTwvdGV4dD48IS0tTUQ1PVsyYTU2ODE4NjY4YjlmZGJiYWJhODU2NWRhMGNjYWM3ZF0KY2xhc3MgQ29uY3JldGVTdGF0ZUItLT48cmVjdCBjb2RlTGluZT0iMTUiIGZpbGw9IiNGRUZFQ0UiIGZpbHRlcj0idXJsKCNmMWRnMDI0dTU5YTNldSkiIGhlaWdodD0iNzMuNjA5NCIgaWQ9IkNvbmNyZXRlU3RhdGVCIiBzdHlsZT0ic3Ryb2tlOiAjQTgwMDM2OyBzdHJva2Utd2lkdGg6IDEuNTsiIHdpZHRoPSIxMjYiIHg9IjMzNSIgeT0iMTQyIi8+PGVsbGlwc2UgY3g9IjM1MCIgY3k9IjE1OCIgZmlsbD0iI0FERDFCMiIgcng9IjExIiByeT0iMTEiIHN0eWxlPSJzdHJva2U6ICNBODAwMzY7IHN0cm9rZS13aWR0aDogMS4wOyIvPjxwYXRoIGQ9Ik0zNTIuMzQzOCwxNTMuNjcxOSBDMzUxLjQwNjMsMTUzLjIzNDQgMzUwLjgxMjUsMTUzLjA5MzggMzQ5LjkzNzUsMTUzLjA5MzggQzM0Ny4zMTI1LDE1My4wOTM4IDM0NS4zMTI1LDE1NS4xNzE5IDM0NS4zMTI1LDE1Ny44OTA2IEwzNDUuMzEyNSwxNTkuMDE1NiBDMzQ1LjMxMjUsMTYxLjU5MzggMzQ3LjQyMTksMTYzLjQ4NDQgMzUwLjMxMjUsMTYzLjQ4NDQgQzM1MS41MzEzLDE2My40ODQ0IDM1Mi42ODc1LDE2My4xODc1IDM1My40Mzc1LDE2Mi42NDA2IEMzNTQuMDE1NiwxNjIuMjM0NCAzNTQuMzQzOCwxNjEuNzgxMyAzNTQuMzQzOCwxNjEuMzkwNiBDMzU0LjM0MzgsMTYwLjkzNzUgMzUzLjk1MzEsMTYwLjU0NjkgMzUzLjQ4NDQsMTYwLjU0NjkgQzM1My4yNjU2LDE2MC41NDY5IDM1My4wNjI1LDE2MC42MjUgMzUyLjg3NSwxNjAuODEyNSBDMzUyLjQyMTksMTYxLjI5NjkgMzUyLjQyMTksMTYxLjI5NjkgMzUyLjIzNDQsMTYxLjM5MDYgQzM1MS44MTI1LDE2MS42NTYzIDM1MS4xMjUsMTYxLjc4MTMgMzUwLjM1OTQsMTYxLjc4MTMgQzM0OC4zMTI1LDE2MS43ODEzIDM0Ny4wMTU2LDE2MC42ODc1IDM0Ny4wMTU2LDE1OC45ODQ0IEwzNDcuMDE1NiwxNTcuODkwNiBDMzQ3LjAxNTYsMTU2LjEwOTQgMzQ4LjI2NTYsMTU0Ljc5NjkgMzUwLDE1NC43OTY5IEMzNTAuNTc4MSwxNTQuNzk2OSAzNTEuMTg3NSwxNTQuOTUzMSAzNTEuNjU2MywxNTUuMjAzMSBDMzUyLjE0MDYsMTU1LjQ4NDQgMzUyLjMxMjUsMTU1LjcwMzEgMzUyLjQwNjMsMTU2LjEwOTQgQzM1Mi40Njg4LDE1Ni41MTU2IDM1Mi41LDE1Ni42NDA2IDM1Mi42NDA2LDE1Ni43NjU2IEMzNTIuNzgxMywxNTYuOTA2MyAzNTMuMDE1NiwxNTcuMDE1NiAzNTMuMjM0NCwxNTcuMDE1NiBDMzUzLjUsMTU3LjAxNTYgMzUzLjc2NTYsMTU2Ljg3NSAzNTMuOTM3NSwxNTYuNjU2MyBDMzU0LjA0NjksMTU2LjUgMzU0LjA3ODEsMTU2LjMxMjUgMzU0LjA3ODEsMTU1Ljg5MDYgTDM1NC4wNzgxLDE1NC40Njg4IEMzNTQuMDc4MSwxNTQuMDMxMyAzNTQuMDYyNSwxNTMuOTA2MyAzNTMuOTY4OCwxNTMuNzUgQzM1My44MTI1LDE1My40ODQ0IDM1My41MzEzLDE1My4zNDM4IDM1My4yMzQ0LDE1My4zNDM4IEMzNTIuOTM3NSwxNTMuMzQzOCAzNTIuNzM0NCwxNTMuNDM3NSAzNTIuNTE1NiwxNTMuNzUgTDM1Mi4zNDM4LDE1My42NzE5IFogIi8+PHRleHQgZmlsbD0iIzAwMDAwMCIgZm9udC1mYW1pbHk9InNhbnMtc2VyaWYiIGZvbnQtc2l6ZT0iMTIiIGxlbmd0aEFkanVzdD0ic3BhY2luZ0FuZEdseXBocyIgdGV4dExlbmd0aD0iOTQiIHg9IjM2NCIgeT0iMTYyLjE1NDMiPkNvbmNyZXRlU3RhdGVCPC90ZXh0PjxsaW5lIHN0eWxlPSJzdHJva2U6ICNBODAwMzY7IHN0cm9rZS13aWR0aDogMS41OyIgeDE9IjMzNiIgeDI9IjQ2MCIgeTE9IjE3NCIgeTI9IjE3NCIvPjxsaW5lIHN0eWxlPSJzdHJva2U6ICNBODAwMzY7IHN0cm9rZS13aWR0aDogMS41OyIgeDE9IjMzNiIgeDI9IjQ2MCIgeTE9IjE4MiIgeTI9IjE4MiIvPjxlbGxpcHNlIGN4PSIzNDYiIGN5PSIxOTMiIGZpbGw9IiM4NEJFODQiIHJ4PSIzIiByeT0iMyIgc3R5bGU9InN0cm9rZTogIzAzODA0ODsgc3Ryb2tlLXdpZHRoOiAxLjA7Ii8+PHRleHQgZmlsbD0iIzAwMDAwMCIgZm9udC1mYW1pbHk9InNhbnMtc2VyaWYiIGZvbnQtc2l6ZT0iMTEiIGxlbmd0aEFkanVzdD0ic3BhY2luZ0FuZEdseXBocyIgdGV4dExlbmd0aD0iNjkiIHg9IjM1NSIgeT0iMTk2LjIxMDQiPm9wZXJhdGlvbjEoKTwvdGV4dD48ZWxsaXBzZSBjeD0iMzQ2IiBjeT0iMjA1LjgwNDciIGZpbGw9IiM4NEJFODQiIHJ4PSIzIiByeT0iMyIgc3R5bGU9InN0cm9rZTogIzAzODA0ODsgc3Ryb2tlLXdpZHRoOiAxLjA7Ii8+PHRleHQgZmlsbD0iIzAwMDAwMCIgZm9udC1mYW1pbHk9InNhbnMtc2VyaWYiIGZvbnQtc2l6ZT0iMTEiIGxlbmd0aEFkanVzdD0ic3BhY2luZ0FuZEdseXBocyIgdGV4dExlbmd0aD0iNjkiIHg9IjM1NSIgeT0iMjA5LjAxNTEiPm9wZXJhdGlvbjIoKTwvdGV4dD48IS0tTUQ1PVs2NDQ5NWI4ZmJmOWU3OWEwODBmNDQ5ZDQxZTVhNjIxM10KbGluayBDb250ZXh0IHRvIFN0YXRlLS0+PHBhdGggY29kZUxpbmU9IjIwIiBkPSJNODUuMjYwNiw0NCBDMTMyLjU3OCw0NCAyMTIuMjg4LDQ0IDI2NS4wMjIsNDQgIiBmaWxsPSJub25lIiBpZD0iQ29udGV4dC0mZ3Q7U3RhdGUiIHN0eWxlPSJzdHJva2U6ICNBODAwMzY7IHN0cm9rZS13aWR0aDogMS4wOyIvPjxwb2x5Z29uIGZpbGw9IiNBODAwMzYiIHBvaW50cz0iMjcwLjAzOSw0NCwyNjEuMDM5LDQwLDI2NS4wMzksNDQsMjYxLjAzOSw0OCwyNzAuMDM5LDQ0IiBzdHlsZT0ic3Ryb2tlOiAjQTgwMDM2OyBzdHJva2Utd2lkdGg6IDEuMDsiLz48cGF0aCBkPSJNMTA3LjI1LDcgTDEwNy4yNSwzMiBMMjQ0LjI1LDMyIEwyNDQuMjUsMTcgTDIzNC4yNSw3IEwxMDcuMjUsNyAiIGZpbGw9IiNGQkZCNzciIGZpbHRlcj0idXJsKCNmMWRnMDI0dTU5YTNldSkiIHN0eWxlPSJzdHJva2U6ICNBODAwMzY7IHN0cm9rZS13aWR0aDogMS4wOyIvPjxwYXRoIGQ9Ik0yMzQuMjUsNyBMMjM0LjI1LDE3IEwyNDQuMjUsMTcgTDIzNC4yNSw3ICIgZmlsbD0iI0ZCRkI3NyIgc3R5bGU9InN0cm9rZTogI0E4MDAzNjsgc3Ryb2tlLXdpZHRoOiAxLjA7Ii8+PHRleHQgZmlsbD0iIzAwMDAwMCIgZm9udC1mYW1pbHk9InNhbnMtc2VyaWYiIGZvbnQtc2l6ZT0iMTMiIGxlbmd0aEFkanVzdD0ic3BhY2luZ0FuZEdseXBocyIgdGV4dExlbmd0aD0iMTE2IiB4PSIxMTMuMjUiIHk9IjI0LjA2NjkiPnN0YXRlLm9wZXJhdGlvbjEoKTwvdGV4dD48IS0tTUQ1PVs4NGFhMWFiNjg4OTI2YTMwNjFmYTVjZTkzNWM1MGNjZV0KcmV2ZXJzZSBsaW5rIFN0YXRlIHRvIENvbmNyZXRlU3RhdGVBLS0+PHBhdGggY29kZUxpbmU9IjIyIiBkPSJNMjg1LjQ1NCw5OC40MzkgQzI3Ni42MDYsMTEyLjk2OSAyNjcuMjMsMTI4LjM2MzggMjU5LjEwNywxNDEuNzAxMSAiIGZpbGw9Im5vbmUiIGlkPSJTdGF0ZSZsdDstQ29uY3JldGVTdGF0ZUEiIHN0eWxlPSJzdHJva2U6ICNBODAwMzY7IHN0cm9rZS13aWR0aDogMS4wOyIvPjxwb2x5Z29uIGZpbGw9Im5vbmUiIHBvaW50cz0iMjc5LjQ4NSw5NC43ODMsMjk1Ljg2Niw4MS4zNDMsMjkxLjQ0MiwxMDIuMDY1LDI3OS40ODUsOTQuNzgzIiBzdHlsZT0ic3Ryb2tlOiAjQTgwMDM2OyBzdHJva2Utd2lkdGg6IDEuMDsiLz48IS0tTUQ1PVs2YzVkZTc4MzA1OGUzOWUzMThkNjNmMDgwYjMwM2UxMF0KcmV2ZXJzZSBsaW5rIFN0YXRlIHRvIENvbmNyZXRlU3RhdGVCLS0+PHBhdGggY29kZUxpbmU9IjIzIiBkPSJNMzUwLjQzMiw5OC45MTkgQzM1OS4wODcsMTEzLjMwNyAzNjguMjMyLDEyOC41MTA0IDM3Ni4xNjYsMTQxLjcwMTEgIiBmaWxsPSJub25lIiBpZD0iU3RhdGUmbHQ7LUNvbmNyZXRlU3RhdGVCIiBzdHlsZT0ic3Ryb2tlOiAjQTgwMDM2OyBzdHJva2Utd2lkdGg6IDEuMDsiLz48cG9seWdvbiBmaWxsPSJub25lIiBwb2ludHM9IjM0NC4xNzEsMTAyLjA4OSwzMzkuODYsODEuMzQzLDM1Ni4xNjgsOTQuODczLDM0NC4xNzEsMTAyLjA4OSIgc3R5bGU9InN0cm9rZTogI0E4MDAzNjsgc3Ryb2tlLXdpZHRoOiAxLjA7Ii8+PCEtLU1ENT1bN2RlZTdiNTY1ZWE5YjFmMGRhMjc2NzhjZTRhOTRkNzBdCkBzdGFydHVtbA0KY2xhc3MgQ29udGV4dCB7DQogICAgK3JlcWV1c3QoKQ0KfQ0KDQppbnRlcmZhY2UgU3RhdGUgew0KICAgICtvcGVyYXRpb24xKCkNCiAgICArb3BlcmF0aW9uMigpDQp9DQoNCmNsYXNzIENvbmNyZXRlU3RhdGVBIHsNCiAgICArb3BlcmF0aW9uMSgpDQogICAgK29wZXJhdGlvbjIoKQ0KfQ0KDQpjbGFzcyBDb25jcmV0ZVN0YXRlQiB7DQogICAgK29wZXJhdGlvbjEoKQ0KICAgICtvcGVyYXRpb24yKCkNCn0NCg0KQ29udGV4dCAtPiBTdGF0ZQ0Kbm90ZSBvbiBsaW5rOiBzdGF0ZS5vcGVyYXRpb24xKCkNClN0YXRlIDx8LSAtIENvbmNyZXRlU3RhdGVBDQpTdGF0ZSA8fC0gLSBDb25jcmV0ZVN0YXRlQg0KQGVuZHVtbA0KClBsYW50VU1MIHZlcnNpb24gMS4yMDIwLjE2YmV0YTcoVW5rbm93biBjb21waWxlIHRpbWUpCihHUEwgc291cmNlIGRpc3RyaWJ1dGlvbikKSmF2YSBSdW50aW1lOiBKYXZhKFRNKSBTRSBSdW50aW1lIEVudmlyb25tZW50CkpWTTogSmF2YSBIb3RTcG90KFRNKSA2NC1CaXQgU2VydmVyIFZNCkRlZmF1bHQgRW5jb2Rpbmc6IFVURi04Ckxhbmd1YWdlOiBlbgpDb3VudHJ5OiBVUwotLT48L2c+PC9zdmc+'>\n\n<p><code>Context::request()</code> call <code>state.operation1()</code>，將事情 delegate 給 state object 做。在糖果機的例子裡，<code>GumballMachine</code> 就是 <code>Context</code>。</p>\n<h2 id=\"由誰處理狀態轉換？\"><a href=\"#由誰處理狀態轉換？\" class=\"headerlink\" title=\"由誰處理狀態轉換？\"></a>由誰處理狀態轉換？</h2><p>狀態轉換可以在 state object 做，也可以在 context 做，糖果機的例子是由 state object 做狀態轉換。</p>\n<p>一般原則是狀態轉換是固定的時候，適合在 context 做，而轉換會在 runtime 因為條件不同而有不同時適合在 state object 做。</p>\n<p>在 state object 轉換狀態的缺點是會讓 state object 們互相依賴，解決這問題的方式之一是讓 state object 可以透過 context 取得其他 state object，也就是糖果機的 state getters。</p>\n<h2 id=\"與-Strategy-Pattern-比較\"><a href=\"#與-Strategy-Pattern-比較\" class=\"headerlink\" title=\"與 Strategy Pattern 比較\"></a>與 Strategy Pattern 比較</h2><p>State pattern 跟 <a href=\"/Strategy-Pattern\">Strategy pattern</a> 的 UML 根本長得一樣。兩個 pattern 的差異在於「意圖」，也可以說是出發點、想達到的目的。</p>\n<p>State pattern 將行為封裝在一堆 state object 中，context 隨著狀態不同將動作 delegate 給其中一個 state object。Strategy pattern 則是有很多 algorithm 可以選，通常由使用 algorithm 的使用者（使用 strategy 的 code）決定用哪一個。Strategy 提供了 algotithm 選擇上的彈性但由使用者主導。State 則以狀態為主，狀態改變會導致行為改變。</p>\n","tags":["Design Pattern"]},{"title":"Linking 的故事(?)","url":"/Story-of-linking/","content":"<p>很久很久以前（大概是還在用紙帶打洞的時代），會在 code 裡直接寫 variable 跟 function 所在的 address（我猜一開始說不定只有「要在哪裡取得資料」跟「要跳到哪裡繼續執行」的概念）。增加指令、修改程式後，會有很多 variable 及 function 的 address 被改變，像是中間多塞個指令就會讓後面東西 address 全改了，所以程式中所有 address 都需要重新調整（relocate）。</p>\n<p>這種 relocate 工作太令人崩潰，於是有人想出 symbol 的概念──以符號代表某個 variable 或 function（其實就是取名字）。code 裡改用 symbol，不再直接寫 address。等程式要執行的時候再把 symbol 換成真正的 address。這就是最開始 linking 主要做的事。</p>\n<p>隨著時代演進(?)，程式規模越來越大，人們開始在一個程式中分許多 module 並且分別 compile。有多個 module 後 linking 就要處理跨 module 的 variable 及 function 引用，也就是將在其他 module 中的 variable 跟 function 的 address 填入 reference 到它們的地方。例如在 A module 裡 call B module 的 function foo()，就要在 A module 中填入 foo() 真正的 address。</p>\n<p>如此一來，compile 階段可以不用知道 symbol 的 address，而且 module 也可以獨立 compile，等到 link 階段再由 linker 處理 symbol 及 address 的轉換。linker 就像是將多個 compile 好的 module 黏起來。</p>\n<p>linking 主要過程：</p>\n<ul>\n<li>Address and storage allocation</li>\n<li>Symbol resolution</li>\n<li>Relocation</li>\n</ul>\n","tags":["System Software"]},{"title":"Strategy Pattern","url":"/Strategy-Pattern/","content":"<p>定義演算法家族，將個別演算法封裝起來，讓它們可以互相替換。</p>\n<p>此 pattern 讓演算法的變動不會影響到使用演算法的部分。</p>\n<p>例子：最短路徑搜尋</p>\n<p><img src=\"/images/StrategyPatternEx.png\" alt=\"Strategy Pattern 最短路徑搜尋 class diagram\"></p>\n<p>將 shortest path algorithm 封裝起來，讓 RouteFinder 使用。RouteFinder 使用 ShortestPathStrategy 找 shortest path（RouteFinder 將找路徑的工作 delegate 給 ShortestPathStrategy），ShortestPathStrategy 的 instance 則依據使用哪種 algorithm 決定。</p>\n<p>有新的 algorithm 或 strategy 時只要 implement ShortestPathStrategy 並換掉 RouteFinder 使用的 instance 即可。</p>\n<h2 id=\"Ref\"><a href=\"#Ref\" class=\"headerlink\" title=\"Ref\"></a>Ref</h2><ul>\n<li>《深入淺出設計模式》</li>\n<li><a href=\"http://teddy-chen-tw.blogspot.tw/2013/08/strategy-pattern.html\" target=\"_blank\" rel=\"noopener\">http://teddy-chen-tw.blogspot.tw/2013/08/strategy-pattern.html</a></li>\n<li><a href=\"http://www.dotblogs.com.tw/joysdw12/archive/2013/03/07/95769.aspx\" target=\"_blank\" rel=\"noopener\">http://www.dotblogs.com.tw/joysdw12/archive/2013/03/07/95769.aspx</a></li>\n</ul>\n","tags":["Design Pattern"]},{"title":"Strong Symbol and Weak Symbol","url":"/Strong-Symbol-and-Weak-Symbol/","content":"<p>symbol 的 definition 可分為 strong symbol 跟 weak symbol。C/C++ 的 compiler 預設 function 及有初始化的 global variable 為 strong symbol，未初始化的 global variable 為 weak symbol。strong &amp; weak symbol 跟處理 symbol 重複定義有關：</p>\n<ol>\n<li>不允許 strong symbol 重複定義，有的話會 link error。</li>\n<li>如果一個 symbol 在某個 object file 中是 strong symbol，其他都是 weak symbol，選 strong symbol。</li>\n<li>如果都是 weak symbol，選 type size 最大的。</li>\n</ol>\n<h2 id=\"Usage\"><a href=\"#Usage\" class=\"headerlink\" title=\"Usage\"></a>Usage</h2><p>GCC 中可用 <code>__attribute__((weak))</code> 來定義一個 strong symbol 為 weak symbol：</p>\n<figure class=\"highlight c++\"><figcaption><span>weaksym.cpp</span></figcaption><table><tr><td class=\"code\"><pre><span class=\"line\">__attribute__((weak)) <span class=\"keyword\">int</span> x = <span class=\"number\">2</span>;\t<span class=\"comment\">// weak symbol</span></span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight c++\"><figcaption><span>main.cpp</span></figcaption><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">int</span> x = <span class=\"number\">123</span>;\t<span class=\"comment\">// strong symbol</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span> &lt;&lt; x &lt;&lt; <span class=\"built_in\">endl</span>;\t\t<span class=\"comment\">// result is 123</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>weak symbol 可以在 link time 置換 function。一開始給個預設 implementation 並設為 weak symbol，使用者可以寫 function 編成 object file 去 link。由於使用者寫的是 strong symbol 會蓋掉原本的 default implementation，達到 link 階段換 implementation。</p>\n<figure class=\"highlight c++\"><figcaption><span>weakfoo.cpp</span></figcaption><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">extern</span> <span class=\"keyword\">void</span> <span class=\"title\">foo</span><span class=\"params\">()</span> __<span class=\"title\">attribute__</span> <span class=\"params\">((weak))</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">foo</span><span class=\"params\">()</span> </span>&#123; <span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"default foo\"</span> &lt;&lt; <span class=\"built_in\">endl</span>; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    foo();</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight c++\"><figcaption><span>foo.cpp</span></figcaption><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">foo</span><span class=\"params\">()</span> </span>&#123; <span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"custom foo\"</span> &lt;&lt; <span class=\"built_in\">endl</span>; &#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight stylus\"><table><tr><td class=\"code\"><pre><span class=\"line\">&gt; g++ -c weakfoo<span class=\"selector-class\">.cpp</span> -o weakfoo.o</span><br><span class=\"line\">&gt; g++ -c foo<span class=\"selector-class\">.cpp</span> -o foo.o</span><br><span class=\"line\">&gt; g++ weakfoo.o</span><br><span class=\"line\">&gt; ./<span class=\"selector-tag\">a</span>.out</span><br><span class=\"line\">default foo</span><br><span class=\"line\">&gt; g++ weakfoo<span class=\"selector-class\">.o</span> foo.o</span><br><span class=\"line\">&gt; ./<span class=\"selector-tag\">a</span>.out</span><br><span class=\"line\">custom foo</span><br></pre></td></tr></table></figure>\n\n\n<h2 id=\"Ref\"><a href=\"#Ref\" class=\"headerlink\" title=\"Ref\"></a>Ref</h2><ul>\n<li>《程式設計師的自我修養》3.5.5</li>\n<li><a href=\"https://gcc.gnu.org/onlinedocs/gcc-4.1.2/gcc/Function-Attributes.html\" target=\"_blank\" rel=\"noopener\">https://gcc.gnu.org/onlinedocs/gcc-4.1.2/gcc/Function-Attributes.html</a></li>\n<li><a href=\"https://en.wikipedia.org/wiki/Weak_symbol\" target=\"_blank\" rel=\"noopener\">https://en.wikipedia.org/wiki/Weak_symbol</a></li>\n</ul>\n","tags":["Programming"]},{"title":"Stub","url":"/Stub-in-test/","content":"<p>External Dependency 是系統中與被測試程式互動但你無法掌控的物件。互動就是有 call 啊、使用回傳值之類的。</p>\n<p>stub 是在系統中產生一個可以控制的替代 object 來取代 external dependency object。</p>\n<p>使用 stub 可以解決直接相依帶來的測試問題：無法控制相依物件的行為及回傳值（例如每次 call third party API 得到的結果不同）或者相依物件不穩定，而難以有穩定的環境（固定的 input 及 output）測試要測試的程式邏輯。</p>\n<p>一種典型的 stub 是回傳假資料，藉由假造不同的回傳值來測試程式在不同情境下的運作，例如假造其他 function 的各種可能的回傳值。</p>\n","tags":["Unit Test"]},{"title":"Template Method Pattern","url":"/Template-Method-Pattern/","content":"<p>這個 pattern 是用來建立一個 algorithm 的 template。在一個 method 中定義 algorithm 的骨架，其中的小步驟定義在 derived class。可以在不改變 algorithm 架構的狀況下改變其中某些步驟的做法。</p>\n<h2 id=\"UML\"><a href=\"#UML\" class=\"headerlink\" title=\"UML\"></a>UML</h2><p><img src=\"/images/template_method_pattern.png\" alt=\"Template Method\"></p>\n<p>template method 定義了 algorithm 的骨架，derived class 藉由 override 其中的步驟 function 改變 algorithm 的行為。</p>\n<p>在 base class 中可以定義共用的 operation。有些 operation 在 algorithm 概念上是 derived class 一定要 implement 的，C++ 裡可用 pure virtual function。通常 base class 會有一份 hook 的 implement，derived class 可以選擇性 override hook，依據 hook 在 template method 裡的使用，override hook 可能影響 algorithm 的行為，例如做或不做某些步驟。</p>\n<h2 id=\"相關-pattern\"><a href=\"#相關-pattern\" class=\"headerlink\" title=\"相關 pattern\"></a>相關 pattern</h2><p>Factory Method pattern 是 Template Method 的特殊版，用來生 object。</p>\n<p><a href=\"/Strategy-Pattern/\">Strategy</a> 跟 Template Method 都用來封裝 algorithm，不過不太一樣。Strategy 是各個 derived class 自己完整 implement algorithm，Template Method 則是先訂好一個 “template”，其中的步驟是可以被改變的。</p>\n<h2 id=\"應用\"><a href=\"#應用\" class=\"headerlink\" title=\"應用\"></a>應用</h2><p>很多 UI framework，例如 Java 的 UI framework 跟 Qt，都有 <code>paint()</code> 之類的 painting function 以及 event handling function（例如處理 mouse event）就是使用 Template Method pattern。framework 已經決定何時會 call 這些 function，而 user 寫的 UI component 則依據需要 override 這些 function 決定實際上要做什麼事，如畫什麼東西、按滑鼠時要做什麼等等。</p>\n","tags":["Design Pattern"]},{"title":"Thread on Linux","url":"/Thread-on-Linux/","content":"<p>Linux 本身沒有 thread 的概念，它把 process 跟 thread 都視為 <strong>Task</strong>。</p>\n<p><code>fork()</code> 用來生 child process，生出來的是概念上的 process。</p>\n<p>而 <code>clone()</code> 可以生出跟 parent process 共用 memory space、file descriptor 的 table、signal handler 的 table 等東西的 child process，也就是概念上的 thread。Linux 用 <code>clone()</code> 實作 thread 概念。</p>\n<p><code>clone()</code> 有 glibc 包過的：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;sched.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">clone</span><span class=\"params\">(<span class=\"keyword\">int</span> (*fn)(<span class=\"keyword\">void</span> *), <span class=\"keyword\">void</span> *child_stack,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">          <span class=\"keyword\">int</span> flags, <span class=\"keyword\">void</span> *arg, ...</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">          <span class=\"comment\">/* pid_t *ptid, struct user_desc *tls, pid_t *ctid */</span> )</span></span>;</span><br></pre></td></tr></table></figure>\n\n<p>也有純 system call：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">long</span> <span class=\"title\">clone</span><span class=\"params\">(<span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> flags, <span class=\"keyword\">void</span> *child_stack,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">           <span class=\"keyword\">void</span> *ptid, <span class=\"keyword\">void</span> *ctid,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">           struct pt_regs *regs)</span></span>;</span><br></pre></td></tr></table></figure>\n","tags":["Linux","Thread"]},{"title":"C++ toolchain on windows and linux","url":"/Toolchain-on-windows-and-linux/","content":"<img src=\"../images/toolchain.png\" width=\"800\">\n\n<figure class=\"highlight taggerscript\"><table><tr><td class=\"code\"><pre><span class=\"line\">cl /I &lt;include path&gt;</span><br><span class=\"line\">link /LIBPATH:&lt;library path&gt; /OUT:&lt;output file&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">cl /I \"C:<span class=\"symbol\">\\P</span>rogram Files (x86)<span class=\"symbol\">\\M</span>icrosoft Visual Studio 12.0<span class=\"symbol\">\\V</span>C<span class=\"symbol\">\\i</span>nclude\" /c hello.cpp</span><br><span class=\"line\">link /LIBPATH:\"C:<span class=\"symbol\">\\P</span>rogram Files (x86)<span class=\"symbol\">\\M</span>icrosoft Visual Studio 12.0<span class=\"symbol\">\\V</span>C<span class=\"symbol\">\\l</span>ib\" /LIBPATH:\"C:<span class=\"symbol\">\\P</span>rogram Files (x86)<span class=\"symbol\">\\M</span>icrosoft SDKs<span class=\"symbol\">\\W</span>indows<span class=\"symbol\">\\v</span>7.1A<span class=\"symbol\">\\L</span>ib\" /OUT:hello.exe hello.obj</span><br></pre></td></tr></table></figure>\n\n<p>library path 加 <code>C:\\Program Files (x86)\\Microsoft SDKs\\Windows\\v7.1A\\Lib</code> 主要為了 <code>kernel32.lib</code>。</p>\n<p>不過很少直接用 <code>cl</code>，通常都是用 Visual Studio 整套 IDE。</p>\n","tags":["C++","Programming","Linux","Windows","Tip"]},{"title":"[做玩具] booksr - Simple book searcher in Ruby","url":"/Toy-booksr/","content":"<p><del>做玩具的碎念心得。</del></p>\n<p>用 Google Book API 找書的 Ruby 小程式。</p>\n<p>一開始因為 anobii  改版後變得超級難用，一氣之下不用了，又找不到好用的，就想自己寫一個網路書櫃。但是網路書櫃有點大，而且暫時不想架需要維護的平台，索性簡化，結果簡化成這個小玩具<del>（也簡化太多）</del>。</p>\n<p>目標是學寫 Ruby 程式、包 gem 跟丟上 RubyGems。</p>\n<p>程式邏輯本身很簡單，而且 Ruby 有很多現成的套件可以用，節省不少時間。不過沒用過這套 test framework，bundler 跟 gem 的熟悉度只有 <code>bundle install</code>，所以花比較多時間在 test 跟包 gem。</p>\n<h2 id=\"關於功能\"><a href=\"#關於功能\" class=\"headerlink\" title=\"關於功能\"></a>關於功能</h2><p>原本功能縮小到只想寫 book wrapper，把書籍資料包成 class，寫完覺得實在太陽春才變成找書。擴大功能後卻開始不只想用 Google Book API，還想加上 search Amazon 跟 ISBNDB。但以原本作為練習的目的來說，這些功能有點多餘。</p>\n<p>我有時候會因為某個功能看起來好酷就想加上去，有時候是覺得東西很陽春、太簡單，想加更複雜的能力進去。如果這些事情不斷發生，程式會越長越大、越長越大，<strong>卻永遠沒有完成的一天</strong>。這裡說的完成是指階段性完成──什麼時候要喊「夠了，可以了」然後把東西丟出去。</p>\n<p>這些讓我在中途思考要以「看起來很厲害」為優先，還是以「完成核心功能及達到最初目的」為優先。最後決定縮小範圍，以後者為優先。</p>\n<p><del>雖然弄完覺得像寫了個垃圾就是了…</del></p>\n<h2 id=\"關於搜尋結果\"><a href=\"#關於搜尋結果\" class=\"headerlink\" title=\"關於搜尋結果\"></a>關於搜尋結果</h2><p>有想過搜尋結果的筆數會不會太多？考慮過用其他方式當 output，例如一開始可以設最多只找幾筆之類的。但是試了一下，書籍的搜尋結果似乎不會多到太誇張，又懶得把介面搞得太複雜，就變成很簡單的全部 search 完一次傳回結果。</p>\n<h2 id=\"關於測試\"><a href=\"#關於測試\" class=\"headerlink\" title=\"關於測試\"></a>關於測試</h2><p>我糾結了一陣子到底要怎麼測，中間 test case 一直換一直換。測試有用 Google API 抓資料，不能太多，太多會被 403 擋掉…XD 搜尋結果不是固定的，做太詳細的資料檢驗沒什麼意義，所以最後只有兩種 test case：</p>\n<ol>\n<li>用找 isbn 測 class Book 是好的</li>\n<li>用找 title 測當搜尋結果超過 40 筆時回傳的結果筆數大於 40。<br>這是因為 API 限制一次的 search 結果最多只能有 40 筆，可以用起始 index 決定要顯示哪些 search 結果。</li>\n</ol>\n<h2 id=\"關於-Ruby\"><a href=\"#關於-Ruby\" class=\"headerlink\" title=\"關於 Ruby\"></a>關於 Ruby</h2><p>為什麼選 Ruby？</p>\n<p>沒為什麼……只是它有點名氣，然後我想寫點高階的東西，不然一天到晚在用 C++ 做輪子有點煩……</p>\n<p>越方便的技術代表它抽象化的程度越高，寫起來通常比較快，像在把現成的積木拼起來。但也代表它隱藏更多細節，我有時候會覺得不知道這些細節很沒有安全感(?)。到目前為止，Ruby 寫起來有很多方便的地方，可是我隱約覺得真要用得好還是要了解背後的原理，但那些原理可就不像一開始學的這種方便性那麼容易了。</p>\n","tags":["Murmur","Toy"]},{"title":"Use Shared Library in Linux","url":"/Use-Shared-Library-in-Linux/","content":"<h2 id=\"執行檔如何尋找-shared-library\"><a href=\"#執行檔如何尋找-shared-library\" class=\"headerlink\" title=\"執行檔如何尋找 shared library\"></a>執行檔如何尋找 shared library</h2><p>ELF 將依賴的 shared library 存在 <code>.dynamic</code> section 的 <code>DT_NEED</code> 欄位。</p>\n<figure class=\"highlight routeros\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ readelf -d main</span><br><span class=\"line\"></span><br><span class=\"line\">Dynamic section at offset 0x868 contains 26 entries:</span><br><span class=\"line\">  Tag       <span class=\"built_in\"> Type </span>                        Name/Value</span><br><span class=\"line\"> 0x0000000000000001 (NEEDED)             Shared library: [./libfoo.so]</span><br><span class=\"line\"> 0x0000000000000001 (NEEDED)             Shared library: [./libbar.so]</span><br><span class=\"line\"> 0x0000000000000001 (NEEDED)             Shared library: [libc.so.6]</span><br></pre></td></tr></table></figure>\n\n<p>如果是絕對路徑， dynamic linker 直接去該路徑存取 shared library。如果是相對路徑，則會依照以下順序到不同路徑下找 library：</p>\n<ul>\n<li><code>LD_LIBRARY_PATH</code> 環境變數指定的路徑</li>\n<li><code>.dynamic</code> section 中 <code>DT_RUNPATH</code> 欄位記錄的路徑</li>\n<li><code>/etc/ld.so.conf</code> 設定的路徑（實際上是讀取 <code>/etc/ld.so.cache</code>）</li>\n<li><code>/lib</code></li>\n<li><code>/usr/lib</code></li>\n</ul>\n<p>因為一個個搜尋路徑很慢，所以指令 <code>ldconfig</code> 除了更新系統中 library 的 SO-NAME soft link 外，還會將這些 SO-NAME 以特殊的形式存在 <code>/etc/ld.so.cache</code> 作為 cache 以加快搜尋。所以增加、刪除或更新 shared library 以及修改 <code>/etc/ld.so.conf</code> 後，都要執行 <code>ldconfig</code> 來更新 SO-NAME。</p>\n<h2 id=\"環境變數\"><a href=\"#環境變數\" class=\"headerlink\" title=\"環境變數\"></a>環境變數</h2><p>幾個跟 dynamic linking 有關的常用環境變數。</p>\n<h3 id=\"LD-LIBRARY-PATH\"><a href=\"#LD-LIBRARY-PATH\" class=\"headerlink\" title=\"LD_LIBRARY_PATH\"></a>LD_LIBRARY_PATH</h3><p>臨時改變 shared library 的搜尋路徑，開發跟 debug 的時候很好用。</p>\n<figure class=\"highlight elixir\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"variable\">$ </span>LD_LIBRARY_PATH=<span class=\"regexp\">/home/foo</span> ls</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"LD-PRELOAD\"><a href=\"#LD-PRELOAD\" class=\"headerlink\" title=\"LD_PRELOAD\"></a>LD_PRELOAD</h3><p>可以指定預先 load 的 shared library 或 object file，無論執行檔或使用的 shared library 有沒有依賴它。因為會使用先 load 的 shared library 的 symbol，所以可以用來改掉原本執行檔使用的 shared library，例如 standard C library。</p>\n<figure class=\"highlight jboss-cli\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ LD_PRELOAD=<span class=\"string\">./libfoo.so</span> <span class=\"string\">./main</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"LD-DEBUG\"><a href=\"#LD-DEBUG\" class=\"headerlink\" title=\"LD_DEBUG\"></a>LD_DEBUG</h3><p>可以看 dynamic linker 的 debug 訊息，設成 <code>help</code> 可以看可設定的值。</p>\n<h2 id=\"建立-amp-安裝-shared-library\"><a href=\"#建立-amp-安裝-shared-library\" class=\"headerlink\" title=\"建立 &amp; 安裝 shared library\"></a>建立 &amp; 安裝 shared library</h2><p>build 出 shared library：</p>\n<figure class=\"highlight angelscript\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ gcc -<span class=\"keyword\">shared</span> -fPIC -Wl,-soname,mysoname -o library_name sources</span><br></pre></td></tr></table></figure>\n\n<p><code>-shared</code> 表示輸出 shared library，<code>-fPIC</code> 表示使用 <a href=\"/Dynamic-Linking-PIC/\">PIC</a>。<code>-Wl</code> 可以將參數傳給 linker。<code>-soname</code> 是指定 SO-NAME，如果不指定，shared library 預設沒有 SO-NAME，即無法用 <code>ldconfig</code> 建 soft link。shared library 的 SO-NAME 可以用 <code>readelf -d</code> 查看。</p>\n<p>去除 symbol 資訊可以讓 shared library 檔案變小，常用在 release 時：</p>\n<figure class=\"highlight armasm\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ <span class=\"keyword\">strip </span>libfoo.so</span><br></pre></td></tr></table></figure>\n\n<p>安裝 shared library 通常是放到系統相關的路徑下，例如 <code>/lib</code>、<code>/usr/lib</code> 等，然後執行 <code>ldconfig</code> 更新 soft link。不過通常安裝會用 <code>make install</code> 之類的指令，不需要手動 copy 跟 <code>ldconfig</code>。</p>\n<h2 id=\"Related-Posts-amp-Ref\"><a href=\"#Related-Posts-amp-Ref\" class=\"headerlink\" title=\"Related Posts &amp; Ref\"></a>Related Posts &amp; Ref</h2><ul>\n<li>ld-linux manual</li>\n<li>《程式設計師的自我修養》ch8</li>\n<li><a href=\"/Dynamic-Linking-Basic/\">Dynamic Linking Basic</a></li>\n<li><a href=\"/Dynamic-Linking-PIC/\">Dynamic Linking PIC</a></li>\n<li><a href=\"/Dynamic-Linking-Relocation/\">Dynamic Linking Relocation</a></li>\n<li><a href=\"/Shared-Library-Versioning/\">Shared Library Versioning</a></li>\n<li><a href=\"/Explicit-Runtime-Linking/\">Explicit Runtime Linking</a></li>\n</ul>\n","tags":["Linux","System Software"]},{"title":"Visual Studio 2017 NUnit Usage","url":"/Visual-Studio-2017-NUnit-Usage/","content":"<p>NUnit 是 .NET 的 unit test framework</p>\n<h1 id=\"建立專案\"><a href=\"#建立專案\" class=\"headerlink\" title=\"建立專案\"></a>建立專案</h1><ol>\n<li>新增「Visual Studio C# 類別庫 (.Net Framework)」專案</li>\n<li>在 solution 裡加入 unit test 新專案，一樣是 Visual Studio C# 類別庫 (.Net Framework)</li>\n</ol>\n<p>unit test project 可命名為 <code>[Project].UnitTests</code>。</p>\n<h1 id=\"安裝-NUnit-套件\"><a href=\"#安裝-NUnit-套件\" class=\"headerlink\" title=\"安裝 NUnit 套件\"></a>安裝 NUnit 套件</h1><p>在 unit test project 右鍵 → 管理 NuGet 套件 → 搜尋 → 安裝。</p>\n<p>安裝 <code>NUnit</code>、<code>NUnit3TestAdapter</code> 套件，NUnit 裝完可以在參考看到 <code>nunit.framework</code>。</p>\n<p>安裝的 NUnit 版本是 3.11.0。</p>\n<h1 id=\"寫-amp-跑測試\"><a href=\"#寫-amp-跑測試\" class=\"headerlink\" title=\"寫 &amp; 跑測試\"></a>寫 &amp; 跑測試</h1><p>在 unit test project 加入要測試的 project 的參考。</p>\n<p>在 class 前標註 <code>[TestFixture]</code> 表示 NUnit 測試的類別，在 function 前標註 <code>[Test]</code> 表示測試。</p>\n<p>選單→測試→執行→所有測試，就會出現「測試總管」顯示測試結果啦～</p>\n<a id=\"more\"></a>\n\n<h1 id=\"SetUp-amp-TearDown\"><a href=\"#SetUp-amp-TearDown\" class=\"headerlink\" title=\"SetUp &amp; TearDown\"></a>SetUp &amp; TearDown</h1><p>執行每個測試 function 前會執行標上 <code>[SetUp]</code> attribute 的 function，通常用來準備物件、進行測試需要的設定等等。</p>\n<p>每個測試 function 執行後會執行標上 <code>[TearDown]</code> 的 function。</p>\n<p>標上 <code>[OneTimeSetUp]</code> 跟 <code>[OneTimeTearDown]</code> 則是在所有測試 function 執行前與執行後會跑一次的 function。</p>\n<p>這幾個 attribute 在一個 test fixture 裡都可以標多個 function，不過一般來說一個 test fixture 只會標一個，<a href=\"https://github.com/nunit/docs/wiki/SetUp-Attribute\" target=\"_blank\" rel=\"noopener\">在繼承的情況下</a>才會多個 function 使用相同 attribute。</p>\n<h1 id=\"Example\"><a href=\"#Example\" class=\"headerlink\" title=\"Example\"></a>Example</h1><figure class=\"highlight cs\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">using</span> System;</span><br><span class=\"line\"><span class=\"keyword\">using</span> NUnit.Framework;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">namespace</span> <span class=\"title\">LogAn.UnitTests</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    [<span class=\"meta\">TestFixture</span>]</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title\">LogAnalyzerTests</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">private</span> LogAnalyzer analyzer = <span class=\"literal\">null</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        [<span class=\"meta\">SetUp</span>]</span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">Setup</span>(<span class=\"params\"></span>)</span></span><br><span class=\"line\"><span class=\"function\"></span>        &#123;</span><br><span class=\"line\">            analyzer = <span class=\"keyword\">new</span> LogAnalyzer();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        [<span class=\"meta\">TearDown</span>]</span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">TearDown</span>(<span class=\"params\"></span>)</span></span><br><span class=\"line\"><span class=\"function\"></span>        &#123;</span><br><span class=\"line\">            <span class=\"comment\">// Just a sample</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        [<span class=\"meta\">Test</span>]</span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">IsValidFileName_BadExtension_ReturnsFalse</span>(<span class=\"params\"></span>)</span></span><br><span class=\"line\"><span class=\"function\"></span>        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">bool</span> result = analyzer.IsValidLogFileName(<span class=\"string\">\"testing.foo\"</span>);</span><br><span class=\"line\">            Assert.False(result);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"Ref\"><a href=\"#Ref\" class=\"headerlink\" title=\"Ref\"></a>Ref</h1><ul>\n<li><a href=\"https://github.com/nunit/docs/wiki/NUnit-Documentation\" target=\"_blank\" rel=\"noopener\">NUnit Documentation</a></li>\n</ul>\n","tags":["Unit Test"]},{"title":"開關訊號的 bounce","url":"/bounce-of-switch/","content":"<p>機械式開關切換時訊號會有 bounce（彈跳）現象。</p>\n<p><img src=\"/images/switch_bounce.gif\" alt=\"switch bounce\"></p>\n<p>上圖為理想狀況，下圖為實際上有 bounce 的狀況。bounce 持續時間約為 10~20 ms。</p>\n<p>程式在 bounce 期間會讀取到 bounce 的訊號造成判斷錯誤。例如按一下按鈕開關我們期望程式只讀到一次 on 的訊號，bounce 會造成程式讀到很多次 on 的訊號。</p>\n<p>解決方式軟體及硬體皆有，硬體的我看不懂所以這裡只說軟體。(欸)</p>\n<p>軟體解決方式：不處理 bounce 時間內的訊號。「不處理」的實際做法可以自己硬寫也可以在 <code>add_event_detect()</code> 裡設定。</p>\n<p>圖片來源：<a href=\"http://www.bbc.co.uk/schools/gcsebitesize/design/electronics/switchesrev2.shtml\" target=\"_blank\" rel=\"noopener\">http://www.bbc.co.uk/schools/gcsebitesize/design/electronics/switchesrev2.shtml</a></p>\n","tags":["Raspberry Pi"]},{"title":"C++ 降低 Compilation Dependency","url":"/c++-decrease-compilation-dependency/","content":"<p>一個檔案 include 另一個檔案時，這兩個檔案便形成 compilation dependency。一個被 include 的檔案一旦修改，跟它有 compilation dependency 的檔案（無論直接或間接 include）都需要重新 compile。假設 A.h include B.h，當 B.h 改變或 B.h include 的檔案改變時，所有 include A.h 的檔案都需要重新 compile。</p>\n<p>應該盡量降低 compile dependency，以減少修改一個 header 而需要重新 compile 的檔案數量，免得改個檔案全世界都要重新 compile。<del>（工程師無數青春在哭泣）</del></p>\n<p>原則上盡量<strong>以 declaration 的 dependency 取代 definition 的 dependency</strong>。</p>\n<ul>\n<li><p>可以用 object pointer 或 object reference，就不要用 object。</p>\n<p>可以在 class 裡宣告 pointer 或 reference 作為 member，就不要定義 object 當 member，因為定義 object 就需要該 class 的 definition。</p>\n</li>\n<li><p>分開 class 的宣告與實作</p>\n<p>讓 include（提供 definition）可以從 header file 移到真正使用這些 class、function 的 cpp file。</p>\n<ul>\n<li><p>Handle class</p>\n<p>使用兩個 class，一個代表宣告，一個是真正的實作。前者通常稱為 <code>Handle class</code>，只宣告 function 並有個 pointer 指向後者。外界使用 Handle class，而 Handle class 會轉 call 真正 implement 的 class 達到功能。這個方式用到第一點的概念──避免使用 object，改用 pointer。</p>\n<p>因為兩個 class 會有相同的 function，會造成同時 maintain 兩份類似 class 的問題。</p>\n</li>\n<li><p>Interface class（abstract base class）</p>\n<p>interface class 沒有 member data、沒有 constructor，只有一 virtual destructor 跟一堆 pure virtual function。實作的 class 繼承 interface class 進行功能實作，以 virtual function 的機制讓外界用 interface class 的 pointer 使用。</p>\n</li>\n</ul>\n<p>這兩種方法的 trade off 是速度會慢一點、多用點 memory，不過普遍上來說好處比 trade off 重要。</p>\n</li>\n</ul>\n<h2 id=\"Ref\"><a href=\"#Ref\" class=\"headerlink\" title=\"Ref\"></a>Ref</h2><ul>\n<li>《Effective C++》item 31</li>\n</ul>\n","tags":["C++","Programming"]},{"title":"C++ 應避免在 constructor 及 destructor 中 call virtual function","url":"/c-plus-plus-avoid-to-call-virtual-function-in-constructor-and-destructor/","content":"<p>應避免在 constructor 跟 destructor 中 call virtual function，否則容易造成跟預期不符的行為（誤以為可以 call 到 derived class 的 virtual function）。</p>\n<p>construct 到 base class 時，C++ 視該 object 為 base class object，derived class 的 virtual function 跟 member 都還沒建出來，所以 call 不到 derived class 的 virtual function。</p>\n<p>反過來的 destruct 則是在 derived class destructor 跑完後，derived class 的東西都刪光光了，該 object 就被當作 base class object，所以在 base class destructor 裡 call virtual function 不會 call 到 derived class 的 virtual function。</p>\n<p>除了要避免 constructor 跟 destructor call 到 virtual function，也要避免它們 call 的 function 再間接 call 到 virtual function。</p>\n<h2 id=\"Ref\"><a href=\"#Ref\" class=\"headerlink\" title=\"Ref\"></a>Ref</h2><ul>\n<li>《Effective C++》item 9</li>\n<li><a href=\"http://www.artima.com/cppsource/nevercall.html\" target=\"_blank\" rel=\"noopener\">http://www.artima.com/cppsource/nevercall.html</a></li>\n</ul>\n","tags":["C++","Programming"]},{"title":"C++ const member function","url":"/c-plus-plus-const-member-function/","content":"<p>不能修改 class non-static member data 也不能 call 其他非 const member function 的 member function。</p>\n<p>宣告 function 時在最後面加個 const 的 function，ex：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">GetIndex</span><span class=\"params\">()</span> <span class=\"keyword\">const</span></span>;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>Declaring a member function with the const keyword specifies that the function is a “read-only” function that does not modify the object for which it is called. A constant member function cannot modify any non-static data members or call any member functions that aren’t constant.</p>\n</blockquote>\n<p>compiler 會檢查 const member function 是否有改到 member data、return value 是否為 pointer 或 reference，如果改到 member data 或傳回可以讓外界修改 member data 時 compiler 會 error。可以透過這個特性反向檢查一個原本非 const 的 member function 是否有修改到 member data。</p>\n<p>如果要在 const member function 中修改特定 member data，可以在該 member data 的宣告前面加上 mutable。</p>\n<h2 id=\"Ref\"><a href=\"#Ref\" class=\"headerlink\" title=\"Ref\"></a>Ref</h2><ul>\n<li>《Effective C++》</li>\n<li><a href=\"http://msdn.microsoft.com/zh-tw/library/6ke686zh.aspx\" target=\"_blank\" rel=\"noopener\">http://msdn.microsoft.com/zh-tw/library/6ke686zh.aspx</a></li>\n</ul>\n","tags":["C++","Programming"]},{"title":"C++ Initialization","url":"/c-plus-plus-initialization/","content":"<p>C++ 對內建 type（如 int）要手動做 initial。</p>\n<h2 id=\"class-member-的初始化\"><a href=\"#class-member-的初始化\" class=\"headerlink\" title=\"class member 的初始化\"></a>class member 的初始化</h2><p>以 constructor 的 member initialization list 做 member 的初始化，會直接將參數丟給該 member 相對應的 constructor，可避免先 run member 的 default  constructor 後才再做 assign，效率較好。</p>\n<p>member 初始化順序：</p>\n<ol>\n<li>base class -&gt; derived class</li>\n<li>依宣告次序初始化（宣告次序與 member initialization list 的次序可能不同）</li>\n</ol>\n<p>初始化 member 的原則：將所有 member 依照宣告順序列在 member initialization list 中。</p>\n<h2 id=\"non-local-static-object-的初始化\"><a href=\"#non-local-static-object-的初始化\" class=\"headerlink\" title=\"non-local static object 的初始化\"></a>non-local static object 的初始化</h2><p>C++ 未定義在不同 translation unit((產生單一 object file 的 source code))中的 non-local static objects((不在 function 中的 static object，如 global object))的初始化相對次序。</p>\n<p>這會造成一些問題，例如在 source code A 裡的 global object objA 的初始化會用到在 source code B 裡的 global object objB 時可能有問題，因為不知道 objA 是不是會比 objB 晚初始化。</p>\n<p>解法：把 non-local static object 放到一 function 中，讓它不是 non-local，則可以知道初始化的順序。該 function return object 的 reference，要用這類 object 時就 call 相應 function。</p>\n<h2 id=\"Ref\"><a href=\"#Ref\" class=\"headerlink\" title=\"Ref\"></a>Ref</h2><ul>\n<li>《Effective C++》p.27~28, 31</li>\n</ul>\n","tags":["C++","Programming"]},{"title":"C++ Interface inheritance and Implement inheritance","url":"/c-plus-plus-interface-inheritance-and-implement-inheritance/","content":"<p>繼承分為 interface 繼承與 implement 繼承。interface 繼承僅繼承 interface，implementation 部分則由繼承者決定。implement 繼承則連同實作一同繼承。</p>\n<p>C++ 語意上用 virtual 區分 base class 希望 derived class 自己定義與不希望 derived class 修改的 function，virtual 為希望 derived class 自行定義，non-virtual 則不希望 derived class 修改。</p>\n<p>C++ 在區分 interface 及 implement 繼承上有：</p>\n<ul>\n<li>pure virtual function</li>\n<li>impure virtual function</li>\n<li>non-virtual function</li>\n</ul>\n<p><img src=\"/images/C++_virtual_and_inheritance.png\" alt=\"C++ virtual and inheritance\"></p>\n<h2 id=\"pure-virtual-function\"><a href=\"#pure-virtual-function\" class=\"headerlink\" title=\"pure virtual function\"></a>pure virtual function</h2><p>pure virtual function 是為了讓 derived class 繼承 base class 的 interface，而 implementation 則由 derived class 全權處理。當一 class 宣告 pure virtual function 時，代表要求 derived class 必須 implement 這些 pure virtual function（沒寫會 compile error），通常是這個繼承體系所需要的共同性質。</p>\n<h2 id=\"impure-virtual-function\"><a href=\"#impure-virtual-function\" class=\"headerlink\" title=\"impure virtual function\"></a>impure virtual function</h2><p>impure virtual function 是為了讓 derived class 繼承 interface 及預設的 implementation。也就是說，derived class 可以自己實作，也可以直接用 base class 的實作。</p>\n<p>這有個風險是，因為在 derived class 中並不強迫要寫出 base class 的 impure virtual function，導致在 derived class 應該有自己實作的狀況下，programmer 可能忘記在 derived class 實作。</p>\n<h2 id=\"non-virtual-function\"><a href=\"#non-virtual-function\" class=\"headerlink\" title=\"non-virtual function\"></a>non-virtual function</h2><p>non-virtual function 主要是為了讓 derived class 繼承 base class 的實作。</p>\n<p>雖然語法上 derived class 可 override base class 的 non-virtual function，但語意上的設計不建議 derived class override base class 的 non-virtual function。另外，override virtual function 跟 override non-virtual function 在實際執行上會有不同行為。</p>\n<p>non-virtua function 是 static binding。在一個繼承體系中 call non-virtual function 時會直接 call 宣告 type 的 class function。如果 derived class 沒有 override function，則因繼承關係 call 到 base class 的 function。如果 dervied class override function，則會 call 到 derived class 的。</p>\n<h2 id=\"Ref\"><a href=\"#Ref\" class=\"headerlink\" title=\"Ref\"></a>Ref</h2><ul>\n<li>《Effective C++》Differentiate between inheritance of interface and inheritance of implementation.</li>\n</ul>\n","tags":["C++","Programming"]},{"title":"C++ Type Casting","url":"/c-plus-plus-type-casting/","content":"<h2 id=\"Old-style-cast\"><a href=\"#Old-style-cast\" class=\"headerlink\" title=\"Old-style cast\"></a>Old-style cast</h2><p>C 風格的舊式轉型，在 C++ 裡不建議使用。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\">(T)expr</span><br></pre></td></tr></table></figure>\n\n<p>將 expr 轉成 type T。</p>\n<h2 id=\"C-style-cast\"><a href=\"#C-style-cast\" class=\"headerlink\" title=\"C++-style cast\"></a>C++-style cast</h2><p>C++ 的新型轉型有四種：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const_cast</span>&lt;T&gt;(expr)</span><br></pre></td></tr></table></figure>\n\n<p>將 const 轉成 non-const，只有這種轉型可以去掉 const。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">dynamic_cast</span>&lt;T&gt;(expr)</span><br></pre></td></tr></table></figure>\n\n<p>主要用來做 safe downcasting（將 base class pointer 轉成 derived class pointer），會在 runtime 判斷 object/expr 是否屬於 T 的繼承架構才進行轉型。轉型成功會傳回 address，失敗傳回 NULL。</p>\n<p>因為要判斷 object 是否屬於繼承架構，dynamic_cast 是執行效率低、成本大的 casting。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">reinterpret_cast</span>&lt;T&gt;(expr)</span><br></pre></td></tr></table></figure>\n\n<p>少用。做低階轉型，例如將 int* 轉成 int。實際結果取決於 compiler，因此不可移植、無法跨平台。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">static_cast</span>&lt;T&gt;(expr)</span><br></pre></td></tr></table></figure>\n\n<p>強制轉型，就像舊式轉型，如將 non-const 轉為 const、int 轉為 double 等。也可以用來將 base class pointer 轉成 derived class pointer，但比較不安全。</p>\n<h2 id=\"Ref\"><a href=\"#Ref\" class=\"headerlink\" title=\"Ref\"></a>Ref</h2><ul>\n<li>《Effective C++》</li>\n<li><a href=\"http://openhome.cc/Gossip/CppGossip/dynamicCast.html\" target=\"_blank\" rel=\"noopener\">http://openhome.cc/Gossip/CppGossip/dynamicCast.html</a></li>\n</ul>\n","tags":["C++","Programming"]},{"title":"C++ Virtual Destructor","url":"/c-plus-plus-virtual-destructor/","content":"<p><strong>為有「多型」性質（即有 virtual function）的 base class 宣告 virtual destructor。</strong></p>\n<p>C++ 沒有定義 base class 的 destructor 是 non-virtual 時以 base class pointer 刪除 derived class 的 object 的行為。常出現的結果是只有 base class 部分的 memory 會被釋放、derived class 部分的不會釋放，這會造成「局部銷毀」物件的問題，memory 當然就沒 free 乾淨。</p>\n<p>用 virtual destructor 可以解決上述問題，因為 virtual function 的性質會 call 到 derived class 的 destructor。</p>\n<p>不過不是把所有 base class 的 destructor 宣告成 virtual 就好，非必要（沒有 virtual function）時不需要這麼宣告。</p>\n<h2 id=\"Ref\"><a href=\"#Ref\" class=\"headerlink\" title=\"Ref\"></a>Ref</h2><ul>\n<li>《Effective C++》</li>\n</ul>\n","tags":["C++","Programming"]},{"title":"更換 search engine 為 Swiftype","url":"/change-search-engine-to-swiftype/","content":"<p>技術 blog 沒有搜尋挺麻煩的，儘管有設 tag，但還是搜尋最方便。之前在 Octopress 用的 Tapir 不支援中文，看起來沒什麼解，只好另尋新歡(?)。找到 <a href=\"https://swiftype.com\" target=\"_blank\" rel=\"noopener\">Swiftype</a> 這套，除了基本搜尋功能外，Swiftype 還提供調整搜尋結果、統計分析等功能。</p>\n<p>註冊、輸入 URL，它處理完後到 INSTALL 頁面 copy source code 到 theme 中相應 call <code>search_form()</code> 的地方。每個 theme 的位置不太一樣，nut 在 <code>layout/_widget/search.ejs</code>，landscape 在 <code>layout/_partial/header.ejs</code>。</p>\n<p>發現一個問題：在 overlay 的顯示方式下，搜尋結果的頁面太長，scroll bar 無法捲到最下面。想改成結果直接顯示在頁面，不用 overlay，之後參考<a href=\"https://swiftype.com/documentation/widget\" target=\"_blank\" rel=\"noopener\">這裡</a>看怎麼改。</p>\n","tags":["Hexo","Blog"]},{"title":"更換 Octopress 的搜尋功能","url":"/change-search-for-octopress/","content":"<p>發現兩個問題：Tapir 不支援中文、換過 permalink 會怪怪的。</p>\n<p><em>2014/4/28 updated</em></p>\n<hr>\n<p>Octopress 預設的 search 功能是 Google search，一搜尋就會導到 Google 的頁面。不太喜歡這種方式，把 search 換成 <a href=\"http://tapirgo.com/\" target=\"_blank\" rel=\"noopener\">Tapir</a>，可以在自己站內找。</p>\n<p>Tapir 的原理是它每 15 分鐘會掃一次網站的 RSS，再透過他們的 API 達到以 RSS 為 base 的搜尋功能。要注意的是，沒在 RSS 中的文章是不會被 search 到的。</p>\n<h2 id=\"修改方式\"><a href=\"#修改方式\" class=\"headerlink\" title=\"修改方式\"></a>修改方式</h2><p>先到 <a href=\"http://tapirgo.com/\" target=\"_blank\" rel=\"noopener\">Tapir</a> 輸入 RSS feed 跟 mail，會得到一組 key，這裡只需要用到 public key。</p>\n<p>到 <a href=\"https://github.com/blimey85/octopress-tapir\" target=\"_blank\" rel=\"noopener\">Octopress Tapir plugin</a> 下載所需檔案並放到對應資料夾。</p>\n<ul>\n<li>source/search.html</li>\n<li>source/javascripts/jquery_tapir.js</li>\n<li>source/images/loading.gif</li>\n</ul>\n<p>修改 <code>_config.yml</code>：</p>\n<ul>\n<li>註解掉 <code>simple_search</code></li>\n<li>加入 <code>tapir_token: [your public key from Tapir]</code></li>\n</ul>\n<p>修改 <code>source/_includes/navigation.html</code>，在 <code>include custom/navigation.html</code> 前面加入：</p>\n\n    {% if site.tapir_token %}\n    <form method=\"get\" action=\"{{ root_url }}/search.html\">\n    <fieldset role=\"search\">\n\t  <input class=\"search\" name=\"query\" type=\"text\" placeholder=\"Search...\" x-webkit-speech />\n    </fieldset>\n    </form>\n    {% endif %}\n\n\n<p>修改 <code>source/atom.xml</code>，拿掉 <code>for post in site.posts limit: 20</code> 的 <code>limit: 20</code>，讓所有 post 都會出現在 RSS feed 。另一個可能的做法是複製 <code>source/atom.xml</code> 為 <code>source/atomForSearch.xml</code>，<code>rake generate</code> 後將這個 XML 的 URL 丟給 Tapir 當作 search 的 base。</p>\n<h2 id=\"Ref\"><a href=\"#Ref\" class=\"headerlink\" title=\"Ref\"></a>Ref</h2><ul>\n<li><a href=\"http://tapirgo.com/\" target=\"_blank\" rel=\"noopener\">http://tapirgo.com/</a></li>\n<li><a href=\"https://github.com/blimey85/octopress-tapir\" target=\"_blank\" rel=\"noopener\">https://github.com/blimey85/octopress-tapir</a></li>\n<li><a href=\"http://minizatic.github.io/blog/2013/08/08/installing-octopress-plugins/\" target=\"_blank\" rel=\"noopener\">http://minizatic.github.io/blog/2013/08/08/installing-octopress-plugins/</a></li>\n</ul>\n","tags":["Tip","Blog","Octopress"]},{"title":"Travis 設定 Github Access Token","url":"/config-travis-and-github-with-composer/","content":"<h2 id=\"Problem\"><a href=\"#Problem\" class=\"headerlink\" title=\"Problem\"></a>Problem</h2><p>Travis 在 run <code>composer install</code> 會出現類似以下錯誤：</p>\n<figure class=\"highlight livecodeserver\"><table><tr><td class=\"code\"><pre><span class=\"line\">Failed <span class=\"built_in\">to</span> clone <span class=\"keyword\">the</span> git@github.com:jquery/jquery-dist.git repository, <span class=\"keyword\">try</span> running <span class=\"keyword\">in</span> interactive mode so that you can enter your GitHub credentials</span><br><span class=\"line\"></span><br><span class=\"line\">  [Composer\\Repository\\InvalidRepositoryException]</span><br><span class=\"line\">  No valid bower.json was found <span class=\"keyword\">in</span> <span class=\"keyword\">any</span> branch <span class=\"keyword\">or</span> tag <span class=\"keyword\">of</span> <span class=\"keyword\">https</span>://github.com/jq</span><br><span class=\"line\">  uery/jquery-dist.git, could <span class=\"keyword\">not</span> <span class=\"built_in\">load</span> <span class=\"keyword\">a</span> package <span class=\"built_in\">from</span> <span class=\"keyword\">it</span>.</span><br></pre></td></tr></table></figure>\n\n<p>失敗的 repository 不一定，可能這次 jquery 下次別的。</p>\n<p>找了一陣，說是踩到 Github 的 <a href=\"https://developer.github.com/v3/#rate-limiting\" target=\"_blank\" rel=\"noopener\">rate limit</a>（我理解是 <code>composer install</code> 會一直從 github 抓東西所以容易踩到），但又有文章說這個問題已經被修正。<del>我還是踩到了啊</del></p>\n<h2 id=\"Solution\"><a href=\"#Solution\" class=\"headerlink\" title=\"Solution\"></a>Solution</h2><ol>\n<li>在 Github 產生 <a href=\"https://github.com/settings/tokens\" target=\"_blank\" rel=\"noopener\">Personal access token</a>。</li>\n<li>在 Travis 設定有使用 Travis 的 project 的環境變數（environment variable），指定變數名稱，值是剛剛在 Github 產生的 access token。</li>\n<li>修改 <code>.travis.yml</code>，在 <code>composer install</code> 前加入 <code>composer config github-oauth.github.com ${環境變數名稱}</code></li>\n</ol>\n<h2 id=\"Ref\"><a href=\"#Ref\" class=\"headerlink\" title=\"Ref\"></a>Ref</h2><ul>\n<li><a href=\"https://blog.wyrihaximus.net/2015/09/github-auth-token-on-travis/\" target=\"_blank\" rel=\"noopener\">Github auth token on TravisCI</a></li>\n</ul>\n","tags":["Tip","Github","Travis"]},{"title":"C++ 在 operator=() 處理 self assignment","url":"/cpp-handle-self-assignment-in-operator-assignment/","content":"<p>self assignment：object 被 assign 給自己。</p>\n<p>class member 有 pointer 時寫 <code>operator=()</code> 要小心處理 self assignment。如果先把自己原本的 member delete 掉，等同把 rhs 的 member 也 delete 掉，assign 後會得到爛掉的 pointer。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\">Foo&amp; Foo::<span class=\"keyword\">operator</span>=(<span class=\"keyword\">const</span> Foo&amp; rhs)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    Bitmap* pOrig = pb;    <span class=\"comment\">// pb is member pointer in Widget</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (rhs.pb != <span class=\"literal\">NULL</span>)</span><br><span class=\"line\">        pb = <span class=\"keyword\">new</span> Bitmap(*rhs.pb);</span><br><span class=\"line\">    <span class=\"keyword\">else</span></span><br><span class=\"line\">        pb = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">delete</span> pOrig;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> *<span class=\"keyword\">this</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>這做法可以處理 member pointer 但會讓 member pointer 指的位置經過 self assignment 後變得不同，另一種做法是檢查 <code>this</code> 是否跟 <code>&amp;rhs</code> 相同，不同時才真的做 copy。 </p>\n<h2 id=\"Ref\"><a href=\"#Ref\" class=\"headerlink\" title=\"Ref\"></a>Ref</h2><ul>\n<li>《Effective C++》</li>\n</ul>\n","tags":["C++","Programming"]},{"title":"Delegate","url":"/delegate/","content":"<p>Delegate 中文叫「委派」。</p>\n<p>將某些操作（例如是否相等）的細節交給 object 自己處理。</p>\n<p>用一點簡單的 code 來說明。首先是沒有 delegate 的寫法（這裡先不管 member 放在 public 不是好習慣的問題）：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Foo</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    Foo(<span class=\"keyword\">int</span> x, <span class=\"keyword\">int</span> y) : m_x(x), m_y(y) &#123; &#125;;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">int</span> m_x;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> m_y;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    Foo foo1(10, 20), foo2(200, 300);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (foo1.m_x == foo2.m_x &amp;&amp; foo1.m_y == foo2.m_y)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"comment\">// do sth.</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>這種方式，當在<strong>任何地方</strong>需要比較兩個 <code>Foo</code> object 時，都要像上面第 14 行這樣寫。<del>不覺得這樣都把 Foo 肚子裡的東西挖出來到處亂放嗎？</del>如果之後 Foo 要多加一個 member，<strong>所有比較 <code>Foo</code> object 的地方</strong>都要改，光是有 20 個地方要改就有得受了，更何況還可能漏掉勒。所以啦，delegate 的觀念就可以在這裡拯救可憐的工程師，以下是有 delegate 觀念的版本：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Foo</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    Foo(<span class=\"keyword\">int</span> x, <span class=\"keyword\">int</span> y) : m_x(x), m_y(y) &#123; &#125;;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">IsEqual</span><span class=\"params\">(<span class=\"keyword\">const</span> Foo&amp; rFoo)</span> <span class=\"keyword\">const</span></span></span><br><span class=\"line\"><span class=\"function\">\t</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> (m_x == rFoo.m_x &amp;&amp; m_y == rFoo.m_y);</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">int</span> m_x;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> m_y;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    Foo foo1(10, 20), foo2(200, 300);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (foo1.IsEqual(foo2))</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"comment\">// do sth.</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>增加 <code>IsEqual()</code> 後，我們就可以把判斷放進 <code>class Foo</code>，由 <code>Foo</code> 自己處理如何判斷相等的這件事。外面只需要 call <code>IsEqual()</code> 就可以比較兩個 <code>Foo</code> object，也就是外界將判斷相等的事情「委派」給 <code>Foo</code>。這時候如果多加一個 member <code>m_z</code>，只需要改 <code>IsEqual()</code> 的 implement 就可以了，外面 20 個比較的地方都不用改！世界變得一片美好。</p>\n<p>文言一點來說，delegate 有助於保持 <code>loosely coupled</code>。loosely coupled 表示 object 彼此獨立（也可以看成 object 跟其他 code），對一 object 的修改不會引起一連串其他 object 或 code 的修改。</p>\n<h2 id=\"問題時間\"><a href=\"#問題時間\" class=\"headerlink\" title=\"問題時間\"></a>問題時間</h2><ul>\n<li><p>為什麼不用 C++ 的 <code>operator==</code>？</p>\n<p>用 <code>operator==</code> 也可以。這裡想表達的是 delegate 的觀念，如何實作不是重點。反過來說，不同語言也有不同的特性跟用法，而一個觀念可以用很多種方式實作。</p>\n</li>\n<li><p>為什麼感覺有封裝的味道？</p>\n<p>我也這麼覺得。一些 OO 原則跟觀念彼此根本一家親，運用 A 的同時也運用了 B。我暫時想不出更好的範例了，就先這樣吧！:P</p>\n</li>\n</ul>\n","tags":["OOAD"]},{"title":"設計 C++ class","url":"/design-a-new-c-plus-plus-class/","content":"<p>列出設計一新 class 時需要注意的問題跟與其相關的東西：</p>\n<ul>\n<li><p>真的需要一個新 class 嗎？<em>（我覺得這最重要）</em></p>\n<p>使用既有 class 是否能達成需求？</p>\n</li>\n<li><p>如何產生及銷毀新 class 的 object？</p>\n<p>與 constructor、destructor、new、new[]、delete、delete[] 有關</p>\n</li>\n<li><p>物件的 initialization 跟 assignment 有何區別？</p>\n<p>與 constructor、assignment operator 的行為有關</p>\n</li>\n<li><p>如果以 pass by value 的方式傳遞新 class 的 object 時是什麼意思？</p>\n<p>與 copy constructor 有關</p>\n</li>\n<li><p>新 class 的合法值為何？</p>\n<p>需維護的條件、member function（如 constructor、assignment operator、setter）所做的錯誤檢查、exception、exception specification</p>\n</li>\n<li><p>新 class 是否繼承某個繼承架構？</p>\n<p>base class 的 non-virtual 及 virtual function</p>\n<p>virtual distructor</p>\n</li>\n<li><p>新 class 需要那些轉型？</p>\n<p>轉型 function</p>\n</li>\n<li><p>那些 operator、function 對此 class 來說是合法的？</p>\n<p>牽涉到要宣告那些 function？是否為 member？</p>\n</li>\n<li><p>不想使用哪些 compiler 會自動生成的 function（如 constructor）？</p>\n<p>如果不使用，將它宣告成 private。</p>\n</li>\n<li><p>誰可以使用新 class 的 memeber？</p>\n<p>public、protected、private、friend</p>\n</li>\n<li><p>新 class 的 undeclared interface 是？</p>\n</li>\n<li><p>這個 class 需要多 general？</p>\n<p>class template</p>\n</li>\n</ul>\n<h2 id=\"Ref\"><a href=\"#Ref\" class=\"headerlink\" title=\"Ref\"></a>Ref</h2><ul>\n<li>《Effective C++》item 19</li>\n</ul>\n","tags":["C++","Programming"]},{"title":"Dokuwiki Tips","url":"/dokuwiki-tips/","content":"<h2 id=\"清除特定頁面-cache\"><a href=\"#清除特定頁面-cache\" class=\"headerlink\" title=\"清除特定頁面 cache\"></a>清除特定頁面 cache</h2><p>在該頁面網址後面加上</p>\n<figure class=\"highlight routeros\"><table><tr><td class=\"code\"><pre><span class=\"line\">?<span class=\"attribute\">purge</span>=<span class=\"literal\">true</span></span><br></pre></td></tr></table></figure>\n\n\n<h2 id=\"clean-cache-script\"><a href=\"#clean-cache-script\" class=\"headerlink\" title=\"clean cache script\"></a>clean cache script</h2><figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#!/bin/bash</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">cleanup</span></span>() &#123;</span><br><span class=\"line\">  <span class=\"comment\"># $1 ... full path to data directory of wiki</span></span><br><span class=\"line\">  <span class=\"comment\"># $2 ... number of days after which old files are to be removed</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\"># purge files older than $2 days from attic and media_attic (old revisions)</span></span><br><span class=\"line\">  find <span class=\"string\">\"<span class=\"variable\">$1</span>\"</span>/&#123;media_,&#125;attic/ -<span class=\"built_in\">type</span> f -mtime +<span class=\"variable\">$2</span> -print0 | xargs -0r rm -f</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\"># remove stale lock files (files which are 1-2 days old)</span></span><br><span class=\"line\">  find <span class=\"string\">\"<span class=\"variable\">$1</span>\"</span>/locks/ -name <span class=\"string\">'*.lock'</span> -<span class=\"built_in\">type</span> f -mtime +1 -print0 | xargs -0r rm -f</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\"># remove empty directories</span></span><br><span class=\"line\">  find <span class=\"string\">\"<span class=\"variable\">$1</span>\"</span>/&#123;attic,cache,index,locks,media,media_attic,media_meta,meta,pages,tmp&#125;/ \\</span><br><span class=\"line\">    -mindepth 1 -<span class=\"built_in\">type</span> d -empty -print0 | xargs -0r rmdir</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\"># remove files older than $2 days from the cache</span></span><br><span class=\"line\">  find <span class=\"string\">\"<span class=\"variable\">$1</span>\"</span>/cache/?/ -<span class=\"built_in\">type</span> f -mtime +<span class=\"variable\">$2</span> -print0 | xargs -0r rm -f</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>使用方式：</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ ./cleanwiki.sh <span class=\"tag\">&lt;<span class=\"name\">path</span> <span class=\"attr\">of</span> <span class=\"attr\">dokuwiki</span>&gt;</span>/data <span class=\"tag\">&lt;<span class=\"name\">天數</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n\n<h2 id=\"Ref\"><a href=\"#Ref\" class=\"headerlink\" title=\"Ref\"></a>Ref</h2><ul>\n<li><a href=\"https://www.dokuwiki.org/tips:maintenance\" target=\"_blank\" rel=\"noopener\">https://www.dokuwiki.org/tips:maintenance</a></li>\n</ul>\n","tags":["Tip","Dokuwiki"]},{"title":"Eclipse Theme","url":"/eclipse-theme/","content":"<p><em>Eclipse 編輯區預設背景是白色的，對於用慣 vim、console 這種底都黑黑的我來說實在是有點不舒服，理所當然的就要來找找 theme。</em></p>\n<p>發現一個 plugin：Eclipse Color Themes</p>\n<p>官網：<a href=\"http://eclipsecolorthemes.org/\" target=\"_blank\" rel=\"noopener\">http://eclipsecolorthemes.org/</a></p>\n<p>update site：<a href=\"http://eclipse-color-theme.github.com/update/\" target=\"_blank\" rel=\"noopener\">http://eclipse-color-theme.github.com/update/</a></p>\n<p>Help → Install New Software 將 update site 加進去，就可以選 Eclipse Color Themes 來裝。</p>\n<p>theme 可以到官網抓 EPF 格式，File → Import → Preference 套用。</p>\n","tags":["Eclipse","Tip"]},{"title":"封裝會改變的東西","url":"/encapsulate-change/","content":"<p>封裝會改變的東西，減少改動一個部分會影響到其他部分的狀況。</p>\n<p>將 class 中容易改變的部分封裝到另一個 class 有助於保護原本 class 有不必要的改變。</p>\n<p>程式改變可能改動到相關功能，如果一個 class 中常修改的地方並非該 class 負責的事情，修改它是不必要的，而且可能引入其他功能受到影響的風險。如果能將常修改的地方封裝，就可以保護原本 class 的其他功能不受影響。</p>\n<p>「封裝」不單指將東西包成 class，把一堆 property 放到 map 之類的 container 也是封裝。</p>\n<h2 id=\"Related-Posts\"><a href=\"#Related-Posts\" class=\"headerlink\" title=\"Related Posts\"></a>Related Posts</h2><ul>\n<li><a href=\"/Open-Closed-Principle\">Open Closed Principle（OCP）</a></li>\n<li><a href=\"/Single-Responsibility-Principle\">Single Responsibility Principle（SRP）</a></li>\n<li><a href=\"/Dont-Repeat-Yourself\">Don’t Repeat Yourself（DRY）</a></li>\n</ul>\n","tags":["OOAD"]},{"title":"Feature driven and Use case driven development","url":"/feature-driven-and-use-case-driven-development/","content":"<p>設計軟體事先處理整體系統輪廓，將大系統切成多個較小的問題，再逐一反覆處理每個小問題直到完成整個系統。</p>\n<p>Feature Driven Development 及 Use Case Driven Development 是「將系統切成小問題再逐一反覆處理」的方式。</p>\n<h2 id=\"Feature-Driven-Development\"><a href=\"#Feature-Driven-Development\" class=\"headerlink\" title=\"Feature Driven Development\"></a>Feature Driven Development</h2><p>以 feature 為主軸，以功能為切入角度。</p>\n<p>挑出特定功能，規劃、分析及開發該功能直到完成。</p>\n<p>看系統的角度比較 granular。</p>\n<p>適合功能較個別獨立、未密切相連的系統。</p>\n<h2 id=\"Use-Case-Driven-Development\"><a href=\"#Use-Case-Driven-Development\" class=\"headerlink\" title=\"Use Case Driven Development\"></a>Use Case Driven Development</h2><p>以 use case diagram 為主軸，以 scenario（使用情境）及流程為切入角度。從 use diagram 拿出一個個 use case 做，挑出 use case 的 scenraio，寫 code 支援該 scenario，直到完成 use case 的所有 scenario 以及完成所有 use case。</p>\n<p>看系統的角度比較整體。</p>\n<p>適合由一堆流程構成的系統，例如差勤請假系統。</p>\n<h2 id=\"碎念時間\"><a href=\"#碎念時間\" class=\"headerlink\" title=\"碎念時間\"></a>碎念時間</h2><p>實際上開發軟體會混合多種方式，例如從 use case driven 開始，接著在 use case 挑出小功能進行設計（這是 feature driven），最後在實作階段用 test driven 來思考如何 implement。</p>\n<p>開發軟體的方式很多，各有其適用之所在，重點不在於哪個方法最好，而是哪些方法的搭配使用能較好的解決所面對的問題。</p>\n","tags":["OOAD"]},{"title":"Git + github in Linux","url":"/git-plus-github-in-linux/","content":"<p>用 github 可以做到類似遠端備份的功能，類似 svn 的中央 server（但不一樣）。每個 client 在本地端都有完整的 git repository，在 local 就可以做 commit 等操作，而非一定要連到 github。</p>\n<p>先到 <a href=\"https://github.com/\" target=\"_blank\" rel=\"noopener\">Github</a> 申請帳號。github 提供免費帳號無上限的 public repository，如果要私人的 Repository 就要付錢囉。</p>\n<p>以下操作都是在 Linux 上，在 Windows 上沒特別研究。</p>\n<h2 id=\"安裝-git\"><a href=\"#安裝-git\" class=\"headerlink\" title=\"安裝 git\"></a>安裝 git</h2><p>看是在哪種 Linux distribution 上，通常可以直接裝套件（Fedora 用 <code>yum</code>，Ubuntu 用 <code>apt</code>，Gentoo 用 <code>emerge</code>，可參考<a href=\"http://git-scm.com/download/linux\" target=\"_blank\" rel=\"noopener\">這裡</a>）。</p>\n<h2 id=\"設定-ssh-key\"><a href=\"#設定-ssh-key\" class=\"headerlink\" title=\"設定 ssh key\"></a>設定 ssh key</h2><p>為了方便跟 github 傳輸資料，要設 ssh 的 public/private key：</p>\n<figure class=\"highlight elixir\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"variable\">$ </span>ssh-keygen -t rsa</span><br></pre></td></tr></table></figure>\n\n<p>產生一組 key，預設放在 <code>~/.ssh/</code>。</p>\n<p>Enter passphrase 是每次存取這把 key 時要輸入的密碼，有輸入的話每次用 git 指令 access github 都要打一次密碼。</p>\n<p>到 github Account Setting 中的 SSH KEYS 增加 key，把剛產生的 public key（預設是 <code>~/.ssh/id_rsa.pub</code>）貼上去。</p>\n<h2 id=\"在-github-新增-repository\"><a href=\"#在-github-新增-repository\" class=\"headerlink\" title=\"在 github 新增 repository\"></a>在 github 新增 repository</h2><p>照著網頁按，幾乎只要輸入 repository name 就可以了。</p>\n<h2 id=\"將現有的-git-repository-上傳（push）至-github\"><a href=\"#將現有的-git-repository-上傳（push）至-github\" class=\"headerlink\" title=\"將現有的 git repository 上傳（push）至 github\"></a>將現有的 git repository 上傳（push）至 github</h2><figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> <span class=\"built_in\">cd</span> mygit</span></span><br><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> git remote add origin git@github.com:[userid]/[rep<span class=\"string\">'s name].git</span></span></span><br><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> git push origin master</span></span><br></pre></td></tr></table></figure>\n\n<p>[userid] 是 github 上的帳號。[rep’s name] 是 repository name。</p>\n<h2 id=\"下載（clone）github-上的-repository-到-local-端\"><a href=\"#下載（clone）github-上的-repository-到-local-端\" class=\"headerlink\" title=\"下載（clone）github 上的 repository 到 local 端\"></a>下載（clone）github 上的 repository 到 local 端</h2><p>初次下載，在 Git 稱為 clone。</p>\n<p>抓自己或其他人的皆可。</p>\n<figure class=\"highlight asciidoc\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ git clone git@github.com:[userid]/[rep's name].git [local dir name]</span><br><span class=\"line\">$ git clone <span class=\"link\">https://github.com/</span>[<span class=\"string\">userid</span>]/[rep's name].git [local dir name]</span><br></pre></td></tr></table></figure>\n\n<p>使用兩種不同 protocol clone。</p>\n<h2 id=\"將自己的修改傳上-github\"><a href=\"#將自己的修改傳上-github\" class=\"headerlink\" title=\"將自己的修改傳上 github\"></a>將自己的修改傳上 github</h2><figure class=\"highlight avrasm\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ git <span class=\"keyword\">push</span></span><br></pre></td></tr></table></figure>\n\n\n<h2 id=\"將-github-上較新的-code-抓下來\"><a href=\"#將-github-上較新的-code-抓下來\" class=\"headerlink\" title=\"將 github 上較新的 code 抓下來\"></a>將 github 上較新的 code 抓下來</h2><figure class=\"highlight elixir\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"variable\">$ </span>git pull</span><br></pre></td></tr></table></figure>\n\n\n<h2 id=\"Ref\"><a href=\"#Ref\" class=\"headerlink\" title=\"Ref\"></a>Ref</h2><ul>\n<li><a href=\"http://billy3321.blogspot.com/2009/02/github-howto.html\" target=\"_blank\" rel=\"noopener\">http://billy3321.blogspot.com/2009/02/github-howto.html</a></li>\n<li><a href=\"https://github.com/\" target=\"_blank\" rel=\"noopener\">Github</a></li>\n<li><a href=\"http://git-scm.com/\" target=\"_blank\" rel=\"noopener\">Git</a></li>\n<li><a href=\"http://git-scm.com/book/\" target=\"_blank\" rel=\"noopener\">Pro Git</a></li>\n</ul>\n","tags":["Linux","Tip","Git","Github"]},{"title":"Hello Octopress","url":"/hello-octopress/","content":"<p>不可免俗的，Octopress 第一篇文章是 say hello。</p>\n<p>在 Windows 上玩 Octopress + Github。</p>\n<h2 id=\"Prepare\"><a href=\"#Prepare\" class=\"headerlink\" title=\"Prepare\"></a>Prepare</h2><p>要先裝好 Git 跟 Ruby 環境。Git 是用 <a href=\"http://msysgit.github.io/\" target=\"_blank\" rel=\"noopener\">Git for Windows</a>，Ruby 環境則從從 <a href=\"http://rubyinstaller.org/downloads\" target=\"_blank\" rel=\"noopener\">http://rubyinstaller.org/downloads</a> 下載 RubyInstaller 1.9.3 跟 Development kit 來安裝。</p>\n<p>Development kit 下載後先解壓縮，用以下指令安裝：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> <span class=\"built_in\">cd</span> &lt;DEVKIT_INSTALL_DIR&gt;</span></span><br><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> ruby dk.rb init</span></span><br><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> ruby dk.rb install</span></span><br></pre></td></tr></table></figure>\n\n<p>安裝完 Ruby 要在環境變數 PATH 加入 Ruby 的 bin 資料夾路徑，如 <code>C:\\Ruby193\\bin</code>。</p>\n<h2 id=\"Install-Octopress\"><a href=\"#Install-Octopress\" class=\"headerlink\" title=\"Install Octopress\"></a>Install Octopress</h2><p>我直接用 Git Bash 下指令。</p>\n<figure class=\"highlight gams\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"symbol\">$</span> git clone git:<span class=\"comment\">//github.com/imathis/octopress.git octopress</span></span><br><span class=\"line\"><span class=\"symbol\">$</span> gem update --<span class=\"keyword\">system</span></span><br><span class=\"line\"><span class=\"symbol\">$</span> gem install bundler</span><br><span class=\"line\"><span class=\"symbol\">$</span> cd octopress</span><br><span class=\"line\"><span class=\"symbol\">$</span> bundle install</span><br><span class=\"line\"><span class=\"symbol\">$</span> rake install</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"Configuration\"><a href=\"#Configuration\" class=\"headerlink\" title=\"Configuration\"></a>Configuration</h3><p>編輯 <code>_config.yml</code> 可修改 blog 的主要設定。</p>\n<a id=\"more\"></a>\n\n<h2 id=\"Deploy-到-github\"><a href=\"#Deploy-到-github\" class=\"headerlink\" title=\"Deploy 到 github\"></a>Deploy 到 github</h2><p>先建名稱為 username.github.com 的 repos。blog 建出來會位於 <a href=\"http://username.github.io\" target=\"_blank\" rel=\"noopener\">http://username.github.io</a> 。</p>\n<figure class=\"highlight verilog\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ rake setup_github_pages</span><br><span class=\"line\">$ rake <span class=\"keyword\">generate</span></span><br><span class=\"line\">$ rake deploy</span><br></pre></td></tr></table></figure>\n\n<p>第一步需輸入 github repos 的位置，例如：<a href=\"mailto:git@github.com\">git@github.com</a>:cjwind/cjwind.github.com.git</p>\n<p>rake deploy 後會把產生出來的 blog push 到 master branch。</p>\n<p>在 git repos 中會有兩個 branch，分別放產生頁面的 master 跟 source file 的 source。</p>\n<h3 id=\"將-source-加入-repos\"><a href=\"#將-source-加入-repos\" class=\"headerlink\" title=\"將 source 加入 repos\"></a>將 source 加入 repos</h3><p>將 source files 也 push 到 github 上。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> git add .</span></span><br><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> git commit</span></span><br><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> git push origin <span class=\"built_in\">source</span></span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Write-Post\"><a href=\"#Write-Post\" class=\"headerlink\" title=\"Write Post\"></a>Write Post</h2><figure class=\"highlight haxe\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ rake <span class=\"keyword\">new</span><span class=\"type\">_post</span>[<span class=\"string\">\"title\"</span>]</span><br></pre></td></tr></table></figure>\n\n<p>用以上指令產生新文章後，到 source/_posts 下用文字編輯器編輯生出來的檔案。</p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">---</span></span><br><span class=\"line\"><span class=\"attr\">layout:</span> <span class=\"string\">post</span></span><br><span class=\"line\"><span class=\"attr\">title:</span> <span class=\"string\">\"Hello\"</span></span><br><span class=\"line\"><span class=\"attr\">date:</span> <span class=\"number\">2014</span><span class=\"number\">-03</span><span class=\"number\">-15</span> <span class=\"number\">23</span><span class=\"string\">:11:22</span> <span class=\"string\">+0800</span></span><br><span class=\"line\"><span class=\"attr\">comments:</span> <span class=\"literal\">true</span></span><br><span class=\"line\"><span class=\"attr\">tags:</span></span><br><span class=\"line\"><span class=\"meta\">---</span></span><br></pre></td></tr></table></figure>\n\n<p>分類的寫法有幾種。一個分類：<code>tags: programming</code>，或多個分類：<code>tags: [programming, tips]</code>。</p>\n<p>如果想當作草稿，可以加上 <code>published: false</code>。</p>\n<p>上面那段之後就是內文了。如果想加上「閱讀全文」，只要在文章中加入 <code>&lt;!--more--&gt;</code> 即可。</p>\n<p>寫好之後可以用 </p>\n<figure class=\"highlight elixir\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"variable\">$ </span>rake preview</span><br></pre></td></tr></table></figure>\n\n<p>產生預覽，到 <a href=\"http://127.0.0.1:4000\" target=\"_blank\" rel=\"noopener\">http://127.0.0.1:4000</a> 看結果。</p>\n<p>要發布的時候同樣先產生頁面再 deploy 到 github 上：</p>\n<figure class=\"highlight verilog\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ rake <span class=\"keyword\">generate</span></span><br><span class=\"line\">$ rake deploy</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"Remove-post\"><a href=\"#Remove-post\" class=\"headerlink\" title=\"Remove post\"></a>Remove post</h3><p>只要將 source/_posts/ 底下相對應的 .markdown 檔刪掉，之後 generate 時會刪掉對應的頁面。</p>\n<h3 id=\"貼-highlight-code\"><a href=\"#貼-highlight-code\" class=\"headerlink\" title=\"貼 highlight code\"></a>貼 highlight code</h3><p>安裝 <a href=\"https://www.python.org/\" target=\"_blank\" rel=\"noopener\">Python</a>，基於可能會有版本整合上的問題，還是先用 Python 2。裝完要在環境變數 PATH 加入 Python 的安裝路另，如 <code>C:\\Python27</code>。如果沒裝 Python 而且文章中有 highlight code 語法，<code>rake generate</code> 不會有 error 但會生出空白頁。</p>\n<p>inline 的語法：</p>\n<figure class=\"highlight arcade\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">` code snippet `</span></span><br></pre></td></tr></table></figure>\n\n<p>block 的語法：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;figure <span class=\"class\"><span class=\"keyword\">class</span></span>=<span class=\"string\">\"highlight plain\"</span>&gt;<span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">figcaption</span>&gt;</span><span class=\"tag\">&lt;<span class=\"name\">span</span>&gt;</span>[title] [url] [link text] [linenos:false] [start:#] [mark:#,#-#]<span class=\"tag\">&lt;/<span class=\"name\">span</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">figcaption</span>&gt;</span></span><span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">table</span>&gt;</span><span class=\"tag\">&lt;<span class=\"name\">tr</span>&gt;</span><span class=\"tag\">&lt;<span class=\"name\">td</span> <span class=\"attr\">class</span>=<span class=\"string\">\"code\"</span>&gt;</span><span class=\"tag\">&lt;<span class=\"name\">pre</span>&gt;</span><span class=\"tag\">&lt;<span class=\"name\">span</span> <span class=\"attr\">class</span>=<span class=\"string\">\"line\"</span>&gt;</span>code snippet<span class=\"tag\">&lt;/<span class=\"name\">span</span>&gt;</span><span class=\"tag\">&lt;<span class=\"name\">br</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">pre</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">td</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">tr</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">table</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">figure</span>&gt;</span></span></span><br></pre></td></tr></table></figure>\n\n<p>有寫 language 就會 highlight。<a href=\"http://pygments.org/docs/lexers/\" target=\"_blank\" rel=\"noopener\">support 的 language</a></p>\n<h2 id=\"Write-Page\"><a href=\"#Write-Page\" class=\"headerlink\" title=\"Write Page\"></a>Write Page</h2><figure class=\"highlight haxe\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ rake <span class=\"keyword\">new</span><span class=\"type\">_page</span>[<span class=\"string\">\"page_name\"</span>]</span><br></pre></td></tr></table></figure>\n\n<p>以上指令會產生 source/page_name/index.markdown，編輯完成、產生頁面後，可從 <baseURL>/page_name 看。</p>\n<h3 id=\"將-Page-列在導覽列上\"><a href=\"#將-Page-列在導覽列上\" class=\"headerlink\" title=\"將 Page 列在導覽列上\"></a>將 Page 列在導覽列上</h3><p>以 About page 為例，修改 source/_includes/custom/navigation.html，加入</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">li</span>&gt;</span><span class=\"tag\">&lt;<span class=\"name\">a</span> <span class=\"attr\">href</span>=<span class=\"string\">\"&#123;&#123; root_url &#125;&#125;/about\"</span>&gt;</span>About<span class=\"tag\">&lt;/<span class=\"name\">a</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"加上分類列表\"><a href=\"#加上分類列表\" class=\"headerlink\" title=\"加上分類列表\"></a>加上分類列表</h2><p>Download <a href=\"https://github.com/tokkonopapa/octopress-tagcloud\" target=\"_blank\" rel=\"noopener\">https://github.com/tokkonopapa/octopress-tagcloud</a>，這個 plugin 有分類列表跟標籤雲。</p>\n<p>將檔案解壓縮到 octopress 對應的資料夾。</p>\n<p>修改 <code>_config.yml</code></p>\n<figure class=\"highlight dts\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"symbol\">default_asides:</span> [custom<span class=\"meta-keyword\">/asides/</span>category_list.html, ...]</span><br></pre></td></tr></table></figure>\n\n<p>產生頁面</p>\n<figure class=\"highlight verilog\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ rake <span class=\"keyword\">generate</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Custom-Domain\"><a href=\"#Custom-Domain\" class=\"headerlink\" title=\"Custom Domain\"></a>Custom Domain</h2><p>在 source/ 底下新增檔案 CNAME，內容是自訂 domain，例如 <code>www.cjwind.idv.tw</code>。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> rake generate</span></span><br><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> rake deploy</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> git add .</span></span><br><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> git commit</span></span><br><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> git push origin <span class=\"built_in\">source</span></span></span><br></pre></td></tr></table></figure>\n\n<p>設定 DNS，新增一 CNAME record，將 <code>www.cjwind.idv.tw</code> 指向 <code>cjwind.github.io</code>。如果要用最上層的 domain name，參考 <a href=\"http://octopress.org/docs/deploying/github/\" target=\"_blank\" rel=\"noopener\">Octopress 官網說明</a>。</p>\n<h2 id=\"Troubleshooting\"><a href=\"#Troubleshooting\" class=\"headerlink\" title=\"Troubleshooting\"></a>Troubleshooting</h2><h3 id=\"code-highlight\"><a href=\"#code-highlight\" class=\"headerlink\" title=\"code highlight\"></a>code highlight</h3><p>有一次 <code>rake generate</code> 遇到 error：</p>\n<figure class=\"highlight vim\"><table><tr><td class=\"code\"><pre><span class=\"line\">pygments_code.r<span class=\"variable\">b:14</span>:in `<span class=\"keyword\">highlight</span><span class=\"string\">': undefined method `[]'</span> <span class=\"keyword\">for</span> ni<span class=\"variable\">l:NilClass</span> (NoMethodError)</span><br></pre></td></tr></table></figure>\n\n<p>原因不明，測試起來是某段 C code 造成的，可是看起來我寫的語法沒錯，google 之後砍掉 <code>.pygments-cache/</code> 再重新 generate 就好了。</p>\n<ul>\n<li><a href=\"https://github.com/imathis/octopress/issues/1427\" target=\"_blank\" rel=\"noopener\">https://github.com/imathis/octopress/issues/1427</a></li>\n</ul>\n<h2 id=\"Ref\"><a href=\"#Ref\" class=\"headerlink\" title=\"Ref\"></a>Ref</h2><ul>\n<li><a href=\"http://octopress.org/docs/configuring/\" target=\"_blank\" rel=\"noopener\">http://octopress.org/docs/configuring/</a></li>\n<li><a href=\"http://wwssllabcd.github.io/blog/2012/08/01/how-to-install-octopress-on-window/\" target=\"_blank\" rel=\"noopener\">http://wwssllabcd.github.io/blog/2012/08/01/how-to-install-octopress-on-window/</a></li>\n<li><a href=\"http://tonytonyjan.net/2012/03/01/install-octopress-on-windows/\" target=\"_blank\" rel=\"noopener\">http://tonytonyjan.net/2012/03/01/install-octopress-on-windows/</a></li>\n<li><a href=\"http://zerodie.github.io/blog/2012/01/19/octopress-github-pages/\" target=\"_blank\" rel=\"noopener\">http://zerodie.github.io/blog/2012/01/19/octopress-github-pages/</a></li>\n<li><a href=\"http://octopress.org/docs/blogging/code/\" target=\"_blank\" rel=\"noopener\">http://octopress.org/docs/blogging/code/</a></li>\n<li><a href=\"http://pages.tzengyuxio.me/pandoc/\" target=\"_blank\" rel=\"noopener\">Markdown 語法</a></li>\n<li><a href=\"http://robdodson.me/blog/2012/04/30/custom-domain-with-octopress-and-github-pages/\" target=\"_blank\" rel=\"noopener\">http://robdodson.me/blog/2012/04/30/custom-domain-with-octopress-and-github-pages/</a></li>\n</ul>\n","tags":["Blog","Octopress","Github"]},{"title":"Hello Hexo","url":"/hello-world/","content":"<p><del>簡單來說，我變心了。</del></p>\n<p>Octopress 隨著文章數越多 <code>rake generate</code> 似乎有越來越慢的趨勢，稍微查一下發現雖然有 <code>generate</code> 加速的方法，但遇到 <code>deploy</code> 還是會慢，索性跳到比較快的 Hexo。</p>\n<p>Hexo 也可以配合 Github page 使用。跟 Octopress 的不同的是 Hexo 把 post 跟 draft 分開，還不錯。</p>\n<p>從 Octopress 轉到 Hexo 不難，先安裝好 <a href=\"http://hexo.io/\" target=\"_blank\" rel=\"noopener\">Hexo</a>，再將原本 <code>_posts/</code> 底下的檔案搬過來便是。Hexo 不像 Octopress 將 source 開成另一個 branch 可以 push 到 repos 上，<del>為了備份跟遠端傳輸 source 檔，我把整個 Hexo 資料夾放在 Dropbox 上。</del>理論上電腦有裝 node.js 跟 Git 的環境就可以直接寫。</p>\n<p>偶爾改爛 theme，放在 Dropbox 上就不知道自己改了什麼、改不回去，試驗開另一個 repos 放 source。</p>\n<h2 id=\"新增頁面\"><a href=\"#新增頁面\" class=\"headerlink\" title=\"新增頁面\"></a>新增頁面</h2><figure class=\"highlight routeros\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ hexo new<span class=\"built_in\"> page </span>&lt;name&gt;</span><br></pre></td></tr></table></figure>\n\n<p>在導覽列加新的頁面要修改 <code>themes/&lt;theme name&gt;/_config.yml</code>，在 <code>menu</code> 底下加，例如：</p>\n<figure class=\"highlight dts\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"symbol\">menu:</span></span><br><span class=\"line\"><span class=\"symbol\">  Home:</span> /</span><br><span class=\"line\"><span class=\"symbol\">  Archives:</span> /archives</span><br><span class=\"line\"><span class=\"symbol\">  Toy:</span> /toy</span><br><span class=\"line\"><span class=\"symbol\">  About:</span> /about</span><br></pre></td></tr></table></figure>\n\n<p>這個設定因 theme 而異，以上設定是 default theme landscape 的。</p>\n<h2 id=\"Custom-Domain-Name\"><a href=\"#Custom-Domain-Name\" class=\"headerlink\" title=\"Custom Domain Name\"></a>Custom Domain Name</h2><p>在 <code>source/</code> 底下增加一檔案 <code>CNAME</code>，內容為自訂 domain name，如 <code>www.cjwind.idv.tw</code>。</p>\n<h2 id=\"Theme\"><a href=\"#Theme\" class=\"headerlink\" title=\"Theme\"></a>Theme</h2><p><del>改用 <a href=\"https://github.com/seff/nut\" target=\"_blank\" rel=\"noopener\">nut</a></del></p>\n<h2 id=\"修改-Deploy-git-repos\"><a href=\"#修改-Deploy-git-repos\" class=\"headerlink\" title=\"修改 Deploy git repos\"></a>修改 Deploy git repos</h2><p>除了修改 <code>_config.yml</code> 裡 <code>deploy</code> 下 <code>repo</code> 的設定外，也要刪除 <code>.deploy/</code>，才會套用新的 repos 設定。</p>\n<h2 id=\"Ref\"><a href=\"#Ref\" class=\"headerlink\" title=\"Ref\"></a>Ref</h2><ul>\n<li><a href=\"http://hexo.io/\" target=\"_blank\" rel=\"noopener\">http://hexo.io/</a></li>\n<li><a href=\"http://lostjs.com/2014/04/22/from-octopress-to-hexo/\" target=\"_blank\" rel=\"noopener\">http://lostjs.com/2014/04/22/from-octopress-to-hexo/</a></li>\n</ul>\n","tags":["Hexo","Blog"]},{"title":"libcurl - HTTP usage","url":"/libcurl/","content":"<p>libcurl 是處理收送網路 request、response 的 library，可用來收送 HTTP 的 request 及 response。</p>\n<p>libcurl 收到 response 時會 call callback function，由 callback function 處理收到的資料。callback function 可自行撰寫，其 prototype 如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">size_t</span> <span class=\"title\">func</span><span class=\"params\">(<span class=\"keyword\">void</span> *ptr, <span class=\"keyword\">size_t</span> <span class=\"built_in\">size</span>, <span class=\"keyword\">size_t</span> nmemb, <span class=\"keyword\">void</span> *userdata)</span></span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>ptr 指向收到的資料</li>\n<li>nmemb 為收到資料的大小</li>\n<li>userdata 可自己定義，我拿它當 return value。</li>\n</ul>\n<p>libcurl 的 callback function 分成處理 header 跟 data，用 <code>curl_easy_setopt()</code> 指定處理的 callback function。如果沒有指定 callback function，預設上 data 會被印出來，header 則不處理。</p>\n<h2 id=\"Usage\"><a href=\"#Usage\" class=\"headerlink\" title=\"Usage\"></a>Usage</h2><p>1. Initialize</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;curl/curl.h&gt;</span></span></span><br><span class=\"line\">        </span><br><span class=\"line\">CURL* curl = curl_easy_init();</span><br></pre></td></tr></table></figure>\n\n<p>2.  Set HTTP header data</p>\n<p>設 HTTP header，如指定 Content-type：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">curl_slist</span>* <span class=\"title\">headers</span>;</span></span><br><span class=\"line\"><span class=\"built_in\">memset</span>(header, <span class=\"number\">0</span>, <span class=\"keyword\">sizeof</span>(headers));</span><br><span class=\"line\">headers = curl_slist_append(headers, <span class=\"string\">\"Content-type: application/json\"</span>);</span><br></pre></td></tr></table></figure>\n\n<p>call <code>curl_slist_append()</code> 會不斷加資訊到 headers 這個資料結構中。</p>\n<p>3. Set options</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\">curl_easy_setopt(curl, CURLOPT_POST, <span class=\"number\">1</span>);                <span class=\"comment\">// 以 POST 傳送資料</span></span><br><span class=\"line\">curl_easy_setopt(curl, CURLOPT_HTTPHEADER, headers);    <span class=\"comment\">// 指定 header</span></span><br><span class=\"line\">curl_easy_setopt(curl, CURLOPT_URL, url.c_str());       <span class=\"comment\">// 指定 url</span></span><br><span class=\"line\">curl_easy_setopt(curl, CURLOPT_POSTFIELDS, postdata);   <span class=\"comment\">// 指定 data，將 postdata 當作 POST data 傳給 server</span></span><br><span class=\"line\"></span><br><span class=\"line\">curl_easy_setopt(curl, CURLOPT_HEADERFUNCTION, parseHeader);    <span class=\"comment\">// 指定處理 HTTP header 的 callback function 為 parseHeader</span></span><br><span class=\"line\">curl_easy_setopt(curl, CURLOPT_WRITEHEADER, &amp;rescode);          <span class=\"comment\">// 指定 parseHeader 的 userdata</span></span><br><span class=\"line\"></span><br><span class=\"line\">curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, getResponse);     <span class=\"comment\">// 指定處理 data 的 callback function 為 getResponse</span></span><br><span class=\"line\">curl_easy_setopt(curl, CURLOPT_WRITEDATA, &amp;response);           <span class=\"comment\">// 指定 getResponse 的 userdata</span></span><br></pre></td></tr></table></figure>\n\n<p>4. 傳送 request</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\">curl_easy_perform(curl);</span><br></pre></td></tr></table></figure>\n\n<p>以 blocking 的方式傳送 request。</p>\n<p>5. clean up</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\">curl_slist_free_all(headers);\t<span class=\"comment\">// 清掉 headers 裡的東西</span></span><br><span class=\"line\">curl_easy_cleanup(curl);</span><br></pre></td></tr></table></figure>\n\n<a id=\"more\"></a>\n\n<h2 id=\"callback-function\"><a href=\"#callback-function\" class=\"headerlink\" title=\"callback function\"></a>callback function</h2><figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">size_t</span> <span class=\"title\">parseHeader</span><span class=\"params\">(<span class=\"keyword\">void</span> *ptr, <span class=\"keyword\">size_t</span> <span class=\"built_in\">size</span>, <span class=\"keyword\">size_t</span> nmemb, <span class=\"built_in\">string</span> *userdata)</span></span></span><br></pre></td></tr></table></figure>\n\n<p>指定以 <code>parseHeader()</code> 處理 header：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\">curl_easy_setopt(curl, CURLOPT_HEADERFUNCTION, parseHeader);</span><br><span class=\"line\">curl_easy_setopt(curl, CURLOPT_WRITEHEADER, &amp;data);\t    <span class=\"comment\">// 指定 data 的 address 給 parseHeader() 的 userdata</span></span><br></pre></td></tr></table></figure>\n\n<p>userdata 是 void*，可以使用任何 type 或 structure 的 pointer。</p>\n<p>處理 data 的 option 是 <code>CURLOPT_WRITEFUNCTION</code> 跟 <code>CURLOPT_WRITEDATA</code>。</p>\n<h2 id=\"傳送-POST-資料\"><a href=\"#傳送-POST-資料\" class=\"headerlink\" title=\"傳送 POST 資料\"></a>傳送 POST 資料</h2><figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">char</span> postdata[] = <span class=\"string\">\"&#123;\\\"reboot\\\": &#123;\\\"type\\\" : \\\"SOFT\\\"&#125;&#125;\"</span>;</span><br><span class=\"line\">curl_easy_setopt(curl, CURLOPT_POST, <span class=\"number\">1</span>);</span><br><span class=\"line\">curl_easy_setopt(curl, CURLOPT_POSTFIELDS, postdata);</span><br></pre></td></tr></table></figure>\n\n<p>在 postdata 放要傳的資料，用 set option 指定。<em>不太確定 postdata 的 type 是不是一定要用 char？</em></p>\n<h2 id=\"Link-option\"><a href=\"#Link-option\" class=\"headerlink\" title=\"Link option\"></a>Link option</h2><p>用 <code>curl-config --libs</code> 指令找到需要的 link option。</p>\n<h2 id=\"Example\"><a href=\"#Example\" class=\"headerlink\" title=\"Example\"></a>Example</h2><p>要求 Openstack reboot 某台 VM：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">reboot</span><span class=\"params\">(<span class=\"built_in\">string</span> token, <span class=\"keyword\">int</span> vmid)</span> </span>&#123;</span><br><span class=\"line\">    CURL *curl;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">curl_slist</span> *<span class=\"title\">headers</span> = <span class=\"title\">NULL</span>;</span></span><br><span class=\"line\">    <span class=\"built_in\">string</span> url = <span class=\"built_in\">string</span>(APIURL) + <span class=\"string\">\"/servers/\"</span> + int2string(vmid) + <span class=\"string\">\"/action\"</span>;</span><br><span class=\"line\">    <span class=\"keyword\">char</span> postdata[] = <span class=\"string\">\"&#123;\\\"reboot\\\": &#123;\\\"type\\\" : \\\"SOFT\\\"&#125;&#125;\"</span>;</span><br><span class=\"line\">    <span class=\"built_in\">string</span> rescode;</span><br><span class=\"line\"></span><br><span class=\"line\">    curl = curl_easy_init();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> ( curl ) &#123;</span><br><span class=\"line\">        headers = curl_slist_append(headers, <span class=\"built_in\">string</span>(<span class=\"string\">\"X-Auth-Token: \"</span> + token).c_str());</span><br><span class=\"line\">        headers = curl_slist_append(headers, <span class=\"string\">\"Content-type: application/json\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        curl_easy_setopt(curl, CURLOPT_POST, <span class=\"number\">1</span>);</span><br><span class=\"line\">        curl_easy_setopt(curl, CURLOPT_HTTPHEADER, headers);</span><br><span class=\"line\">        curl_easy_setopt(curl, CURLOPT_URL, url.c_str());</span><br><span class=\"line\">        curl_easy_setopt(curl, CURLOPT_POSTFIELDS, postdata);   <span class=\"comment\">// put POST data here</span></span><br><span class=\"line\">        curl_easy_setopt(curl, CURLOPT_HEADERFUNCTION, parseHeader);</span><br><span class=\"line\">        curl_easy_setopt(curl, CURLOPT_WRITEHEADER, &amp;rescode);  <span class=\"comment\">// set userdata in callback function</span></span><br><span class=\"line\"></span><br><span class=\"line\">        curl_easy_perform(curl);</span><br><span class=\"line\"></span><br><span class=\"line\">        curl_slist_free_all(headers);</span><br><span class=\"line\">        curl_easy_cleanup(curl);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> ( rescode == <span class=\"string\">\"202\"</span> ) <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">cerr</span> &lt;&lt; <span class=\"string\">\"reboot failed, response code is \"</span> &lt;&lt; rescode &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// parse http header</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">size_t</span> <span class=\"title\">parseHeader</span><span class=\"params\">(<span class=\"keyword\">void</span> *ptr, <span class=\"keyword\">size_t</span> size, <span class=\"keyword\">size_t</span> nmemb, <span class=\"built_in\">string</span> *userdata)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> ( <span class=\"built_in\">strncmp</span>((<span class=\"keyword\">char</span> *)ptr, <span class=\"string\">\"X-Auth-Token:\"</span>, <span class=\"number\">13</span>) == <span class=\"number\">0</span> ) &#123; <span class=\"comment\">// get Token</span></span><br><span class=\"line\">        strtok((<span class=\"keyword\">char</span> *)ptr, <span class=\"string\">\" \"</span>);</span><br><span class=\"line\">        *userdata = <span class=\"built_in\">string</span>(strtok(<span class=\"literal\">NULL</span>, <span class=\"string\">\" \\n\"</span>));        <span class=\"comment\">// token will be stored in userdata</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> ( <span class=\"built_in\">strncmp</span>((<span class=\"keyword\">char</span> *)ptr, <span class=\"string\">\"HTTP/1.1\"</span>, <span class=\"number\">8</span>) == <span class=\"number\">0</span> ) &#123;  <span class=\"comment\">// get http response code</span></span><br><span class=\"line\">        strtok((<span class=\"keyword\">char</span> *)ptr, <span class=\"string\">\" \"</span>);</span><br><span class=\"line\">        *userdata = <span class=\"built_in\">string</span>(strtok(<span class=\"literal\">NULL</span>, <span class=\"string\">\" \\n\"</span>));        <span class=\"comment\">// http response code</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> nmemb;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n<h2 id=\"Ref\"><a href=\"#Ref\" class=\"headerlink\" title=\"Ref\"></a>Ref</h2><ul>\n<li><a href=\"http://curl.haxx.se/libcurl/\" target=\"_blank\" rel=\"noopener\">http://curl.haxx.se/libcurl/</a></li>\n<li><a href=\"http://curl.haxx.se/libcurl/c/curl_easy_setopt.html\" target=\"_blank\" rel=\"noopener\">http://curl.haxx.se/libcurl/c/curl_easy_setopt.html</a></li>\n</ul>\n","tags":["Programming","Third Party"]},{"title":"Linux Process Exit Status","url":"/linux-process-exit-status/","content":"<h2 id=\"Process-Termination\"><a href=\"#Process-Termination\" class=\"headerlink\" title=\"Process Termination\"></a>Process Termination</h2><p>Linux 中 process 結束時系統會回收該 process 使用的大部分 resource，僅留下結束資訊供它的 parent 取得。parent 回收 child process、取得這些資訊後，剩餘的 resource 才會被釋放。如果 parent 沒有回收結束的 child process，child 會變殭屍（zombie），即執行結束了但沒有把 resource 釋放乾淨，會佔用 PID 及一些記憶體空間放 exit status。</p>\n<p>parent process 透過 call <code>wait()</code> 回收 child process 並取得 child process 的 exit status。</p>\n<p>process 結束分成正常結束（terminate normally）跟不正常結束（terminate abnormally or crash）。</p>\n<p>以系統的角度來看，process call <code>exit()</code> 或從 <code>main()</code> return 算 terminate normally。（實際上從 <code>main()</code> return 後就會 call <code>exit()</code> 系列 function。）process crash、被 signal 結束或其他狀況算 terminate abnormally。</p>\n<p>以程式或 programmer 的角度來看，<code>exit()</code> 的參數為非 0 通常代表有些檢查沒有通過，程式無法繼續完成工作才會在中間 call <code>exit()</code>。這個狀況是<strong>「程式正常結束，但沒有完成該有的運作」</strong>，屬於程式執行邏輯上的錯誤，跟 crash 不同。</p>\n<h2 id=\"Process-Exit-Status\"><a href=\"#Process-Exit-Status\" class=\"headerlink\" title=\"Process Exit Status\"></a>Process Exit Status</h2><p>Linux 中以 exit status code 表示 process 結束時的狀態（它怎麼結束的）。</p>\n<h3 id=\"System\"><a href=\"#System\" class=\"headerlink\" title=\"System\"></a>System</h3><p>系統 exit status code 的範圍為 0 至 255。若程式設置超過 255 的 code，會以 mod 256 作為 exit code。</p>\n<p>有些 code 已保留給系統使用、有固定意義。一般不建議 programmer 再對這些 code 定義其他意義。系統已保留的 exit code 為：0、1、2、126 ~ 165、255。</p>\n<h3 id=\"C-C-program\"><a href=\"#C-C-program\" class=\"headerlink\" title=\"C/C++ program\"></a>C/C++ program</h3><p>在 C/C++ program 中 <code>exit()</code> 的參數值是在 process <strong>正常結束</strong>下，讓 programmer 得知「程式階層上」的 exit status，跟系統所使用的 exit status code <strong>相關但不相等</strong>。</p>\n<a id=\"more\"></a>\n\n<h2 id=\"Parent-取得-child-exit-status\"><a href=\"#Parent-取得-child-exit-status\" class=\"headerlink\" title=\"Parent 取得 child exit status\"></a>Parent 取得 child exit status</h2><p>parent process call <code>wait()</code> 可取得 child process 的 exit status：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> status = <span class=\"number\">-1</span>;</span><br><span class=\"line\">wait(&amp;status);</span><br></pre></td></tr></table></figure>\n\n\n<h3 id=\"Parent-判斷-child-的結束狀態\"><a href=\"#Parent-判斷-child-的結束狀態\" class=\"headerlink\" title=\"Parent 判斷 child 的結束狀態\"></a>Parent 判斷 child 的結束狀態</h3><p>parent 由 <code>wait()</code> 取得 的 status 值可用一些 macro 判斷意義。先以 <code>WIFEXITED()</code> 判斷 child 是否 terminate normally，再以其他 macro 取得更細部的資訊。</p>\n<ul>\n<li><p><code>WIFEXITED()</code> return true</p>\n<p>對系統來說 child process 是正常結束。另假設 child process 是 call <code>exit(N)</code> 結束的。</p>\n</li>\n<li><p><code>WEXITSTATUS()</code> 會 return N</p>\n<ul>\n<li><p>N == 0</p>\n<p>以程式、programmer 觀點會認為 child process 正確完成工作。</p>\n</li>\n<li><p>N != 0</p>\n<p>以程式、programmer 觀點會認為程式並未正確完成工作，可能中間檢查到問題造成程式無法完成工作（例如未設環境變數），以 <code>exit()</code> 的方式處理此錯誤、方便 debug。</p>\n<p>N 值的意義由 programmer 定義。</p>\n</li>\n</ul>\n</li>\n<li><p><code>WIFEXITED()</code> return false</p>\n<p>對系統來說 child process 不正常結束，可用一些 macro 再做檢查：</p>\n<ul>\n<li><p><code>WCOREDUMP()</code>：child 是否產生 core dump</p>\n</li>\n<li><p><code>WIFSIGNALED()</code>：child 是否因 signal 結束</p>\n</li>\n</ul>\n</li>\n</ul>\n<p>其他 macro 可參考 <code>wait()</code> man page。</p>\n<h2 id=\"Ref\"><a href=\"#Ref\" class=\"headerlink\" title=\"Ref\"></a>Ref</h2><ul>\n<li><a href=\"http://tldp.org/LDP/abs/html/exitcodes.html\" target=\"_blank\" rel=\"noopener\">http://tldp.org/LDP/abs/html/exitcodes.html</a></li>\n</ul>\n","tags":["Linux"]},{"title":"Liskov Substitution Principle (LSP)","url":"/liskov-substitution-principle/","content":"<p>這個原則跟何時該使用繼承有關：derived class 必須能替代 base class。</p>\n<p>使用繼承時必須確保 base class 的所有特性及 method 對 derived class 仍成立，反過來說，derived class 必須有 base class 所有特性。一個 derived class 的 object 是一個（is-a）base class 的 object，原本對 base class 的 object 所做的所有操作可以直接換成對 derived class 的 object 操作。</p>\n<p>C++ 的 public 繼承在意義上即是 LSP 所說的繼承觀念。</p>\n<h2 id=\"繼承的替代方案\"><a href=\"#繼承的替代方案\" class=\"headerlink\" title=\"繼承的替代方案\"></a>繼承的替代方案</h2><p>使用繼承一般是希望擴充原有 class，但如果套用繼承時發現會違反 LSP，有什麼替代方案呢？</p>\n<ul>\n<li><a href=\"/delegate\">Delegate</a><br>將達成某功能的任務委託給原本想擴充的 class，也就是<del>不負責任的</del>丟給別人做。</li>\n<li><a href=\"relationships-between-classes\">Composition</a></li>\n<li><a href=\"relationships-between-classes\">Aggregation</a></li>\n</ul>\n","tags":["OOAD"]},{"title":"搬筆記到 Octopress","url":"/move-posts/","content":"<p>用想放空的假期把寫在 Dokuwiki 上的筆記搬到 Octopress 來。原本因為可以自己任意編排，加上寫給自己看的筆記是用 Dokuwiki，就繼續沿用 Dokuwiki。漸漸發現要找資料的時候都直接用搜尋功能，沒怎麼在用原本的分類頁。越來越覺得那樣編排可能沒有必要，似乎有搜尋跟標籤就可以了。</p>\n<p>好一陣子前 survey 過 Octopress，當時好像因為不習慣網頁上沒有管理的功能，暫且不用。可能最近有點轉性，覺得網頁上沒管理功能好像也還好。本來就喜歡用 Notepad++ 寫東西，配合 Git Bash 讓我覺得在 Windows 上用 command line 沒那麼卡，再加上有 Github 可以放，乾脆搬來了。</p>\n<p>目前讓我比較困擾的是這 blog 的 repos 只有在我的桌機上，所以只能從桌機寫，之後要看怎麼在另一台電腦上建立同樣的環境。這是網頁不直接提供管理功能的缺點，可是我在用的電腦就那幾台，也不太可能用手機寫這類的文章，只要幾個環境架起來之後應該還好。</p>\n<p>這 blog 主要拿來放 Computer Science 的筆記，之後慢慢寫些小程式應該也會把相關的東西放上來吧。</p>\n<p><em>一邊搬筆記一邊稍微看一下，真心覺得我有些用句很怪，看起來有點像英文文法的中文。XD</em></p>\n","tags":["Blog"]},{"title":"關於理論、軟體結構之類的事","url":"/murmur-about-structure/","content":"<p>最近的感想。</p>\n<p>念書的時候常覺得書上的理論跟實際上的使用或實作有一段距離，我說不上來那是落差還是什麼，但就是有點搭得起來又哪裡怪怪的。後來工作後我有點疑問──在學校念的那些理論，真的有用嗎？如果業界是以實務為主，為什麼我們需要學那些理論？<del>從這個問題就看得出來我當學生的時候很少好好理解過為啥自己要念那些書…</del></p>\n<p>我最近得到的答案是──理論會提供我們背景知識與架構，可以讓我們能較快速的理解系統跟軟體的運作方式，而不至於迷失在茫茫程式碼海中，要從許多的片段中慢慢拼湊才能知道整個系統的樣貌。當然，理論提供的是偏向概念上的了解，它不會有太細部的東西，實務上的細節是會隨著情境不同而調整的。</p>\n<p>軟體的結構也一樣。最近工作上，我發現因為對整個軟體的架構比較熟悉了，所以能比較快猜測、反應出可能是哪邊有問題，不像之前一遇到問題就得重新 trace，也似乎比較看得出來改動哪個部分會影響到那些東西。開始稍微能體會軟體有其架構的重要性，當它有個結構、有些規則可循，programmer 比較能知道改動的影響範圍，出問題時也能比較快找到。我們可以不用去記憶一些特例跟「這邊改了那邊還有那那邊也需要改」的事情，這也會減少出錯的可能。<del>對我這種不喜歡記那麼多細節還會搞混的人來說這真是太棒了！</del></p>\n<p>最近在看《深入淺出設計模式》，我想 design pattern 也是一種軟體上的結構，如果知道某個部分是使用某個 pattern，就能馬上了解其大致的運作。不過我不了解 pattern 的時候，看那些 code 只有一個感想──幹嘛把事情搞得那麼複雜？</p>\n<p>可惜的是，我現在仍然不覺得「軟體有其架構帶來的效益」這件事能有精確量化的指標。因為沒有對照組，沒有一套沒有架構的同樣軟體去比較有架構與沒有架構的差別，可能只能用間接的方式去量度關於軟體有架構的益處。</p>\n","tags":["Murmur"]},{"title":"MySQL++","url":"/mysql-plus-plus/","content":"<p>供 C++ 使用的 MySQL library。</p>\n<h2 id=\"Installation\"><a href=\"#Installation\" class=\"headerlink\" title=\"Installation\"></a>Installation</h2><p>in Fedora</p>\n<figure class=\"highlight brainfuck\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">$</span> <span class=\"comment\">sudo</span> <span class=\"comment\">yum</span> <span class=\"comment\">install</span> <span class=\"comment\">mysql</span> <span class=\"comment\">mysql</span><span class=\"literal\">-</span><span class=\"comment\">devel</span> <span class=\"comment\">mysql</span>++<span class=\"literal\">-</span><span class=\"comment\">devel</span></span><br></pre></td></tr></table></figure>\n\n<p>in Ubuntu</p>\n<figure class=\"highlight q\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ sudo apt-<span class=\"built_in\">get</span> install libmysql++-<span class=\"built_in\">dev</span></span><br></pre></td></tr></table></figure>\n\n\n<h2 id=\"How-to-use\"><a href=\"#How-to-use\" class=\"headerlink\" title=\"How to use\"></a>How to use</h2><p>include file and namespace</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;mysql++.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> mysqlpp;</span><br></pre></td></tr></table></figure>\n\n<p>compile</p>\n<figure class=\"highlight gradle\"><table><tr><td class=\"code\"><pre><span class=\"line\">g++ -o &lt;obj <span class=\"keyword\">file</span>&gt; &lt;<span class=\"keyword\">source</span> <span class=\"keyword\">file</span>&gt; -I<span class=\"regexp\">/usr/i</span>nclude<span class=\"regexp\">/mysql++ -I/u</span>sr<span class=\"regexp\">/include/my</span>sql -lmysqlpp -lmysqlclient</span><br></pre></td></tr></table></figure>\n\n<a id=\"more\"></a>\n\n<h2 id=\"Exception\"><a href=\"#Exception\" class=\"headerlink\" title=\"Exception\"></a>Exception</h2><p>出錯時會噴 exception，如果不 catch exception，process 會被 abort。用 catch 處理各種 error 比較好。</p>\n<h3 id=\"BadQuery-Exception\"><a href=\"#BadQuery-Exception\" class=\"headerlink\" title=\"BadQuery Exception\"></a>BadQuery Exception</h3><p>query 出錯時可以用 catch BadQuery exception 的方式取得 error 資訊。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">    query.exec();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">catch</span> ( BadQuery e ) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">cerr</span> &lt;&lt; e.errnum() &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">    <span class=\"built_in\">cerr</span> &lt;&lt; e.what() &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n<h3 id=\"BadFieldName-Exception\"><a href=\"#BadFieldName-Exception\" class=\"headerlink\" title=\"BadFieldName Exception\"></a>BadFieldName Exception</h3><p>access Row 不存在欄位會噴的 excpetion，例如：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\">sql = <span class=\"string\">\"SELECT name FROM test\"</span>;</span><br><span class=\"line\">db.execSql(sql, result);</span><br><span class=\"line\">  </span><br><span class=\"line\">Row row = result[<span class=\"number\">0</span>];</span><br><span class=\"line\"><span class=\"built_in\">cout</span> &lt;&lt; <span class=\"built_in\">string</span>(row[<span class=\"string\">\"name\"</span>]) &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\"><span class=\"built_in\">cout</span> &lt;&lt; <span class=\"built_in\">string</span>(row[<span class=\"string\">\"id\"</span>]) &lt;&lt; <span class=\"built_in\">endl</span>;    <span class=\"comment\">// 這裡會噴 BadFieldName</span></span><br></pre></td></tr></table></figure>\n\n\n<h2 id=\"Sample-Code\"><a href=\"#Sample-Code\" class=\"headerlink\" title=\"Sample Code\"></a>Sample Code</h2><p>使用 Connection 物件建立 DB 連線，用 Query 物件設定執行 SQL query，可用 StoreQueryResult 物件取得 query 的結果，在運用 Row 物件取得每一筆資料。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">foo</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    Connection *conn = <span class=\"keyword\">new</span> Connection();</span><br><span class=\"line\">    Query query;</span><br><span class=\"line\">    StoreQueryResult result;</span><br><span class=\"line\">    Row row;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">if</span> ( !conn-&gt;<span class=\"built_in\">connect</span>(<span class=\"string\">\"dbname\"</span>, <span class=\"string\">\"127.0.0.1\"</span>, <span class=\"string\">\"user\"</span>, <span class=\"string\">\"pwd\"</span>) ) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">cerr</span> &lt;&lt; <span class=\"string\">\"Error: Fail to connect to DB.\"</span> &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    query = conn-&gt;query();</span><br><span class=\"line\">    query &lt;&lt; <span class=\"string\">\"SELECT * FROM `testtable`\"</span>;</span><br><span class=\"line\">    result = query.store();</span><br><span class=\"line\">    row = result[<span class=\"number\">0</span>];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><em>至於 Query 的 exec() 跟 store() 有什麼差，還要再研究…</em></p>\n<h2 id=\"Ref\"><a href=\"#Ref\" class=\"headerlink\" title=\"Ref\"></a>Ref</h2><ul>\n<li><a href=\"http://tangentsoft.net/mysql++/\" target=\"_blank\" rel=\"noopener\">http://tangentsoft.net/mysql++/</a></li>\n</ul>\n","tags":["C++","MySQL"]},{"title":"Performance of Concurrency","url":"/performance-of-concurrency/","content":"<p>用 concurrency 就是為了更快，為了比 sequential 程式快，不然搞得那麼複雜幹嘛呢。</p>\n<p>如何評估 concurrent 程式的效能提升？</p>\n<p><code>speedup = sequential 程式執行時間 / concurrent 程式執行時間</code></p>\n<p>speedup 可能隨著使用的 core 數改變，標示程式在不同 core 數上的 speedup，可以由不同 core 數的 speedup 變化知道程式的 scalability。speedup 的提升隨著使用 core 數增加而增加甚至比例接近 core 增加的數量，表示有好的 scalability。理想狀況是 core 數加倍 speedup 也加倍。</p>\n<p>有時會發生 speedup 的提升超過 core 的增加數量，稱為 superlinear speedup。這通常是有問題，要再確認 concurrent 程式執行結果是否正確、是否使用一般情境下的 dataset 而非只是測試資料。superlinear speedup 常見的原因是資料量太小，sequential 程式因為不斷需要新資料而被清掉的 cache 反而在 concurrent 程式中因為各 core 處理的資料量太小而 cache 住，自然 concurrent 程式在資料讀取上會比較快，造成效能變超好的錯覺。<em>（假的！）</em></p>\n<p>如果已有 sequential 程式、要決定是否 concurrent 化，能事先估算效能提升比較好，畢竟 concurrent 程式複雜也需要投入成本開發，如果效能提升不好就白費工夫了。</p>\n<p>接下來兩個定理皆假設一個 core 上只執行一個 thread，如果一個 core 上執行多個 thread，就要把下面公式中的 core 數換成 thread 的數量。</p>\n<a id=\"more\"></a>\n\n<h2 id=\"Amdahl’s-law\"><a href=\"#Amdahl’s-law\" class=\"headerlink\" title=\"Amdahl’s law\"></a>Amdahl’s law</h2><p>在 dataset 大小是固定的情況下（dataset 不會隨著可用 core 數變多而跟著變多），可以用 Amdahl’s law 估算 speedup 的理論值。</p>\n<p>使用 Amdahl’s law 要知道程式的執行時間有多少比例能平行化、又有多少比例只能以 sequential 執行，用估算值即可，當然也可以用 profiler 看程式的實際執行時間。Amdahl’s law 的 speedup 如下：</p>\n<p><code>speedup &lt;= 1 / ((1 - p) + (p / c))</code></p>\n<ul>\n<li><code>p</code> 是程式執行時間中可平行化的比例</li>\n<li><code>c</code> 是使用的 core 數</li>\n</ul>\n<p>舉個例子，假設一個 sequential 程式執行需要 10 分鐘，其中 2 分鐘的工作無法平行化、8 分鐘的工作可以平行化，那麼在 4 core 的環境下 speedup 是：</p>\n<p><code>speedup &lt;= 1 / ((1 - 0.8) + (0.8 / 4)) = 2.5</code></p>\n<p>假設有無限多 core 可以使用，speedup 會趨近於 <code>1 / (1 - p)</code>，也就是跟無法平行化的執行時間成反比。蠻符合直覺的，因為一個程式平行化到極限，它的執行時間就是不能平行化的部份的執行時間（像例子的 2 分鐘）。</p>\n<h2 id=\"Gustafson’s-law\"><a href=\"#Gustafson’s-law\" class=\"headerlink\" title=\"Gustafson’s law\"></a>Gustafson’s law</h2><p>Amdahl’s law 有個問題在它的前提：dataset 大小固定。這表示無論程式可使用的 core 如何變多，給程式跑的 dataset 都不變。問題是實際上隨著機器能力的增強（core 數變多），要處理的資料量也會變多（看看十幾年前 1MB 就很大了，現在隨便都是 TB 在喊的），在 dataset 會隨著 core 數變多的情況下就不能用 Amdahl’s law 啦。</p>\n<p>於是有了 Gustafson’s law，也稱為 scaled speedup，考慮 dataset 隨著 core 數變多而等比例增加的情況下計算 speedup 的理論上限：</p>\n<p><code>scaled speedup &lt;= c + (1 - c) * s</code></p>\n<ul>\n<li><code>c</code> 是使用的 core 數</li>\n<li><code>s</code> 是在給定 dataset 以及使用 core 數的情況下，程式花多少時間在 sequential 執行上的比例</li>\n</ul>\n<p>舉例，假設有個平行化程式在 32 core 上執行花了 1000 秒，其中 30 秒花在 sequential 執行上（在一個 core 上 sequential 執行），那麼這個程式比起相同 dataset 只用一個 thread 執行（dataset 大能不能 single thread 跑是另一回事）的 speedup 是：</p>\n<p><code>scaled speedup &lt;= 32 + (1 - 32) * (30/1000) = 31.07</code></p>\n<p>注意這邊的 <code>s</code> 不能當作 Amdahl’s law 的 <code>1 - p</code>，因為這裡的 <code>s</code> 是在某特定 core 數下的執行時間比例，而非 sequential 程式中預估可平行化部份的執行時間。</p>\n<p>Gustafson’s law 跟處理龐大資料有關。資料量變大不見得得 sequential 處理的資料就變多，如果是可平行處理的資料變多，那麼反而 sequential 執行所佔的整體比例會下降（Amdahl’s law 沒有這一點是因為 dataset 固定），於是在資料逐漸龐大的情況下，sequential 部份的影響可能減小。</p>\n<h2 id=\"Efficiency（效率）\"><a href=\"#Efficiency（效率）\" class=\"headerlink\" title=\"Efficiency（效率）\"></a>Efficiency（效率）</h2><p>跟 speedup 有關的是 efficiency，efficiency 反映的是系統運算資源的使用狀況，看看 concurrent 程式對系統資源的使用效率如何。</p>\n<p><code>efficiency = 實際觀察到的 speedup / 使用的 core 數</code></p>\n<p>efficiency 通常以百分比表示，愈高表示愈沒有資源是閒置的。</p>\n<h2 id=\"Ref\"><a href=\"#Ref\" class=\"headerlink\" title=\"Ref\"></a>Ref</h2><ul>\n<li><a href=\"https://en.wikipedia.org/wiki/Amdahl%27s_law\" target=\"_blank\" rel=\"noopener\">Wiki Amdahl’s law</a></li>\n<li><a href=\"http://en.wikipedia.org/wiki/Gustafson%27s_law\" target=\"_blank\" rel=\"noopener\">Wiki Gustafson’s law</a></li>\n<li><a href=\"http://www.ithome.com.tw/voice/106886\" target=\"_blank\" rel=\"noopener\">關注平行程式設計</a></li>\n</ul>\n","tags":["Concurrency"]},{"title":"PHPExcel","url":"/phpexcel/","content":"<p>官方網站：<a href=\"http://phpexcel.codeplex.com/\" target=\"_blank\" rel=\"noopener\">http://phpexcel.codeplex.com/</a></p>\n<p>用來讀取、產生 Excel 的 PHP class。</p>\n<p>下載回來後解壓縮 Classes，在要使用的 PHP 檔案中 include。</p>\n<h2 id=\"產生-Excel\"><a href=\"#產生-Excel\" class=\"headerlink\" title=\"產生 Excel\"></a>產生 Excel</h2><figure class=\"highlight php\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// include PHPExcel 相關檔案</span></span><br><span class=\"line\"><span class=\"keyword\">include</span>(<span class=\"string\">\"includes/PHPExcel.php\"</span>);</span><br><span class=\"line\"><span class=\"keyword\">include</span>(<span class=\"string\">\"includes/PHPExcel/Writer/Excel2007.php\"</span>);    <span class=\"comment\">// Excel 2007 格式</span></span><br><span class=\"line\"><span class=\"keyword\">include</span>(<span class=\"string\">\"includes/PHPExcel/IOFactory.php\"</span>);           <span class=\"comment\">// 放置圖片</span></span><br><span class=\"line\"></span><br><span class=\"line\">error_reporting(E_ALL);</span><br><span class=\"line\"></span><br><span class=\"line\">$objPHPExcel = <span class=\"keyword\">new</span> PHPExcel(); </span><br><span class=\"line\">$objPHPExcel-&gt;setActiveSheetIndex(<span class=\"number\">0</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 指定儲存格的內容，中文要用 iconv() 轉換，不然會顯示不出來</span></span><br><span class=\"line\">$objPHPExcel-&gt;getActiveSheet()-&gt;setCellValue(<span class=\"string\">'A1'</span>, iconv(<span class=\"string\">\"big5\"</span>, <span class=\"string\">\"utf-8\"</span>, <span class=\"string\">\"測試\"</span>));</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 也可以用指定 column 跟 row 的方式設定內容，column 是從 0 開始編號，row 是從 1 開始編號</span></span><br><span class=\"line\">$objPHPExcel-&gt;getActiveSheet()-&gt;setCellValueByColumnAndRow(<span class=\"number\">0</span>, <span class=\"number\">1</span>, iconv(<span class=\"string\">'big5'</span>, <span class=\"string\">'utf-8'</span>, <span class=\"string\">'哈囉'</span>));</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 自動設定欄寬</span></span><br><span class=\"line\">$objPHPExcel-&gt;getActiveSheet()-&gt;getColumnDimension(<span class=\"string\">'A'</span>)-&gt;setAutoSize(<span class=\"keyword\">true</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 在 Excel 中放圖片</span></span><br><span class=\"line\">$objDrawing = <span class=\"keyword\">new</span> PHPExcel_Worksheet_Drawing();</span><br><span class=\"line\">$objDrawing-&gt;setName(<span class=\"string\">'cat'</span>);                        <span class=\"comment\">// 圖片名稱</span></span><br><span class=\"line\">$objDrawing-&gt;setDescription(<span class=\"string\">'cat'</span>);                 <span class=\"comment\">// 圖片描述</span></span><br><span class=\"line\">$objDrawing-&gt;setPath(<span class=\"string\">'cat.jpg'</span>);                    <span class=\"comment\">// 圖片檔案路徑，支援JPG及PNG格式</span></span><br><span class=\"line\">$objDrawing-&gt;setWidth(<span class=\"number\">1000</span>);                        <span class=\"comment\">// 圖片寬</span></span><br><span class=\"line\">$objDrawing-&gt;setCoordinates(<span class=\"string\">\"A2\"</span>);                  <span class=\"comment\">// 圖片放置的儲存格位置</span></span><br><span class=\"line\">$objDrawing-&gt;setOffsetX(<span class=\"number\">30</span>);                        <span class=\"comment\">// X偏移量</span></span><br><span class=\"line\">$objDrawing-&gt;setWorksheet($objPHPExcel-&gt;getActiveSheet());</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 儲存 Excel 檔，這裡會存成 .xlsx 格式</span></span><br><span class=\"line\">$objWriter = <span class=\"keyword\">new</span> PHPExcel_Writer_Excel2007($objPHPExcel);</span><br><span class=\"line\">$objWriter-&gt;save(str_replace(<span class=\"string\">'.php'</span>, <span class=\"string\">'.xlsx'</span>, <span class=\"keyword\">__FILE__</span>));    <span class=\"comment\">// Excel 檔案路徑</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"讀取-Excel\"><a href=\"#讀取-Excel\" class=\"headerlink\" title=\"讀取 Excel\"></a>讀取 Excel</h2><figure class=\"highlight php\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">include</span>(<span class=\"string\">'includes/PHPExcel/IOFactory.php'</span>);</span><br><span class=\"line\">    </span><br><span class=\"line\"><span class=\"comment\">// read excel</span></span><br><span class=\"line\">$filename = <span class=\"string\">\"test.xlsx\"</span>;</span><br><span class=\"line\">$objPHPExcel = PHPExcel_IOFactory::createReader(<span class=\"string\">'Excel5'</span>);\t<span class=\"comment\">// 與舊版相容</span></span><br><span class=\"line\">$objPHPExcel = PHPExcel_IOFactory::load($filename);</span><br><span class=\"line\">$objWorksheet = $objPHPExcel-&gt;getSheet(<span class=\"number\">0</span>);                  <span class=\"comment\">// 讀取第一個工作表</span></span><br><span class=\"line\">$data = <span class=\"keyword\">array</span>();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 用 iterator 依序讀取 rows, columns, 並將資料存到 $data</span></span><br><span class=\"line\"><span class=\"keyword\">foreach</span> ( $objWorksheet-&gt;getRowIterator() <span class=\"keyword\">as</span> $rowidx =&gt; $row ) &#123;</span><br><span class=\"line\">    $cellIterator = $row-&gt;getCellIterator();     </span><br><span class=\"line\">    $cellIterator-&gt;setIterateOnlyExistingCells(<span class=\"keyword\">false</span>);      <span class=\"comment\">// 讀入整行, 若為空回傳 null</span></span><br><span class=\"line\">    <span class=\"keyword\">foreach</span> ( $cellIterator <span class=\"keyword\">as</span> $cellidx =&gt; $cell ) &#123;  </span><br><span class=\"line\">        $data[$rowidx][$cellidx] = $cell-&gt;getValue(); </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","tags":["PHP","Third Party"]},{"title":"PHPUnit","url":"/phpunit/","content":"<p>PHP 的 Unit Test Framework。</p>\n<blockquote>\n<p>Whenever you are tempted to type something into a print statement or a debugger expression, write it as a test instead.<br>~ Martin Fowler</p>\n</blockquote>\n<p>test 要是 independent。一個 test 的 result 不能 depend 其他 test 的 result。</p>\n<h2 id=\"Install-on-Ubuntu-12-04\"><a href=\"#Install-on-Ubuntu-12-04\" class=\"headerlink\" title=\"Install on Ubuntu 12.04\"></a>Install on Ubuntu 12.04</h2><figure class=\"highlight gams\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"symbol\">$</span> sudo apt-get remove phpunit    <span class=\"comment\">// 應該是前面有先用 apt-get install 裝了才需要</span></span><br><span class=\"line\"><span class=\"symbol\">$</span> sudo pear upgrade pear         <span class=\"comment\">// pear 只要裝了 php 就有</span></span><br><span class=\"line\"><span class=\"symbol\">$</span> sudo pear channel-discover pear.phpunit.de</span><br><span class=\"line\"><span class=\"symbol\">$</span> sudo pear channel-discover pear.symfony-project.com</span><br><span class=\"line\"><span class=\"symbol\">$</span> sudo pear channel-discover components.ez.<span class=\"keyword\">no</span></span><br><span class=\"line\"><span class=\"symbol\">$</span> sudo pear update-channels</span><br><span class=\"line\"><span class=\"symbol\">$</span> sudo pear upgrade-<span class=\"keyword\">all</span></span><br><span class=\"line\"><span class=\"symbol\">$</span> sudo pear install -alldeps phpunit/PHPUnit</span><br><span class=\"line\"><span class=\"symbol\">$</span> sudo pear uninstall phpunit/PHPUnit</span><br><span class=\"line\"><span class=\"symbol\">$</span> sudo pear install phpunit/PHPUnit</span><br></pre></td></tr></table></figure>\n\n<p>最後兩個指令看起來很好笑，好像是 pear 的 script 有問題。用倒數第三行裝完之後，又會說找不到 <code>PHP_CodeCoverage_Filter::getInstance()</code>，後來做這兩行就動了。</p>\n<h3 id=\"失敗的安裝\"><a href=\"#失敗的安裝\" class=\"headerlink\" title=\"失敗的安裝\"></a>失敗的安裝</h3><p>不能直接用</p>\n<figure class=\"highlight routeros\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ sudo apt-<span class=\"builtin-name\">get</span> install phpunit</span><br></pre></td></tr></table></figure>\n\n<p>不然 run 的時候會該找不到 PHP Code Coverage。</p>\n<h2 id=\"Run-test\"><a href=\"#Run-test\" class=\"headerlink\" title=\"Run test\"></a>Run test</h2><p>run all tests</p>\n<figure class=\"highlight elixir\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"variable\">$ </span>phpunit</span><br><span class=\"line\"><span class=\"variable\">$ </span>phpunit --stderr</span><br></pre></td></tr></table></figure>\n\n<p>PHPUnit 在一些系統上會有 header already sent 的錯誤，加 <code>--stderr</code> 可以避免 PHPUnit 把這視為測試錯誤。</p>\n<p>執行單一測試，指定某測試檔做測試。</p>\n<figure class=\"highlight cmake\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ phpunit --stderr &lt;<span class=\"keyword\">test</span> <span class=\"keyword\">file</span> path&gt;</span><br></pre></td></tr></table></figure>\n\n\n<h2 id=\"Basic-conventions\"><a href=\"#Basic-conventions\" class=\"headerlink\" title=\"Basic conventions\"></a>Basic conventions</h2><ol>\n<li>class “Class” 的 test 放在 class “ClassTest”</li>\n<li>ClassTest 要繼承 PHPUnit_Framework_TestCase</li>\n<li>test 為 public method，method name 為 test*</li>\n<li>在 test 中，用 assert*() function check value 是否符合預期</li>\n</ol>\n<h2 id=\"failure-vs-error\"><a href=\"#failure-vs-error\" class=\"headerlink\" title=\"failure vs error\"></a>failure vs error</h2><p>failure 是 assertion function fail（要測試的 function 的 output 不符合預期）。以 F 代表。</p>\n<p>error 是出現 unexpected exception 或 PHP error。以 E 代表。</p>\n<h2 id=\"setUp-amp-tearDown\"><a href=\"#setUp-amp-tearDown\" class=\"headerlink\" title=\"setUp() &amp; tearDown()\"></a>setUp() &amp; tearDown()</h2><p>為了讓測試是正確且獨立的，要保持執行 test 時環境是乾淨的。在每次執行一個 test method 前會 call <code>setUp()</code> 建立 test 所需要的 object、變數等等。run 完 test method 後會 call <code>tearDown()</code> 清東西。</p>\n<p>通常只需 implement <code>tearDown()</code>，用來 close file、socket 等。</p>\n<h2 id=\"用-file-system-組合-test-suite\"><a href=\"#用-file-system-組合-test-suite\" class=\"headerlink\" title=\"用 file system 組合 test suite\"></a>用 file system 組合 test suite</h2><p>可以用 file system 的 directory structure 達到組合出一個 test suite 的目的。這也是最簡單的方式。:)</p>\n<p>建立一 test dir 並建立跟 project dir 中一樣的 directory structure。把 test case source file（就是 test method 的 source code）以相應 project source file 的位置放進去。PHPUnit 會自動 traverse test dir 做 test。</p>\n<p>舉例說明：</p>\n<p>這是 project directory：</p>\n<figure class=\"highlight reasonml\"><table><tr><td class=\"code\"><pre><span class=\"line\">object/</span><br><span class=\"line\">    <span class=\"module-access\"><span class=\"module\"><span class=\"identifier\">MyStack</span>.</span></span>php</span><br></pre></td></tr></table></figure>\n\n<p>這是 test directory：</p>\n<figure class=\"highlight reasonml\"><table><tr><td class=\"code\"><pre><span class=\"line\">tests/</span><br><span class=\"line\">    <span class=\"module-access\"><span class=\"module\"><span class=\"identifier\">MyStackTest</span>.</span></span>php</span><br></pre></td></tr></table></figure>\n\n<p>PHPUnit 會在 test dir（上例的 tests/）底下找 *Test.php 來做測試。</p>\n<h3 id=\"執行-test-suite\"><a href=\"#執行-test-suite\" class=\"headerlink\" title=\"執行 test suite\"></a>執行 test suite</h3><figure class=\"highlight dos\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ phpunit --stderr &lt;test <span class=\"built_in\">dir</span> <span class=\"built_in\">path</span>&gt;</span><br></pre></td></tr></table></figure>\n\n\n<h2 id=\"寫-test-就是…\"><a href=\"#寫-test-就是…\" class=\"headerlink\" title=\"寫 test 就是…\"></a>寫 test 就是…</h2><ol>\n<li>生一些 testcase（input 及預期的 output）</li>\n<li>在 test method 裡 call 要測的 function，把 test case 的 input 當作 arg 丟進去。</li>\n<li>用 asseert function 判斷 function 的 output 是否符合預期。</li>\n</ol>\n<h2 id=\"Ref\"><a href=\"#Ref\" class=\"headerlink\" title=\"Ref\"></a>Ref</h2><ul>\n<li><a href=\"http://www.phpunit.de/manual/3.6/en/index.html\" target=\"_blank\" rel=\"noopener\">PHPUnit manual</a></li>\n</ul>\n","tags":["PHP","Unit Test"]},{"title":"Prefix Scan","url":"/prefix-scan/","content":"<p>prefix scan 是計算一個數值 vector 所有的部份和，每個結果 element 是原始 vector 對應位置之前數值的和，包含自己的稱為 inclusive prefix scan，不包含稱為 exclusive prefix scan。例如 <code>[3, 5, 4, 10, 8]</code> 的 inclusive prefix scan 是 <code>[3, 8, 12, 22, 30]</code>，exclusive 是 <code>[0, 3, 8, 12, 22]</code>。</p>\n<a id=\"more\"></a>\n\n<p>簡單的 sequential 演算法沒什麼好說的，用另一個 array 存結果，一個 loop 加過去：</p>\n<script src=\"//gist.github.com/f488ddc63487de8c01ec6eeb23c38886.js\"></script>\n\n<p><code>$ gcc -std=c99 seq.c -o seq</code></p>\n<h2 id=\"Concurrent-Algorithm\"><a href=\"#Concurrent-Algorithm\" class=\"headerlink\" title=\"Concurrent Algorithm\"></a>Concurrent Algorithm</h2><p>將 data 用 thread 數量切成幾塊，每個 thread 負責一塊 data 做區域 prefix scan。取出每一塊區域 prefix scan 最後一個 element 組成一個 array，對這個 array 做 exclusive prefix scan。最後將 exclusive prefix scan 每個 element 加回區域 prefix scan 結果即為整個 array 的 prefix scan。例如：</p>\n<ul>\n<li>原始資料：<code>[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 9, 8, 7, 6, 5, 4]</code></li>\n<li>切成四塊：<code>[1, 2, 3, 4]</code> <code>[5, 6, 7, 8]</code> <code>[9, 10, 9, 8]</code> <code>[7, 6, 5, 4]</code></li>\n</ul>\n<ol>\n<li>區域 prefix scan：<code>[1, 3, 6, 10]</code> <code>[5, 11, 18, 26]</code> <code>[9, 19, 28, 36]</code> <code>[7, 13, 18, 22]</code></li>\n<li>取出最後一個 element 得到 <code>[10, 26, 36, 22]</code>，做 exclusive prefix scan 得到 <code>[0, 10, 36, 72]</code></li>\n<li>將步驟 2 的結果加回對應區塊的區域 prefix scan：<code>[1, 3, 6, 10]</code> <code>[15, 21, 28, 36]</code> <code>[45, 55, 64, 72]</code> <code>[79, 85, 90, 94]</code>，這四塊合在一起就是完整的 prefix scan。</li>\n</ol>\n<p>步驟 1 跟 3 各區塊的計算可以獨立完成，步驟 2 需要計算跟 thread 數量相同的 prefix scan，可以用 sequential 的方式處理。這個演算法的步驟 2 必須等步驟 1 全部完成後才能做，步驟 3 也得等步驟 2 做完才能執行，所以實作上要有讓 thread 等待直到某個步驟做完才繼續的機制。</p>\n<script src=\"//gist.github.com/bf72e1cc68b1c837a3bbc8a65dc04c93.js\"></script>\n\n<p><code>$ gcc -DNUM_THREADS=4 -std=c99 -pthread con.c -o con</code></p>\n<p>實作上用 condition variable 達到「等待上一個步驟做完才繼續」的同步機制。</p>\n<h2 id=\"Performance-比較\"><a href=\"#Performance-比較\" class=\"headerlink\" title=\"Performance 比較\"></a>Performance 比較</h2><p>sequential 版跟 concurrent 版究竟效能差多少呢？猜想 concurrent 的執行時間會比較短但不會呈倍數減少，例如用 4 個 thread 不會讓執行時間變成 1/4，因為有生 thread 跟同步機制的 overhead。prefix scan 的運算很簡單，concurrent 帶來的 overhead 相對原本計算量的比重會比較高，效能差距可能不會非常明顯。</p>\n<h3 id=\"測試環境\"><a href=\"#測試環境\" class=\"headerlink\" title=\"測試環境\"></a>測試環境</h3><ul>\n<li>Debian 9.2</li>\n<li>kernel 4.9.0-4-amd64</li>\n<li>4 Intel(R) Core(TM) i5-6500 CPU @ 3.20GHz</li>\n</ul>\n<h3 id=\"測量-amp-比較\"><a href=\"#測量-amp-比較\" class=\"headerlink\" title=\"測量 &amp; 比較\"></a>測量 &amp; 比較</h3><p>測量結果是用 <code>perf</code> 跑五次得到的執行時間。<em>這是個簡單用來玩玩的例子。</em></p>\n<p>在 input size 固定的情況下觀察 sequential 版本與 concurrent 不同 thread 數的執行時間：</p>\n<p><img src=\"/images/prefix_scan_performance.png\" alt=\"performance\"></p>\n<p>concurrent 版本因為有生 thread 以及 synchronization 的 overhead，在只有一個 thread 的情況下表現會比 sequential 差。兩個 thread 就能比 sequential 好一些，4 個 thread 好更多，但 8 個 thread 的效能沒有再更好。</p>\n<p>再比較在不同 input size 下，concurrent 不同 thread 數的相對 sequential 的 speedup（<code>sequential 執行時間 / concurrent 執行時間</code>）：</p>\n<p><img src=\"/images/prefix_scan_speedup.png\" alt=\"speedup\"></p>\n<p>input size 不夠大（10^4 ~ 10^5）concurrent 程式的效能反而因為 overhead 而下降，input size 在 10^6 以上才有明顯的效能提升，但 4 個 thread 跟 8 個 thread 的結果依然差不多。這可能是因為這顆 CPU 是 4 core，超過 4 個 thread 導致 thread 必須在 core 上 context switch 的 overhead。</p>\n<p>最後看看兩種版本的程式到底都在忙些什麼：</p>\n<p><code>$ perf record -g ./seq 10000000</code></p>\n<p><img src=\"/images/prefix_scan_seq_report.png\" alt=\"sequential report\"></p>\n<p><code>$ perf record -g ./con_4 10000000</code></p>\n<p><img src=\"/images/prefix_scan_con_report.png\" alt=\"concurrent report\"></p>\n<p>除了計算本身，都花了些時間在亂數產生 input 以及 page fault 上。<code>perf record</code> 產生的報告是 binary 檔，用 <code>perf report</code> 看。</p>\n<h2 id=\"Ref\"><a href=\"#Ref\" class=\"headerlink\" title=\"Ref\"></a>Ref</h2><ul>\n<li>《The Art of Concurrency》</li>\n<li><a href=\"http://wiki.csie.ncku.edu.tw/embedded/perf-tutorial\" target=\"_blank\" rel=\"noopener\">Linux 效能分析工具: Perf</a></li>\n<li><a href=\"https://perf.wiki.kernel.org/index.php/Tutorial\" target=\"_blank\" rel=\"noopener\">perf Tutorial</a></li>\n<li><a href=\"https://www.ibm.com/developerworks/cn/linux/l-cn-perf1/\" target=\"_blank\" rel=\"noopener\">Perf – Linux下的系統性能調優工具</a></li>\n<li><a href=\"https://hackmd.io/s/Skwp-alOg\" target=\"_blank\" rel=\"noopener\">gnuplot 語法解說和示範</a></li>\n</ul>\n","tags":["Concurrency"]},{"title":"Pthread Condition Variable","url":"/pthread-condition-variable/","content":"<p>man page 對 condition variable 的說明：</p>\n<blockquote>\n<p>A condition (short for ``condition variable’’) is a synchronization device that allows threads to suspend execution and relinquish the processors  until some predicate on shared data is satisfied. The basic operations on conditions are: signal the condition (when the predicate becomes true), and wait for the condition, suspending the thread execution until another thread signals the condition.</p>\n</blockquote>\n<p>讓某些 thread suspend 起來，等某個條件成立才繼續往下執行。而另外有些 thread 則會更動條件中變數的值，並在該條件成立時 “signal condition” 叫起在 wait 的 thread 來執行。</p>\n<blockquote>\n<p>A condition variable must always be associated with a mutex, to avoid the race condition where a thread prepares to  wait  on  a  condition variable and another thread signals the condition just before the first thread actually waits on it.</p>\n</blockquote>\n<p>condition variable 必須搭配 mutex，避免 race condition：thread A 在 thread B signal condition 後才 wait 這個 condition variable，這種狀況可能讓 thread A 永遠在 sleep（如果沒有人會再 signal 這個 condition variable）。</p>\n<p>如果所有 thread 在 signal condition variable 之前都 lock mutex，就能保證 condition 不會在 thread lock mutex 跟 wait condition variable 之間被 signal。或者說是不會在 check 過 condition 到 call wait function 以前其他 thread 就 signal condition variable。</p>\n<p><code>pthread_cond_signal()</code> 會叫起一個正在 wait condition variable 的 thread 來 run。如果沒有 thread 正在 wait，什麼事都不會發生。</p>\n<p><code>pthread_cond_wait()</code> 會 atomically unlcok mutex 並讓 calling thread wait condition variable（suspend 此 thread，suspend 的 thread 不會使用任何 CPU time）。這兩個動作是 atomically 執行的，不會被打斷。</p>\n<p>進入 <code>pthread_cond_wait()</code> 前必須先 lock mutex。而 <code>pthread_cond_wait()</code> 在 return（可以 return 是因為有人 signal condition variable）前，會重新 lock 住 mutex。</p>\n","tags":["Programming"]},{"title":"Pthread Mutex","url":"/pthread-mutex/","content":"<p>mutex 用來保護多個 thread 共享（shared）的資料，避免 concurrent modification 造成問題。</p>\n<p>lock mutex =&gt; modify shared data =&gt; unlock mutex</p>\n<p>mutex 有三種 type：</p>\n<ol>\n<li>fast</li>\n<li>recursive</li>\n<li>error check</li>\n</ol>\n<p>操作 mutex 的 function 會依照 type 不同而可能有不同的操作方式。</p>\n<h2 id=\"Initialize-Mutex\"><a href=\"#Initialize-Mutex\" class=\"headerlink\" title=\"Initialize Mutex\"></a>Initialize Mutex</h2><p>initial 時，可以用 pthread_mutex_init() 或直接 assign const 指定 mutex 的 type。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">pthread_mutex_init</span><span class=\"params\">(<span class=\"keyword\">pthread_mutex_t</span> *mutex, <span class=\"keyword\">const</span> <span class=\"keyword\">pthread_mutexattr_t</span> *mutexattr)</span></span>;</span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"comment\">// 直接 assign const</span></span><br><span class=\"line\"><span class=\"keyword\">pthread_mutex_t</span> fastmutex = PTHREAD_MUTEX_INITIALIZER;</span><br><span class=\"line\"><span class=\"keyword\">pthread_mutex_t</span> recmutex = PTHREAD_RECURSIVE_MUTEX_INITIALIZER_NP;</span><br><span class=\"line\"><span class=\"keyword\">pthread_mutex_t</span> errchkmutex = PTHREAD_ERRORCHECK_MUTEX_INITIALIZER_NP;</span><br></pre></td></tr></table></figure>\n\n\n<h2 id=\"Lock-Mutex\"><a href=\"#Lock-Mutex\" class=\"headerlink\" title=\"Lock Mutex\"></a>Lock Mutex</h2><figure class=\"highlight stylus\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"title\">pthread_mutex_lock</span><span class=\"params\">()</span></span></span><br></pre></td></tr></table></figure>\n\n<p>如果 mutex 是 unlock 狀態，則 lock 該 mutex 且讓該 mutex 為 call phread_mutex_lock() 的 thread 擁有，做完這些後立刻 return。</p>\n<p>如果 mutex 正被 lock 住，此 function 會依照不同 type 的 mutex 有不同動作：</p>\n<ol>\n<li><p>fast</p>\n<p>calling thread 會 suspend，直到 mutex unlock。沒寫好的話可能造成 deadlock。</p>\n</li>\n<li><p>recursive</p>\n<p>成功並立刻 return。這種 mutex 會記錄它被 lock 幾次，也就是一個 thread 可以 lock 這種 mutex 很多次。要 unlock 這種 mutex 時，也必須 call 相應 lock 次數的 unlock function 才能真正 unlock。</p>\n</li>\n<li><p>error check</p>\n<p>立刻 return，但 errno = EDEADLK。<em>真是個會讓人誤會的 errno 名稱…</em></p>\n<p>EDEADLK 在 man page 的解釋：</p>\n<blockquote>\n<p>the mutex is already locked by the calling thread (``error checking’’ mutexes only).</p>\n</blockquote>\n</li>\n</ol>\n<h2 id=\"Try-Lock-Mutex\"><a href=\"#Try-Lock-Mutex\" class=\"headerlink\" title=\"Try Lock Mutex\"></a>Try Lock Mutex</h2><figure class=\"highlight stylus\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"title\">pthread_mutex_trylock</span><span class=\"params\">()</span></span></span><br></pre></td></tr></table></figure>\n\n<p>跟 pthread_mutex_lock() 差不多，差別是這個不會 block 住。</p>\n<p>操作 fast mutex 時，trylock() 會立刻 return，而 errno 為 EBUSY。</p>\n<h2 id=\"Unlock-Mutex\"><a href=\"#Unlock-Mutex\" class=\"headerlink\" title=\"Unlock Mutex\"></a>Unlock Mutex</h2><figure class=\"highlight stylus\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"title\">pthread_mutex_unlock</span><span class=\"params\">()</span></span></span><br></pre></td></tr></table></figure>\n\n<p>進入此 function 前，mutex 應為 locked 且被 calling thread 擁有。</p>\n<p>fast mutex 會直接被 unlock。recursive mutex 需 call 相同於 lock 次數的 unlock 才會真正 unlock。</p>\n<p>error check 跟 recursive 的 mutex 會檢查兩個條件：此 mutex 是否為 locked 且被 calling thread 擁有。若有一條件不符合，則不會 unlock，會 return error code。fast mutex 不會做此檢查，所以非擁有此 mutex 的 thread 也可以 unlock 它（這當然不好）。</p>\n<h2 id=\"Ref\"><a href=\"#Ref\" class=\"headerlink\" title=\"Ref\"></a>Ref</h2><ul>\n<li>Linux pthread_mutex man page<ul>\n<li>PS：Ubuntu 上要裝 glic-doc 才有 pthread 的 man page</li>\n</ul>\n</li>\n</ul>\n","tags":["Programming"]},{"title":"Pull-up & Pull-down resistor（上拉 & 下拉電阻）","url":"/pull-up-and-pull-down-resistor/","content":"<p>接 button、switch 時會用到。<del>（看到 button 這字想到的是 GUI 上的…）</del></p>\n<p>電路中希望維持一個電位基準值，好判斷某個電壓值是 0 還是 1。pull-up 跟 pull-down 電阻就是用來維持基準電位的，如果電路沒有接個東西，程式會讀到雜訊（亂數值）。</p>\n<p><img src=\"/images/Pullup_Resistor.png\" alt=\"Pull-up resistor\"></p>\n<p>switch 斷開時上半部的電路是通的，logic gate 會讀到較高的電位。switch 接上後，logic gate 的電位會變低（從電流來看是下半部電路會接通，以至於電位會改變）。如果認定 switch 接上是邏輯的 1 則 logic gate 是低電位時表示邏輯的 1，高電位表示邏輯的 0。</p>\n<p><img src=\"/images/Pulldown_Resistor.png\" alt=\"Pull-down resistor\"></p>\n<p>pull-down 電阻是反過來，switch 斷開時 logic gate 會讀到低電位，接上後是高電位。所以高電位表示邏輯 1，低電位表示邏輯 0。</p>\n<p>接 Raspberry Pi 時，上面說的 logic gate 就是 Raspberry Pi 的 GPIO pin。</p>\n<p><em>murmur：被高低電位搞得頭有點暈，不太確定那個電流的理解對不對？沒搞得很懂 logic gate 在乎的是電位還是電位差……我的電路學只有高中程度啊……Orz</em></p>\n<p>圖片來源及 Ref：</p>\n<ul>\n<li><a href=\"http://zh.wikipedia.org/wiki/%E4%B8%8A%E6%8B%89%E7%94%B5%E9%98%BB\" target=\"_blank\" rel=\"noopener\">http://zh.wikipedia.org/wiki/%E4%B8%8A%E6%8B%89%E7%94%B5%E9%98%BB</a></li>\n<li><a href=\"http://playground.arduino.cc/CommonTopics/PullUpDownResistor\" target=\"_blank\" rel=\"noopener\">http://playground.arduino.cc/CommonTopics/PullUpDownResistor</a></li>\n</ul>\n","tags":["Raspberry Pi"]},{"title":"Qt4 Sequential Container","url":"/qt4-sequential-container/","content":"<p>這篇是看 Qt4 Container 相關網頁的筆記，包含三種 Sequential Container：QVector、QList、QLinkedList。<em>PS：Qt 已經出到 5。（2014/4/21）</em></p>\n<a id=\"more\"></a>\n\n<h2 id=\"QVector\"><a href=\"#QVector\" class=\"headerlink\" title=\"QVector\"></a>QVector</h2><p>QVector 使用一塊連續的 memory。</p>\n<p><img src=\"/images/qt4-sequential-container/qt4-sequential-container-1.png\" alt=\"QVector\"></p>\n<p><img src=\"/images/qt4-sequential-container/qt4-sequential-container-2.png\" alt=\"QVector\"></p>\n<p>QVector<T> 是 implicitly shared，有時稱為 copy on write。copy 一 QVector 時，只會 copy pointer d 以及增加 reference count ref。從以下 copy constructor 及 assignment operator 可以看出來：</p>\n<figure class=\"highlight cpp\"><figcaption><span>copy constructor in Qt 4.8.0 qvector.h</span></figcaption><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"title\">QVector</span><span class=\"params\">(<span class=\"keyword\">const</span> QVector&lt;T&gt; &amp;v)</span> : <span class=\"title\">d</span><span class=\"params\">(v.d)</span> </span>&#123; d-&gt;ref.ref(); <span class=\"keyword\">if</span> (!d-&gt;sharable) detach_helper(); &#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight cpp\"><figcaption><span>assignment operator in Qt 4.8.0 qvector.h</span></figcaption><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> T&gt;</span><br><span class=\"line\">QVector&lt;T&gt; &amp;QVector&lt;T&gt;::<span class=\"keyword\">operator</span>=(<span class=\"keyword\">const</span> QVector&lt;T&gt; &amp;v)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    QVectorData *o = v.d;</span><br><span class=\"line\">    o-&gt;ref.ref();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!d-&gt;ref.deref())</span><br><span class=\"line\">        <span class=\"built_in\">free</span>(p);</span><br><span class=\"line\">    d = o;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!d-&gt;sharable)</span><br><span class=\"line\">        detach_helper();</span><br><span class=\"line\">    <span class=\"keyword\">return</span> *<span class=\"keyword\">this</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>QVector<T> 依據 T 的 type 決定如何增加 size。T 是 movable 則用 realloc() 每次增加 4096 bytees。T 是 non-movable，則每次增加 50% 的size。</p>\n<p>movable：a data type that can safely be moved around in memory using memcpy() or memmove(), such as the C++ primitive types and Qt’s implicitly shared classes.</p>\n<h2 id=\"QList\"><a href=\"#QList\" class=\"headerlink\" title=\"QList\"></a>QList</h2><p>QList<T> 以 array list 的方式 implement，不是用 linked list。它的 array 裡是一堆指標，指向 data T，如下圖：</p>\n<p><img src=\"/images/qt4-sequential-container/qt4-sequential-container-3.png\" alt=\"QList\"></p>\n<p>QList 會在它的 array 前面保留一些空間，以 begin 跟 end 記錄保留的空間是哪一段。這麼做方便在 list 的前面增加、移除 data，並且當要在 list 中間 insert  data 時，前面保留的空間可作為資料移動的空間，因為它是 array list，不像 linked list 可以直接改 pointer 來 insert data。例如要塞一個 data 到位置 k，可把原本前面 k-1 個 data 往前面移。</p>\n<p><em>如果前面保留的空間用完了？</em></p>\n<h2 id=\"QLinkedList\"><a href=\"#QLinkedList\" class=\"headerlink\" title=\"QLinkedList\"></a>QLinkedList</h2><p>提供 doubly linked list。適合龐大資料以及需要 O(1) 的 insertion 跟 removal。如果資料量在 200 element 以下，QList 的 performance 比較好。</p>\n<h2 id=\"選擇-sequential-container\"><a href=\"#選擇-sequential-container\" class=\"headerlink\" title=\"選擇 sequential container\"></a>選擇 sequential container</h2><p>QVector、QList、QLinkedList 有不同特性，如何選擇使用哪個？</p>\n<ul>\n<li>大多數時候可選擇 QList。它使用 index-based API，比 QLinkedList 的 iterator-based API 方便，速度通常比 QVector 快，而且生出來的可執行 code 也較短。</li>\n<li>如果需要一個真正的 linked list，希望 insert data 到 list 中間花的時間是 constant time，且想使用 iterator，則用 QLinkedList。</li>\n<li>如果希望 element 佔據的 memory 是連續的，選擇 QVector。</li>\n</ul>\n<h2 id=\"Ref\"><a href=\"#Ref\" class=\"headerlink\" title=\"Ref\"></a>Ref</h2><ul>\n<li><a href=\"http://doc.qt.digia.com/qq/qq19-containers.html\" target=\"_blank\" rel=\"noopener\">http://doc.qt.digia.com/qq/qq19-containers.html</a></li>\n</ul>\n","tags":["Qt"]},{"title":"Read-Write Lock","url":"/read-write-lock/","content":"<p>Read-Write lock 分成用於 read 跟 write 兩種 lock。使用 read lock 表示只會對 resource 做 read-only 的 access，使用 write lock 表示會修改 resource。</p>\n<p>當一個 thread 要做 write 時，其他 read-only thread 會被 block 直到 write 做完。</p>\n<p>Read-Write lock 適合有較多 read，write 較少但 priority 比較高的時候。</p>\n<p>Qt 跟 Read-Write lock 相關的 class：QReadWriteLock、QReadLocker、QWriteLocker</p>\n","tags":["Programming","Qt"]},{"title":"Clean Code","url":"/review-of-Clean-Code/","content":"<p>忙了半年左右，我回來了(?)，來寫點早該看完的《Clean Code》小心得。</p>\n<p>整本書講 clean code 的原則，最後以一個大例子運用原則跟示範 refactor。寫那些原則像在抄書，只針對比較有感的原則跟 code smell 寫點心得。</p>\n<h3 id=\"最少驚奇（嚇）原則\"><a href=\"#最少驚奇（嚇）原則\" class=\"headerlink\" title=\"最少驚奇（嚇）原則\"></a>最少驚奇（嚇）原則</h3><p>讓看你的 code 的人（很可能就是你自己）對那段 code 的預期符合實際結果，儘量符合 common sense 以減少驚奇、驚嚇與驚恐。code 愈能符合預期，愈能減少進去實作看細節的時間。反之，如果常常不符預期，不用多久大家就會戒慎恐懼的每次都進去看實作，不然天知道它會發生什麼事，對吧？</p>\n<p>不過我承認，似乎不是所有人的 commen sense 都一樣。</p>\n<a id=\"more\"></a>\n\n<h3 id=\"base-class-不應該知道實作細節\"><a href=\"#base-class-不應該知道實作細節\" class=\"headerlink\" title=\"base class 不應該知道實作細節\"></a>base class 不應該知道實作細節</h3><p>跟實作細節有關的常數、變數或 function 只該出現在 derived class、不該出現在 base class。</p>\n<p>base class 不該對實作有任何假設。</p>\n<h3 id=\"Static-vs-Non-static-function\"><a href=\"#Static-vs-Non-static-function\" class=\"headerlink\" title=\"Static vs Non-static function\"></a>Static vs Non-static function</h3><p>本書建議少用 static function，在模糊不確定時讓 function 是 non-static，使用 static function 要確定不會有任何可能想讓該 function 是多型。</p>\n<p>我好像曾經在哪裡看過建議使用 static function 而非 non-static function，但忘記是哪了，也可能我記反了。總之有段時間只要遇到沒使用 member 的 function 一律宣告成 static，因為既然實作沒用到 member 就限制住它。</p>\n<p>好吧這是前陣子的爭論點之一。我發現在 interface 上將 function 們宣告成 static 會限制 class 的實作方式、class 無法使用 member，而 interface 不該知道或者限制 class 的實作（類似上一點的概念）。以多型基本上是操作 object 來說，讓 interface 的多數 function 是 static 挺奇怪的，static 表示不需要 object 就可以使用，那好像沒有定成 interface 意義？</p>\n<p>所以後來改觀了，現在傾向用 non-static function 而非 static，static function 只在有語意跟功能上較適合 static 才用。</p>\n<h3 id=\"不要在實作時假設其他-class-的東西\"><a href=\"#不要在實作時假設其他-class-的東西\" class=\"headerlink\" title=\"不要在實作時假設其他 class 的東西\"></a>不要在實作時假設其他 class 的東西</h3><p>這不是書裡的原則，是我的感想。這藏在很多地方，像是 base clas 不該知道實作細節、不要在 class A 假設知道 class B 的任何事、要使用多型就不要假設某個變數是某個 class 的 object 等等。</p>\n<p>發現實作上很容易忽略，可能因為如果不是使用別人的介面，程式設計師知道相關 class 們的各種細節，以至於容易把屬於 A 的東西放進 B 而渾然不覺。我避免這種「假設」的方法是想像自己是 class A 然後問：「我該知道這個資訊嗎？」</p>\n<h3 id=\"用多型取代-if-else-或-switch-case\"><a href=\"#用多型取代-if-else-或-switch-case\" class=\"headerlink\" title=\"用多型取代 if/else 或 switch/case\"></a>用多型取代 if/else 或 switch/case</h3><p>不是絕對，但如果 code 裡到處有跟 type 相關的 switch/case 或 if/else，用多型比較好。讓生出多型 object 的地方是唯一有 switch 的地方，其他部份的 switch 就能用多型 object 處理。</p>\n<h3 id=\"Structure-over-Convention（結構勝於常規）\"><a href=\"#Structure-over-Convention（結構勝於常規）\" class=\"headerlink\" title=\"Structure over Convention（結構勝於常規）\"></a>Structure over Convention（結構勝於常規）</h3><p>「具有強制決策設計特性的結構」勝於「慣例」。</p>\n<p>有大家遵守的慣例當然很好，但用強制性的程式結構更好。例如用有 abstract function 的 base class 比用 switch/case 好，因為 switch/case 的撰寫不是強制性的，很可能會漏改，而 abstract function 的實作是強制的，只要繼承該 base class 就必須實作，不然會 compile 不過或跑起來 error。</p>\n<p>強制性的程式結構可以降低漏改或改錯的可能性，改錯馬上就知道了。套句以前聽過的話：「就是要讓寫錯的編不過，他編不過就知道錯了」</p>\n<p>再說了，我很懶得記慣例（喂）</p>\n<h3 id=\"時序耦合\"><a href=\"#時序耦合\" class=\"headerlink\" title=\"時序耦合\"></a>時序耦合</h3><p>時序耦合是指某些 function 必須以某個次序 call，例如有三個 function A()、B()、C() 需要依序 call。如果 function 沒有顯著的顯示出時序耦合，可能被以錯誤的順序 call。書裡是建立流水線來凸顯時序性，也就是讓 <code>B()</code> 的 input 是 <code>A()</code> 的 output、<code>C()</code> 的 input 是 <code>B()</code> 的 output。</p>\n<p>另外我認為 public function 似乎儘量不要有密切的時序耦合比較好，例如上述三個 function 是 public <strong>要依序而且馬上</strong> call 才能完成一件事，這種情況用另一個 public function 把 call <code>A()</code>、<code>B()</code>、<code>C()</code> 包起來比較好。</p>\n","tags":["Programming","Reading"]},{"title":"The Nature of Software Development","url":"/review-of-The-Nature-of-Software-Development/","content":"<p>薄薄一本、每頁短短的還有可愛插圖(?)，觀念不難但<strong>做到很難</strong>。</p>\n<p>軟體開發環繞著「value」，翻成中文我想是「價值」。</p>\n<blockquote>\n<p>value is “what you want”.</p>\n</blockquote>\n<p>重要概念：</p>\n<ul>\n<li>決定 value 是什麼或者說要什麼，feature 會為軟體帶來 value</li>\n<li>以重要性決定做 feature 的順序</li>\n<li>以 feature 組織 team</li>\n<li>feature by feature 開發，以 feature 了解目前進度</li>\n<li>頻繁 deliver 得到回饋以知道是否需要調整 feature、方向甚至可以結束開發</li>\n</ul>\n<p>每個概念都有更細的觀念跟具體作法，不過本書不太提具體作法。</p>\n<h2 id=\"Agile\"><a href=\"#Agile\" class=\"headerlink\" title=\"Agile\"></a>Agile</h2><p>整本書概念算是環繞著 Agile 的精神吧，看完最大感想：</p>\n<blockquote>\n<p>Agile is simple, but not easy.</p>\n</blockquote>\n<p>Agile 應該不只是開發人員的事，也包含業務甚至客人，而光開發要能做到就已經很困難了。</p>\n<p>我沒有長時間跑 Agile style 開發的經驗，不知道長時間運作的結果，也不知道跑起來順的 Agile 是什麼樣子。只有拿相關東西做些實驗，例如 unit test 跟自動化測試，但連 CI 都還稱不上。</p>\n<p>對開發而言光是「隨時保持軟體可正常運作、可以 deploy」，也就是完整 CI/CD 就已經很不容易了。</p>\n<a id=\"more\"></a>\n\n<h2 id=\"Feature-by-Feature\"><a href=\"#Feature-by-Feature\" class=\"headerlink\" title=\"Feature by Feature\"></a>Feature by Feature</h2><p>feature by feature 開發也是我覺得很困難的地方。我對 feature 的定義是軟體功能，但書裡不是這樣定義 feature，那什麼東西可以是 feature？</p>\n<p>本書觀點：Features add value to software and value is what you want.</p>\n<p><del>然後你就覺得有講跟沒講一樣……</del></p>\n<p>好吧，假設我們知道要什麼了（喂），接下來如何估 feature size？如果 feature 太大要怎麼切？分工又要怎麼分？</p>\n<p>目前遇到做不到 feature by feature 開發（這邊說的 feature 還是偏向「軟體功能」）的最大困難在「不知道怎麼將一個大功能切成多個部份去分工」。有時候大功能可以切分成比較不互相干擾的小功能，這種情況還可以分工，但很多時候怕修改的 code 互相衝突所以不敢再切再分。</p>\n<p>不是做所有東西都需要多人分工，畢竟多人就有溝通成本。東西大到某個程度後分工會比較快，可是大到多大該分？而「害怕修改互相衝突所以不分」又真的無法解決嗎？</p>\n<h2 id=\"Design-and-Clean-Code\"><a href=\"#Design-and-Clean-Code\" class=\"headerlink\" title=\"Design and Clean Code\"></a>Design and Clean Code</h2><p>本書主張快速並且持續的 deploy 小 feature 來進行開發，能這麼做的基礎來自 clean code、自動化測試、不斷 refine 的 design 等等。</p>\n<p>程式整體架構跟結構是會逐漸變動的，並不是一開始定好長怎樣，往後就不再變動。</p>\n<p>我現在傾向做「比剛好符合需求多一點擴充性的 design」，完全不考慮擴充性會讓之後有些東西動不了，例如 DB，現在還不知道到底要怎麼在中後期改善 DB 結構。也儘量避免做擴充性超強或者非常 general 的設計，一是擴充性超強不見得用得到，二是一開始做的 general 常常是自以為的 general，有第二組類似東西要加的時候很容易根本不合。</p>\n<h3 id=\"Planning-with-“stretch-goals”-is-destructive-p-39\"><a href=\"#Planning-with-“stretch-goals”-is-destructive-p-39\" class=\"headerlink\" title=\"Planning with “stretch goals” is destructive (p.39)\"></a>Planning with “stretch goals” is destructive (p.39)</h3><p>不要試圖在一段時間內增加要做的 feature。</p>\n<p>這會導致 team 為了「多加一個 feature」變得匆忙、開始「趕」，然後開始這裡少一個 test、那裡髒一點，結果是增加出 bug 的機率，之後得花其他時間修，或者後續開發因為 code 太髒而變慢。</p>\n<p>蠻同意這一點的。我在匆忙下會開始掉東西，也會試圖減一些不太該減的東西，還有加 feature 看到別人趕出來的亂 code 真的會覺得「為什麼當初不好好寫，現在還不是要先 refactor……」</p>\n<p>「匆忙趕工」只會更慢。</p>\n<p>心有戚戚焉也能理解，但還是有點違反直覺。就是來不及或者多塞東西了才想要用趕的，反射性認為用趕的就能追上或比較快，但……事後要嘛有 bug 不嘛掉東西再不然下次加新功能難改到想罵人。因為違反直覺，所以現在遇到還是得克制一下衝動(?)。</p>\n<h2 id=\"About-member\"><a href=\"#About-member\" class=\"headerlink\" title=\"About member\"></a>About member</h2><p>請容我說一句，我認為開發 team 裡每個人能力都要在一個水準之上並且擁有「想不斷改進」的 mindset，才能做到還算順暢的 Agile style 開發。</p>\n<p>同時，發現 team member 欠缺某些能力時，是要去提升的。</p>\n<h2 id=\"Conclusion\"><a href=\"#Conclusion\" class=\"headerlink\" title=\"Conclusion\"></a>Conclusion</h2><p>本書最後結論寫得蠻有意境的。</p>\n<p>Agile style 開發是很多人面對軟體開發的種種問題，經過實際使用然後認為有效的方式。</p>\n<p>對於習慣，呃，土砲硬幹開發法？（不要亂取名字）的人來說，Agile 可能蠻容易違反直覺的？或者，違反「一直以來都這麼做」。</p>\n<p>只是，那些直覺跟那些「一直以來都這麼做」的方式，真的有經過試驗確認有效？又真的試過 Agile 方法確認無效？</p>\n<p>有用同樣標準看待各種方法嗎？</p>\n<p>還是說，之所以堅持那些直覺跟「一直以來都這麼做」，是因為試驗跟換方法很麻煩？</p>\n<p>每種方法有適用的問題跟情境以及使用後的效果，武器庫有愈多武器，面對各種狀況就有愈多選擇、愈能針對情境選擇最適用的。</p>\n","tags":["Reading"]},{"title":"scrum觀察日記","url":"/scrum-1/","content":"<p>最近工作在跑scrum，來篇觀察日記(欸)。<del>一個端午連假吃飽太閒的概念</del></p>\n<p>頭一兩次planning meeting只有「混亂」兩個字可以形容。人多到坐了好幾張桌子，後面不知道前面在講什麼、前面不知道後面在幹嘛，直接分裂成好幾個小圈圈自己討論，整個會開下來都不知道在做什麼。混亂了一兩次之後，與會人數才縮減到比較能進行討論的數量。</p>\n<p>一開始的討論是上面講上面的、底下自己懂自己的，到底真懂還是假懂，到底我的懂跟你的懂一不一樣都沒人知道，實作下去就發現做下來跟原本想的不一樣。接著的planning meeting開始出現會澄清彼此認知跟假設以及資訊的交流，到這裡才有那麼點資訊流通的樣子出來。不過這樣的澄清跟交流主要還是靠主持人push，而現在的主持人還是scrum master，以這點來說應該是非常不符合scrum……XD 但是我覺得以當前狀況來說這是可以接受的。到目前為止，雖然有RD跟QA參與（先別管什麼跨功能），但討論比較多還是在RD之間跟向PO確認使用者想要的東西，可能因為story被拆小，目前為止的story的測試成分不高。</p>\n<p>我承認有時候planning開一開會覺得很煩躁，怎麼同一段話每個人的理解都不一樣、奇怪這上次不是講過了、啊現在到底是怎樣、能不能快點達成共識啊？可是，這正是討論需要做的，如果不讓每個人表達意見、發問跟參與討論，我們會直接失去不同的想法與聲音，那也沒必要開這種會，看誰厲害聽他的就好了。</p>\n<p>planning meeting中可以讓member知道為什麼要做這個功能、使用者如何使用、需求又是什麼，我覺得這對RD蠻好的，畢竟大家通常會想知道為什麼要做這個功能、為什麼要這麼做，知道理由跟也能認為合理蠻重要的。而RD知道這些，在實作之外，或許也能提供其他建議。</p>\n<p>估size也可以觀察到很有趣的事情。出牌的重點不在精確估出size而在資訊交流及溝通。頭幾次一個story就出很多次牌，好像想出到大家都是一致的，沒幾次就讓人想從眾，尤其是你不想講話或者講到沒什麼好講的時候。我曾經閃過因為不想講話乾脆去猜大多數人會出的牌的念頭，不過想想不太對就沒這麼幹。可能發現這樣出牌會沒完沒了，後來估size變成出兩次牌或收斂到兩三個區間就用權重算size，這似乎讓人變得比較忠於自己的想法。</p>\n<p>人的行為會被環境跟過往經驗影響。出牌跟別人不一樣需要說明，說完出牌還是跟其他人有落差的時候，有些人會選擇堅持自己的想法，有些人會因為不想再被cue而出得跟大家一樣。原本就堅持自己想法的人很好，但考量台灣教育及工作環境的薰陶，對於「表達意見」的看法可能是負面的，而scrum希望每個人可以表達自己的想法，應該在實際做法上設法減少從眾跟鼓勵表達。我不覺得只是口頭上說「大家應該要表達自己的想法啊」、「應該要有熱情有向上的心啊」有多大意義，對表達想法的鼓勵與否，重點之一在有人提出意見後「發生什麼事」。開會開到一片死寂也沒那麼容易，總有人身先士卒的說些什麼，說完之後得到什麼樣的回應會影響其他人開口的意願，這種事實跟環境氣氛比嘴上說說更有說服力。</p>\n<p>daily meeting的部分，好吧雖然可以理解但實在不太喜歡調整後的開始時間，先不論這個的話，我覺得不錯的地方是主持人一個個問有沒有什麼阻礙，雖然成員可以主動說出阻礙是比較好的，可是在還沒建立這樣的習慣前，刻意詢問每個人就是給予機會去表達跟習慣，雖然被動但總比沒有好。如果像我比較害羞或者有時候就是忘了，反正每天都有機會。也注意到自從有次問阻礙被變成提問題後，daily流程中在問阻礙前多了開放提問。從這些流程的小地方可以看到「改變與改善」，我覺得這才是agile精神真正的作為。</p>\n<p>而retrospective，我不知道為什麼就是很難在那個當下做出反應，很難順著遊戲規則去想，常常腦袋一片空白。有點像是，不是對跑scrum沒什麼想法，而是我在那個當下就是對遊戲規則反應不過來的沒進入狀況。這可能是因為我還在收上個project的尾，對正在進行的story只出一張嘴，所以很難知道到底碰到什麼狀況。另一個可能的原因是，我在某些遊戲規則或者引導下需要比較長時間進入狀況，因為在其他場合也多次出現類似的情形。</p>\n<p>說完實際上運作的種種，來談談精神層面(?)。agile的基本精神──因應改變而改變──我是認同的，可是沒辦法相信宣稱agile就是真正的agile。精神固然重要，但現階段實際做法是不是符合那精神更重要，否則都只是披著agile的皮的不知道什麼東西。<del>講不知道什麼東西已經是好聽了，基於對台灣資方的不信任感，我覺得很容易是披著agile的皮的壓榨……</del></p>\n<p>同樣一句話十個人聽都可以有十種解釋了，而agile的精神違反物理定律「慣性」(咦?)，我不認為每個人理解跟認知的agile精神就真的是其精神的內涵（對，連我自己都可能不是真的理解）。「聽其言，觀其行」比較準確，與其聽人宣稱不如直接檢視實際作為。人的行為到這個年紀基本上會有某些pattern，這種東西不會一下子說變就變，是可以從各方面跟小地方觀察到些什麼的。</p>\n<p>最後，說到改變，agile說改變改變但不是隨便亂變。</p>\n<p>scrum流程裡sprint中間不能隨便亂改要做的事，這是改變中的「不變」。變動越大越頻繁，越需要某程度的不變去作為穩定跟結構，這是讓人知道什麼時間點會做調整、什麼時候不會動而能安心做事，否則沒有規則的亂變會導致無所適從或者直接暴衝。變動充滿不確定性，但是人會想要控制感，這是人性，不斷改變帶來的是許多不確定感，而在這之中的不變跟些許規則是讓人能知道有什麼是能夠掌握的。雖然不知道背後緣由，但我想scrum規範這樣的流程是有其原因的。</p>\n","tags":["Murmur"]},{"title":"select()","url":"/select/","content":"<p>由 kernel 注意某些 fd 是否 active（readable、writable 及有 error），有則 return 讓 application process 對 active 的 fd 做相應的處理。用 <code>select()</code> 可避免 application process 去 polling 看各個 socket 是否 active、浪費 CPU 資源。如果沒有 fd active、沒設 timeout、沒有 signal 打斷，<code>select()</code> 是 blocking。</p>\n<p>正常狀況下 <code>select()</code> return 三個 fdset 共有多少 fd active。timeout 時 return 0。收到 signal return -1 且 errno 設為 <code>EINTR</code>，不會測試 fd 也不會修改 fd_set，所以不能用 fd 判斷是否 active。<code>select()</code> 之所以在被 signal 打斷時不修改 fd_set，是為了避免 <code>select()</code> 跟 signal handler 不斷修改同一個 flag 造成 infinite loop。例如 <code>select()</code> 發現某 flag 是 0 會將 flag 設為 1，而某個 signal handler 遇到 flag 是 1 又把 flag 設為 0，沒完沒了。</p>\n<p><code>pselect()</code> 可設定擋住哪些 signal，讓這些 signal 不打斷 <code>pselect()</code>。</p>\n<h2 id=\"Sample-Code\"><a href=\"#Sample-Code\" class=\"headerlink\" title=\"Sample Code\"></a>Sample Code</h2><figure class=\"highlight arduino\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;sys/types.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;sys/socket.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;sys/time.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;arpa/inet.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;unistd.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;cstring&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;cstdlib&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;errno.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;set&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> MAXBUF 1000</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">(<span class=\"keyword\">int</span> listenPort, <span class=\"keyword\">int</span> qlen)</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">CreateListenSock</span><span class=\"params\">(<span class=\"keyword\">int</span> listenPort, <span class=\"keyword\">int</span> qlen)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">run</span>(<span class=\"number\">8899</span>, <span class=\"number\">5</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">(<span class=\"keyword\">int</span> listenPort, <span class=\"keyword\">int</span> qlen)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    fd_set afdset, rfdset, wfdset, efdset;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> listenfd = CreateListenSock(listenPort, qlen);</span><br><span class=\"line\">    <span class=\"keyword\">int</span> maxfd = listenfd;</span><br><span class=\"line\">    <span class=\"built_in\">set</span>&lt;<span class=\"keyword\">int</span>&gt; fds;</span><br><span class=\"line\">    <span class=\"keyword\">bool</span> bNeedWrite = <span class=\"literal\">false</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    FD_ZERO(&amp;afdset); FD_ZERO(&amp;rfdset); FD_ZERO(&amp;wfdset); FD_ZERO(&amp;efdset);</span><br><span class=\"line\">    FD_SET(listenfd, &amp;afdset);</span><br><span class=\"line\"></span><br><span class=\"line\">    fds.insert(listenfd);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (<span class=\"literal\">true</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> iActive = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">timeval</span> <span class=\"title\">timeout</span>;</span></span><br><span class=\"line\"></span><br><span class=\"line\">        rfdset = afdset;</span><br><span class=\"line\">        efdset = afdset;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (bNeedWrite)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            wfdset = afdset;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span></span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            FD_ZERO(&amp;wfdset);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        timeout.tv_sec = <span class=\"number\">3</span>;</span><br><span class=\"line\">        timeout.tv_usec = <span class=\"number\">0</span>;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">if</span> ((iActive = select(maxfd + <span class=\"number\">1</span>, &amp;rfdset, &amp;wfdset, &amp;efdset, &amp;timeout)) == <span class=\"number\">-1</span>)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"comment\">// handle error</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (errno == EINTR)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">else</span></span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span></span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> iHandled = <span class=\"number\">0</span>;</span><br><span class=\"line\">            <span class=\"built_in\">set</span>&lt;<span class=\"keyword\">int</span>&gt;::iterator fdIter = fds.<span class=\"built_in\">begin</span>();</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (; fdIter != fds.<span class=\"built_in\">end</span>() &amp;&amp; iHandled &lt; iActive; ++fdIter)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                <span class=\"keyword\">int</span> fd = *fdIter;</span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (FD_ISSET(fd, &amp;rfdset))</span><br><span class=\"line\">                &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (fd == listenfd)</span><br><span class=\"line\">                    &#123;</span><br><span class=\"line\">                        <span class=\"comment\">// handle new connection</span></span><br><span class=\"line\">                        <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">sockaddr_in</span> <span class=\"title\">cliaddr</span>;</span></span><br><span class=\"line\">                        <span class=\"keyword\">socklen_t</span> cliaddrlen = <span class=\"keyword\">sizeof</span>(cliaddr);</span><br><span class=\"line\"></span><br><span class=\"line\">                        bzero((<span class=\"keyword\">char</span> *)&amp;cliaddr, <span class=\"keyword\">sizeof</span>(cliaddr));</span><br><span class=\"line\"></span><br><span class=\"line\">                        <span class=\"keyword\">int</span> connfd = accept(listenfd, (struct sockaddr *)&amp;cliaddr, &amp;cliaddrlen);</span><br><span class=\"line\"></span><br><span class=\"line\">                        fds.insert(connfd);</span><br><span class=\"line\">                        FD_SET(connfd, &amp;afdset);</span><br><span class=\"line\">                        <span class=\"keyword\">if</span> (connfd &gt; maxfd)</span><br><span class=\"line\">                        &#123;</span><br><span class=\"line\">                            maxfd = connfd;</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                    <span class=\"keyword\">else</span></span><br><span class=\"line\">                    &#123;</span><br><span class=\"line\">                        <span class=\"comment\">// handle read</span></span><br><span class=\"line\">                        <span class=\"keyword\">char</span> readBuf[MAXBUF];</span><br><span class=\"line\">                        <span class=\"keyword\">int</span> iRead = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">                        bzero(readBuf, MAXBUF);</span><br><span class=\"line\"></span><br><span class=\"line\">                        <span class=\"keyword\">if</span> ((iRead = <span class=\"built_in\">read</span>(fd, &amp;readBuf, MAXBUF - <span class=\"number\">1</span>)) &gt; <span class=\"number\">0</span>)</span><br><span class=\"line\">                        &#123;</span><br><span class=\"line\">                            readBuf[iRead] = <span class=\"number\">0</span>;</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (iRead == <span class=\"number\">0</span>)</span><br><span class=\"line\">                        &#123;</span><br><span class=\"line\">                            <span class=\"built_in\">close</span>(fd);</span><br><span class=\"line\">                            FD_CLR(fd, &amp;afdset);</span><br><span class=\"line\">                            fds.erase(fd);</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                        <span class=\"keyword\">else</span></span><br><span class=\"line\">                        &#123;</span><br><span class=\"line\">                            <span class=\"comment\">// handle read error</span></span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">                    iHandled++;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (FD_ISSET(fd, &amp;wfdset))</span><br><span class=\"line\">                &#123;</span><br><span class=\"line\">                    <span class=\"comment\">// handle write</span></span><br><span class=\"line\">                    iHandled++;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (FD_ISSET(fd, &amp;efdset))</span><br><span class=\"line\">                &#123;</span><br><span class=\"line\">                    <span class=\"comment\">// handle error</span></span><br><span class=\"line\">                    iHandled++;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">CreateListenSock</span><span class=\"params\">(<span class=\"keyword\">int</span> listenPort, <span class=\"keyword\">int</span> qlen)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">sockaddr_in</span> <span class=\"title\">servAddr</span>;</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> listenfd = <span class=\"number\">-1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> ((listenfd = socket(AF_INET, SOCK_STREAM, <span class=\"number\">0</span>)) &lt; <span class=\"number\">0</span>) </span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"built_in\">cerr</span> &lt;&lt; <span class=\"string\">\"Create socket failed\"</span> &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">        <span class=\"built_in\">exit</span>(<span class=\"number\">1</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    bzero((<span class=\"keyword\">char</span> *)&amp;servAddr, <span class=\"keyword\">sizeof</span>(servAddr));</span><br><span class=\"line\">    servAddr.sin_family = AF_INET;</span><br><span class=\"line\">    servAddr.sin_addr.s_addr = htonl(INADDR_ANY);</span><br><span class=\"line\">    servAddr.sin_port = htons(listenPort);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (bind(listenfd, (struct sockaddr *)&amp;servAddr, <span class=\"keyword\">sizeof</span>(servAddr)) &lt; <span class=\"number\">0</span>) </span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"built_in\">cerr</span> &lt;&lt; <span class=\"string\">\"Bind socket failed\"</span> &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">        <span class=\"built_in\">exit</span>(<span class=\"number\">1</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">listen</span>(listenfd, qlen);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> listenfd;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","tags":["Programming","Linux"]},{"title":"Clone 已有 Octopress blog","url":"/set-up-existing-octopress-blog/","content":"<p>Octopress 的後端就是自己的電腦，有多台電腦時需要在其他電腦再建立 Octopress 的撰寫環境，並且拿 Github 上面的 repos 下來繼續寫。</p>\n<h2 id=\"安裝環境\"><a href=\"#安裝環境\" class=\"headerlink\" title=\"安裝環境\"></a>安裝環境</h2><p>基本環境：<a href=\"http://msysgit.github.io/\" target=\"_blank\" rel=\"noopener\">Git for Windows</a>、<a href=\"http://rubyinstaller.org/downloads\" target=\"_blank\" rel=\"noopener\">RubyInstaller 1.9.3</a>、<a href=\"http://rubyinstaller.org/downloads\" target=\"_blank\" rel=\"noopener\">Ruby Development kit</a>。如果用到 code highlight，要裝 <a href=\"https://www.python.org/\" target=\"_blank\" rel=\"noopener\">Python 2</a>，否則 <code>rake generate</code> 會生出空白頁。安裝完 Ruby 跟 Python 要在環境變數 PATH 加入 Ruby 的 bin 資料夾路徑以及 Python 的安裝路徑，如 <code>C:\\Ruby193\\bin</code> 及 <code>C:\\Python27</code>。</p>\n<h2 id=\"Clone-repository\"><a href=\"#Clone-repository\" class=\"headerlink\" title=\"Clone repository\"></a>Clone repository</h2><figure class=\"highlight asciidoc\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ git clone -b source <span class=\"link\">https://github.com/</span>[<span class=\"string\">username</span>]/[username].github.io octopress</span><br><span class=\"line\"></span><br><span class=\"line\">$ cd octopress</span><br><span class=\"line\">$ git clone <span class=\"link\">https://github.com/</span>[<span class=\"string\">username</span>]/[username].github.io <span class=\"emphasis\">_deploy</span></span><br></pre></td></tr></table></figure>\n\n<p>Octopress 將 master branch 放在 <code>_deploy/</code>。</p>\n<h2 id=\"Rake-installation-and-configuration\"><a href=\"#Rake-installation-and-configuration\" class=\"headerlink\" title=\"Rake installation and configuration\"></a>Rake installation and configuration</h2><figure class=\"highlight mipsasm\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ gem <span class=\"keyword\">install </span><span class=\"keyword\">bundler</span></span><br><span class=\"line\"><span class=\"keyword\">$ </span><span class=\"keyword\">bundle </span><span class=\"keyword\">install</span></span><br><span class=\"line\"><span class=\"keyword\">$ </span>rake setup_github_pages</span><br></pre></td></tr></table></figure>\n\n<p>最後一個指令會要求輸入 Github 的 repository URL。</p>\n<h2 id=\"Pull-repository\"><a href=\"#Pull-repository\" class=\"headerlink\" title=\"Pull repository\"></a>Pull repository</h2><p>有多台電腦編輯時，開始前要記得將 local repository 更新到最新。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> git pull origin <span class=\"built_in\">source</span></span></span><br><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> <span class=\"built_in\">cd</span> _deploy</span></span><br><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> git pull origin master</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Ref\"><a href=\"#Ref\" class=\"headerlink\" title=\"Ref\"></a>Ref</h2><ul>\n<li><a href=\"http://blog.zerosharp.com/clone-your-octopress-to-blog-from-two-places/\" target=\"_blank\" rel=\"noopener\">http://blog.zerosharp.com/clone-your-octopress-to-blog-from-two-places/</a></li>\n</ul>\n","tags":["Blog","Octopress"]},{"title":"Singleton Pattern","url":"/singleton/","content":"<p>屬於 Creational pattern。</p>\n<p>確保 class 只有一個 instance，並且給它 global 的存取點。</p>\n<p>可以做到延後產生 instance，也就是真正使用到時才 create instance。如果用 global variable，依據不同語言及實作的特性可能在程式一開始就產生 instance。</p>\n<p>常用來管理 shared resource。</p>\n<h2 id=\"做法\"><a href=\"#做法\" class=\"headerlink\" title=\"做法\"></a>做法</h2><ul>\n<li>將 constructor、copy constructor、destructor、assignment operator 宣告為 private 確保外面無法產生第二個 instance 及 destory instance。</li>\n<li>使用 static function 讓外界取得唯一的 instance。</li>\n</ul>\n<h2 id=\"C-實作\"><a href=\"#C-實作\" class=\"headerlink\" title=\"C++ 實作\"></a>C++ 實作</h2><figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Singleton</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">static</span> Singleton* <span class=\"title\">GetSingleton</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    Singleton() &#123; <span class=\"comment\">/* implement */</span> &#125;;</span><br><span class=\"line\">    ~Singleton();</span><br><span class=\"line\">    Singleton(<span class=\"keyword\">const</span> Singleton&amp;);</span><br><span class=\"line\">    Singleton&amp; <span class=\"keyword\">operator</span>=(<span class=\"keyword\">const</span> Singleton&amp;);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\">Singleton* <span class=\"title\">Singleton::GetSingleton</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">static</span> Singleton* pSingleton = <span class=\"keyword\">new</span> Singleton();</span><br><span class=\"line\">    <span class=\"keyword\">return</span> pSingleton;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>外面要取得 instance 時 call <code>Singleton::GetSingleton()</code>。這邊直接用 C++ 的 static local variable 在 function 第一次 call 時會 initialize 之後不會再 initialize 的特性，而它的 lifetime 會持續到程式結束。</p>\n<p>有另一種做法是 <code>GetSingleton()</code> 不 return pointer，而 return reference。</p>\n<p>這個實作沒有 thread-safe，有多個 thread 會 call <code>GetSingleton()</code> 就 GG 了。要 thread-safe 可以用 double-checked locking。</p>\n<h2 id=\"Ref\"><a href=\"#Ref\" class=\"headerlink\" title=\"Ref\"></a>Ref</h2><ul>\n<li><a href=\"http://charlesbc.blogspot.tw/2009/04/design-pattern-singleton.html\" target=\"_blank\" rel=\"noopener\">http://charlesbc.blogspot.tw/2009/04/design-pattern-singleton.html</a></li>\n<li><a href=\"http://stackoverflow.com/questions/1008019/c-singleton-design-pattern\" target=\"_blank\" rel=\"noopener\">http://stackoverflow.com/questions/1008019/c-singleton-design-pattern</a></li>\n<li><a href=\"http://stackoverflow.com/questions/6223355/static-variables-in-class-methods\" target=\"_blank\" rel=\"noopener\">http://stackoverflow.com/questions/6223355/static-variables-in-class-methods</a></li>\n</ul>\n","tags":["Design Pattern"]},{"title":"手動驗證與 unit test","url":"/small-test-by-hand-and-unit-test/","content":"<p>很久很久以前<del>（講得好像很老一樣）</del>，剛學寫程式的時候，我有個習慣是寫一點點就會執行起來看對不對。在那個連用迴圈做輸入都不太熟的超新手時期，連輸入都會做這種「測試」。這習慣延續了很久，直到現在，在剛開始學一個新語言或者環境許可的狀況下（編得過、可以跑、測起來不會太複雜），還是會這樣──寫一點點就跑起來看對不對。</p>\n<p>今天晚上寫小玩具的時候，新語言嘛，不熟，就又出現這種習慣。就在我還沒把程式 run 下去、正覺得這種驗證很囉唆的電光石火(?)之間，我突然想到──幹嘛不把這種驗證寫成 unit test 就好？這樣就不用跑很多次、人眼校對很多次了啊！</p>\n<p>於是乎，這次改變方式，先把要寫的東西全部寫完，再寫 unit test，直接 run unit test 看 code 有沒有寫對。在這種很瑣碎但又得確認是對的事情上，用 unit test 真是神清氣爽啊！雖然不知道之後重複利用的機會多大，但是不用在那裡對到快脫窗真好。也還真給我抓到一個漏掉 assign 的 member…</p>\n<p>看來我的寫 code 方式終於跟 test 連上了一點，不然每次想要硬套 TDD 之類的時候，就像學了個新方法，可是並沒有改變舊習慣，兩邊有點接不起來。這次是注意到舊習慣<del>令人厭煩</del>可以改善的地方，再套一點新東西進去變成好一點的方式。</p>\n<p>最近在想，獨立開發的時候，更該利用自動化測試減少花在重複性工作上的時間。我想，運用科技讓人能更妥善運用時間，才是科技的本意吧。</p>\n","tags":["Murmur"]},{"title":"解決執行 Servo 只有白畫面問題","url":"/solve-servo-blank/","content":"<p>build 好 servo 之後執行 <code>./mach run -d tests/html/about-mozilla.html</code> 視窗只出現白白的畫面。這怎麼看都不正常啊……ˊ（´;ω;｀)</p>\n<h2 id=\"環境\"><a href=\"#環境\" class=\"headerlink\" title=\"環境\"></a>環境</h2><ul>\n<li>LMDE 2 Cinnamon 64 bits</li>\n<li>NVIDIA GeForce GTS 250</li>\n<li>kernel 3.16.0-4-amd64</li>\n</ul>\n<h2 id=\"各種測試\"><a href=\"#各種測試\" class=\"headerlink\" title=\"各種測試\"></a>各種測試</h2><p>build release 版後 <code>./mach run -r tests/html/about-mozilla.html</code> 跟從 <a href=\"https://download.servo.org/\" target=\"_blank\" rel=\"noopener\">https://download.servo.org/</a> 抓 pre-built 版都白白的。</p>\n<p>用 gdb 跑跑看</p>\n<figure class=\"highlight routeros\"><table><tr><td class=\"code\"><pre><span class=\"line\">./mcah <span class=\"builtin-name\">run</span> -d --debug</span><br><span class=\"line\">gdb&gt; r tests/html/about-mozilla.html</span><br><span class=\"line\"><span class=\"built_in\">..</span>.blahblah</span><br></pre></td></tr></table></figure>\n\n<p>所以有在動啊……</p>\n<p><code>./mach run -d tests/html/about-mozilla.html -o output.png</code> 輸出圖檔，圖片也是一片白。</p>\n<p>update 系統再 try 也不行。</p>\n<p>用 VM LMDE 跑 pre-built 出現其他 error <code>0:1(10): error: GLSL 1.50 is not supported. Supported versions are 1.10, 1.20, 1.30, 1.00 ES, and 3.00 ES</code>，<a href=\"https://github.com/servo/servo/issues/11124\" target=\"_blank\" rel=\"noopener\">可能跟 VM 沒 support OpenGL 有關</a>，有點岔題所以不管。</p>\n<p>另一台電腦 Ubuntu 跑 pre-built，正常。</p>\n<h2 id=\"猜猜樂\"><a href=\"#猜猜樂\" class=\"headerlink\" title=\"猜猜樂\"></a>猜猜樂</h2><p>pre-built 不會動表示不是我 build 的有問題。猜是 render 有問題，測輸出圖檔也不行，應該八九不離十是 render 問題。google 看不出所以然，Ubuntu 是好的但應該不至於 Ubuntu 可以 LMDE 卻不能用。</p>\n<p>畫不出來，不然更新看看 driver。</p>\n<p>先說結果，猜中了。(′‧ω‧‵)</p>\n<h2 id=\"檢查顯卡型號-amp-driver\"><a href=\"#檢查顯卡型號-amp-driver\" class=\"headerlink\" title=\"檢查顯卡型號 &amp; driver\"></a>檢查顯卡型號 &amp; driver</h2><figure class=\"highlight angelscript\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ lspci | grep VGA</span><br><span class=\"line\"><span class=\"number\">01</span>:<span class=\"number\">00.0</span> VGA compatible controller: NVIDIA Corporation G92 [GeForce GTS <span class=\"number\">250</span>] (rev a2)</span><br></pre></td></tr></table></figure>\n<p>看顯卡型號。</p>\n<figure class=\"highlight routeros\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ glxinfo | OpenGL</span><br><span class=\"line\">OpenGL vendor string: NVIDIA Corporation</span><br><span class=\"line\">OpenGL renderer string: GeForce GTS 250/PCIe/SSE2</span><br><span class=\"line\">OpenGL core<span class=\"built_in\"> profile </span>version string: 3.3.0 NVIDIA 340.101</span><br><span class=\"line\">OpenGL core<span class=\"built_in\"> profile </span>shading language version string: 3.30 NVIDIA via Cg compiler</span><br><span class=\"line\">OpenGL core<span class=\"built_in\"> profile </span>context flags: (none)</span><br><span class=\"line\">OpenGL core<span class=\"built_in\"> profile profile </span>mask: core profile</span><br><span class=\"line\">OpenGL core<span class=\"built_in\"> profile </span>extensions:</span><br><span class=\"line\">OpenGL version string: 3.3.0 NVIDIA 340.101</span><br><span class=\"line\">OpenGL shading language version string: 3.30 NVIDIA via Cg compiler</span><br><span class=\"line\">OpenGL context flags: (none)</span><br><span class=\"line\">OpenGL<span class=\"built_in\"> profile </span>mask: (none)</span><br><span class=\"line\">OpenGL extensions:</span><br><span class=\"line\">OpenGL ES<span class=\"built_in\"> profile </span>version string: OpenGL ES 2.0 NVIDIA 340.101 340.101</span><br><span class=\"line\">OpenGL ES<span class=\"built_in\"> profile </span>shading language version string: OpenGL ES GLSL ES 1.00</span><br><span class=\"line\">OpenGL ES<span class=\"built_in\"> profile </span>extensions:</span><br></pre></td></tr></table></figure>\n\n<p>看顯卡 driver，這是已經換成 NVIDIA driver 的結果。如果 <code>OpenGL renderer string</code> 出現 Mesa 之類的表示不是用 NVIDIA 的 driver。</p>\n<h2 id=\"更新顯卡-driver\"><a href=\"#更新顯卡-driver\" class=\"headerlink\" title=\"更新顯卡 driver\"></a>更新顯卡 driver</h2><p>為了更新顯卡搞了半天……總結如下。</p>\n<p><a href=\"http://www.nvidia.com/Download/index.aspx?lang=en-us\" target=\"_blank\" rel=\"noopener\">抓 NVIDIA driver</a>。</p>\n<p>修改 <code>/etc/default/grub</code>：<code>GRUB_CMDLINE_LINUX_DEFAULT=&quot;nouveau.blacklist=1 quiet splash text&quot;</code>，之後</p>\n<figure class=\"highlight powershell\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"variable\">$</span> sudo <span class=\"built_in\">update-grub</span></span><br><span class=\"line\"><span class=\"variable\">$</span> sudo <span class=\"built_in\">update-initramfs</span></span><br><span class=\"line\"><span class=\"variable\">$</span> sudo reboot</span><br></pre></td></tr></table></figure>\n\n<p><code>nouveau.blacklist=1</code> 是 disable nouveau，nouveau 是 open source 社群做的 NVIDIA 顯卡的 driver。</p>\n<p><code>text</code> 則是開機不進 GUI，因為得關掉 X server 才能裝 driver，乾脆直接進文字模式裝。我以為是改 run level，但是 google 到一堆都這樣搞就這樣了。有人說用 recovery mode 也可以裝 driver，不過我沒試。</p>\n<p>從 NVIDIA 抓下 <code>NVIDIA-Linux-x86_64-340.101.run</code>，是個 script，要用 root 權限跑。</p>\n<figure class=\"highlight vala\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\"># export CC=gcc-4.8</span></span><br><span class=\"line\"><span class=\"meta\"># sh NVIDIA-Linux-x86_64-340.101.run</span></span><br></pre></td></tr></table></figure>\n\n<p>需要設 <code>CC</code> 是因為我 gcc 預設版本是 4.9，但是 compile driver 需要 4.8。</p>\n<p>安裝過程是 console 的互動介面（忘記這叫什麼了啦）就不細寫了。中間有問要不要 build 成什麼 module 之類的，選 yes 會 fail，懶得研究那是什麼東西，用 no 就安裝成功了。</p>\n<p>最後，修改 <code>/etc/default/grub</code> 以 GUI 開機：<code>GRUB_CMDLINE_LINUX_DEFAULT=&quot;nouveau.blacklist=1 quiet splash&quot;</code> 再 update grub 跟 reboot。</p>\n<p>開 servo 終於正常了…\\T_T/</p>\n<h2 id=\"Ref\"><a href=\"#Ref\" class=\"headerlink\" title=\"Ref\"></a>Ref</h2><ul>\n<li><a href=\"http://www.cgl.ucsf.edu/chimera/graphics/updatelinux.html\" target=\"_blank\" rel=\"noopener\">http://www.cgl.ucsf.edu/chimera/graphics/updatelinux.html</a></li>\n</ul>\n","tags":["Linux","Servo"]},{"title":"以 QMap 做 sort","url":"/sort-by-qmap/","content":"<p>QMap 內的資料會以 key 的值 sort 好。以自訂 class 或 struct 作為 key 需要提供 <code>operator&lt;</code>。所以將資料 insert 進 QMap，再用 iterator 取出就可以做到 sorting。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\">QMap&lt;<span class=\"keyword\">int</span>, QString&gt; sortMap;</span><br><span class=\"line\"></span><br><span class=\"line\">sortMap.insert(<span class=\"number\">31</span>, <span class=\"string\">\"31\"</span>);</span><br><span class=\"line\">sortMap.insert(<span class=\"number\">3</span>, <span class=\"string\">\"3\"</span>);</span><br><span class=\"line\">sortMap.insert(<span class=\"number\">2</span>, <span class=\"string\">\"2\"</span>);</span><br><span class=\"line\">sortMap.insert(<span class=\"number\">5</span>, <span class=\"string\">\"5\"</span>);</span><br><span class=\"line\">sortMap.insert(<span class=\"number\">7</span>, <span class=\"string\">\"7\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span> (QMap&lt;<span class=\"keyword\">int</span>, QString&gt;::iterator iter = sortMap.begin(); iter != sortMap.end(); ++iter)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"comment\">// sorted</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n<p>key 有多個欄位時可以做到不同欄位有不同 priority 的能力，如：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">bool</span> <span class=\"keyword\">operator</span>&lt;(<span class=\"keyword\">const</span> XXX&amp; rhs) <span class=\"keyword\">const</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (fieldA != rhs.fieldA)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> fieldA &lt; rhs.fieldA;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (fieldB != rhs.fieldB)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> fieldB &lt; rhs.fieldB;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>這表示在比較上，fieldA 的 priority 比 fieldB 高，也就是先比 fieldA 再比 fieldB。</p>\n<p><code>x &lt; y</code> 跟 <code>y &lt; x</code> 都為 false 時表示 <code>x == y</code>。</p>\n","tags":["C++","Qt"]},{"title":"如何測試 event","url":"/test-event/","content":"<p>測試 event 分成兩邊：</p>\n<ul>\n<li>測試 event listener：有沒有在 event 發生後做該做的事。</li>\n<li>測試 trigger event：有沒有正確 trigger event。</li>\n</ul>\n<p>基本概念是驗證一方時假造另一方。</p>\n<h2 id=\"測試-event-listener\"><a href=\"#測試-event-listener\" class=\"headerlink\" title=\"測試 event listener\"></a>測試 event listener</h2><p>檢查 event 有沒有註冊到 event listener。用「event 發生後 event listener 有沒有做該做的事」來驗證，而不是試圖 access class 的內部 event 資訊來看是否有註冊成功。例如發生 event 後系統某些狀態會改變，測試方式是在測試裡 trigger event（假造 trigger event），驗證系統狀態是否有正確改變。</p>\n<p>如果發生 event 後會 call 某些 third party function，測試方式是先做個 mock object、inject mock object 到被測試 class，接著 trigger event，最後驗證 mock object 是否有被 call 到該 call 的 function。</p>\n<h2 id=\"測試是否有-trigger-event\"><a href=\"#測試是否有-trigger-event\" class=\"headerlink\" title=\"測試是否有 trigger event\"></a>測試是否有 trigger event</h2><p>在測試中給要測試的 event 註冊一個假的 event listener，接著讓被測試 class 做應該要 trigger event 的事情，最後驗證假 event listener 有沒有被 call 到。</p>\n<p>驗證假 event listener 有沒有被 call 到不一定要用 mock object，也可以是假 event listener 在被 call 到時修改 test 裡的變數，最後直接驗證該變數，這跟語言支援有關。</p>\n<h3 id=\"test-framework-支援\"><a href=\"#test-framework-支援\" class=\"headerlink\" title=\"test framework 支援\"></a>test framework 支援</h3><p>有些 test framework 的支援「某個 event 是否有被 trigger 或 emit 的驗證」。</p>\n","tags":["Unit Test"]},{"title":"[Toy] GpxConcat","url":"/toy-gpxconcat/","content":"<p>把多個 .gpx 檔案接成一個檔的小工具，目前只支援從 <a href=\"http://www.endomondo.com/\" target=\"_blank\" rel=\"noopener\">Endomondo</a> 抓來的 gpx 檔，不確定這是不是 gpx 的固定格式。<del>UI 很醜我真的知道，拜託不要要求工程師的美感。</del></p>\n<p>使用方式：Add 新增要合併的 gpx 檔案，Del 刪掉。Up 跟 Down 排列 gpx 檔案的順序，結果檔中的內容會以檔案列表的順序排列。</p>\n<p>記錄一下寫這小玩具學到的東西：</p>\n<ul>\n<li>Parse XML by C++ with Pugixml</li>\n<li>Setup Qt develop environment with Qt Creator in Windows</li>\n<li>Usage of release in Github</li>\n<li>Deploy Qt application in Windows</li>\n</ul>\n","tags":["Toy"]},{"title":"Use case","url":"/use-case/","content":"<p>首先，來點文言文…</p>\n<blockquote>\n<p>A use case describes <strong>what</strong> your system does to accomplish a particular customer goal.</p>\n</blockquote>\n<blockquote>\n<p>use case 是捕捉新系統或軟體變更的潛在需求之技術。每個 use case 提供一或多個 scenario，傳達系統如何與 end user 或其他系統互動，完成特定目標。</p>\n</blockquote>\n<p>以上文言文看完我也不知道自己是不是知道它在寫什麼。(喂)</p>\n<p>白話文來說，use case 會寫出一堆使用這軟體的情境跟過程，藉由這些情境跟流程來描述軟體要做些什麼好達到客戶的目標。<del>（這樣有白話文一點嗎？）</del></p>\n<p>use case 描述軟體要<strong>「做什麼」（what）</strong>，而非描述「如何做」（how）。</p>\n<h2 id=\"組成-Use-case-的三部分\"><a href=\"#組成-Use-case-的三部分\" class=\"headerlink\" title=\"組成 Use case 的三部分\"></a>組成 Use case 的三部分</h2><ol>\n<li>clear value<br>軟體要幫客戶做的事，也是客戶的目標。</li>\n<li>starting and stoping point<br>use case 的開始及結束點<del>，總不會一直繞圈圈沒完沒了吧</del>。</li>\n<li>external initialtor<br>既然是軟體的使用流程，總有個開始「使用軟體」的人或其他系統。</li>\n</ol>\n<h2 id=\"Main-amp-Alternative-path\"><a href=\"#Main-amp-Alternative-path\" class=\"headerlink\" title=\"Main &amp; Alternative path\"></a>Main &amp; Alternative path</h2><p>main path 是當世界一片美好、沒有任何事情出錯時，使用者會遵循的使用流程。但通常世界不是那麼美好的，工程師的工作之一就是要找出這些不美好(?)，讓軟體也能妥妥善善的處理它。alternative path 即是在 use case 中負責描述及處理這些「出錯狀況」的使用流程。</p>\n<p>alternative path 可以是…</p>\n<ol>\n<li>完全替代原本的部分 path。遇到某個選擇時可以選 main path 繼續下去，也可以選 alternative path 做。<br>例如可以選吃飯或吃麵完成吃晚餐這件事。</li>\n<li>optional 的，用來處理額外、例外以及出錯的狀況。<br>例如想吃牛肉麵但沒開的時候該怎麼辦。</li>\n</ol>\n<h2 id=\"關於-Use-case\"><a href=\"#關於-Use-case\" class=\"headerlink\" title=\"關於 Use case\"></a>關於 Use case</h2><p>形式上沒有固定的限制，我通常會寫成流程步驟，不管形式如何，重點只有一個──看得懂、能正確表達意思。</p>\n<p>寫 use case 的時候會進到幾乎可以將 use case 裡的 logic 變成 code 的細節部分。</p>\n<p>use case 也要包含檢驗步驟，例如檢驗輸入是否合法、某個物件是否存在等等。</p>\n<h2 id=\"Textual-Analysis\"><a href=\"#Textual-Analysis\" class=\"headerlink\" title=\"Textual Analysis\"></a>Textual Analysis</h2><p>寫好 use case，然後咧？跟程式有什麼關係？這時候就是 textual analysis 上場的時候啦！</p>\n<p>分析 use case 裡的名詞及動詞，整理出 class 及 method 即為 texttual analysis。</p>\n<p>use case 中的名詞有可能是系統中的 class，動詞通常是 class 的 method。當然不是 use case 裡所有的名詞跟動詞都是 class 跟 method，所以需要經過分析，好決定要為那些名詞及動詞建立 class 跟 method。</p>\n<p>做完 textual analysis 決定要有哪些 class 跟 method 後，就可以進入設計物件跟物件間關係的階段了。</p>\n","tags":["OOAD"]},{"title":"驗證 Concurrent Algorithm","url":"/verification-of-concurrency/","content":"<p>設計 concurrent algorithm 後當然要確認正確性。在《Principles of Concurrent and Distributed Programming》中 Ben-Ari 定義了為驗證 concurrent algorithm 各種特性的抽象結構（concurrency abstraction），可分為以下四個部份：</p>\n<ul>\n<li>Programs are the execution of atomic statements.</li>\n<li>Concurrent programs are the interleavings of atomic statements from two or more threads.</li>\n<li>All possible interleavings of atomic statements must be shown to retain whatever property we are hoping to verify within a concurrent algorithm.</li>\n<li>No thread’s statement may be (unfairly) excluded from any arbitrary interleavings.</li>\n</ul>\n<a id=\"more\"></a>\n\n<p>一個個看。</p>\n<blockquote>\n<p>Programs are the execution of atomic statements.</p>\n</blockquote>\n<p>atomic statement 是無法再切成更小或無法中斷的 statement，語言層級從組合語言到高階語言都有。分析演算法時選擇可適合語言層級，通常用較 high-level 的語言，必要時才會用組合語言來分析。<em>（用組語分析複雜的演算法應該會想瘋掉）</em></p>\n<blockquote>\n<p>Concurrent programs are the interleavings of atomic statements from two or more threads.</p>\n</blockquote>\n<p>concurrent 程式由多個 thread 所執行的 statement 交錯而成。<em>（不知道除了翻譯還能說什麼…）</em></p>\n<blockquote>\n<p>All possible interleavings of atomic statements must be shown to retain whatever property we are hoping to verify within a concurrent algorithm.</p>\n</blockquote>\n<p>由於無法知道執行時 OS 如何做 scheduling，不能預設 thread 的 statement 會以何種順序執行，也不能假設每次執行的順序都相同。因此要驗證 concurrent algorithm 的特性，必須能說明 statement 以任何順序交錯執行，都能保有該特性，例如正確性。</p>\n<p>在兩個 thread 的情況下有四五個 statement 互相交錯就會有非常多種可能。通常證明演算法擁有某個特性只需要考慮多種交錯中的幾種情況，但需要說明為什麼不用驗證其他交錯情況。</p>\n<blockquote>\n<p>No thread’s statement may be (unfairly) excluded from any arbitrary interleavings.</p>\n</blockquote>\n<p>簡單講就是不會有 thread 被餓死。</p>\n<p>在各種交錯順序執行中，每個 thread 的 statement 總會被執行到，不會有 thread 的 statement 在某種執行順序情況下沒被跑到。OS 在分配執行時間給各 process 或 thread 時是公平的，每個 process 或 thread 都會分配到時間執行。</p>\n<p>至於程式執行過程中某些時候有些 thread 會無法執行，例如要等其他人做完，這是演算法特性，而非 concurrency abstraction 考量的問題。</p>\n<p>驗證 concurrent algorithm 跟找 concurrent 程式 bug（機率性、只在某些特定狀況下發生或者只發生一次就沒了）的基本方式一樣，只是驗證要完整。找 bug 至少要「找到出錯的那種執行順序」（更好是找完 bug 順便驗證一下），驗證正確性則要考慮所有情況下都是對的。所有執行順序交錯的情況太多，但可以分析演算法歸納出幾種情形，驗證這幾種情形都是正確的。</p>\n<p>具體作法是用腦袋或紙筆模擬兩個或多個 thread 以不同順序執行某些 statement 時會不會有問題，這些 statement 可以是多個 function 也可以是一個 function 內的某一段，通常問題出現在多 thread 共用 data（各種 container、state 等等）的 critical section，所以要看不同執行順序下，共用 data 會不會錯或者造成執行結果不如預期。</p>\n<p>燒腦(?)燒出了個可能有問題的執行順序後，如果不安心(?)要更確認，有時候可以用些<del>奇怪的</del>小技巧來複製或確認問題，例如用 breakpoint 之類的方式控制 thread 的執行順序、記錄 log（環境上無法複製或者就只出現那麼一兩次的很有用）、故意讓有問題的 code 跑很多次（loop 下去炸就對了，出現機率一般的 bug 通常就會壞了）。<em>（絕對不承認有時候我以炸 code 為樂）</em></p>\n<p>這邊雖然說 thread，但考慮程式交錯執行不限於狹義上的 thread，比較像考慮多個 executing thread，所以多個 process 會同時 access 相同檔案或資料庫也能用交錯執行來分析。<em>（資料庫是否「共用」要看資料庫本身對資料處理細到什麼程度，這類共用問題我只在遙遠的記憶中有個 keyword 叫 transaction，比較不清楚其他方式）</em></p>\n<p>這篇講的是驗證，但我目前為止還沒有很正式的去驗證過一個 concurrent algorithm，最多是找 bug 或者感應(?)一下會不會有問題。呃，感應，應該說需要一點經驗跟練習，會直覺大概知道有沒有問題，不過直覺當然不能當成正式驗證。</p>\n","tags":["Concurrency"]},{"title":"vim 常用功能","url":"/vim/","content":"<p>常用功能的 plugin 及快捷鍵：</p>\n<ul>\n<li>游標停在字上的時候會自動 highlight 同樣的字<br>開啟 vim 後輸入 <code>z/</code>，目前還沒找到怎麼一開 vim 就啟動自動 highlight。</li>\n<li>跳到游標所在 variable 或 function 的宣告</li>\n<li>在 .cpp 跟 .h 之間切換<br>a.vim (<code>:A</code>)</li>\n<li>跳到游標所在的 function 的定義<br>cscope (<code>ctrl+\\ g</code>)<br>ctags (<code>g]</code> or <code>ctrl+]</code>)</li>\n<li>跳到游標所在的 variable local 宣告<br>ctags (<code>gd</code>)</li>\n<li>跳到游標所在的 variable global 宣告<br>ctags (<code>gD</code>)</li>\n<li>全 project search<br>cscope (<code>ctrl+\\ t</code>)</li>\n<li>列出 file 中有哪些 function<br>taglist (<code>F8</code>)</li>\n<li>自動補齊<br>於 insert mode <code>ctrl + n</code></li>\n<li>自動補括號</li>\n<li>hex mode<br><code>:%! xxd</code></li>\n<li>切換 history<br><code>ctrl + i</code> &amp; <code>ctrl + o</code></li>\n<li>多行註解<br><code>ESC</code>、<code>ctrl + V</code> 選範圍、大寫 <code>I</code>、輸入註解符號、<code>ESC</code></li>\n<li>多行取消註解<br><code>ESC</code>、<code>ctrl + V</code> 選範圍、delete</li>\n</ul>\n<p>My <code>.vimrc</code>：<a href=\"https://github.com/cjwind/dotfiles/blob/master/vimrc\" target=\"_blank\" rel=\"noopener\">https://github.com/cjwind/dotfiles/blob/master/vimrc</a></p>\n<h2 id=\"ctags-taglist\"><a href=\"#ctags-taglist\" class=\"headerlink\" title=\"ctags taglist\"></a>ctags taglist</h2><p><code>$ sudo apt-get install ctags</code></p>\n<p>切到 project 資料夾產生 tag 資訊：</p>\n<p><code>$ ctags --extra=+f -R *</code></p>\n<p>加上 <code>--extra=+f</code> 可以在 vim 中使用 <code>:tag &lt;filename&gt;</code> 跳到該檔案，<code>:tag &lt;filename&gt;</code> 後再 <code>ctrl + t</code> 可回原本檔案。</p>\n<p>到 <a href=\"http://www.vim.org/scripts/script.php?script_id=273\" target=\"_blank\" rel=\"noopener\">http://www.vim.org/scripts/script.php?script_id=273</a> 抓 <code>taglist_45.zip</code>，解開後將 <code>taglist.vim</code> 放到 <code>~/vim/plugin</code>。</p>\n<p><code>~/.vimrc</code> 加入相關設定：</p>\n<figure class=\"highlight vim\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> Tlist_Ctags_Cmd = <span class=\"string\">'/usr/bin/ctags'</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> Tlist_Auto_Open = <span class=\"number\">1</span>     <span class=\"comment\">\" 讓 Tlist 自動開啟</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> Tlist_Show_One_File = <span class=\"number\">1</span>             <span class=\"comment\">\" 不同時顯示多個文件的tag，只顯示當前文件的</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> Tlist_Exit_OnlyWindow = <span class=\"number\">1</span>           <span class=\"comment\">\" 如果taglist窗口是最後一個窗口，則退出vim</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> Tlist_Use_Right_Window = <span class=\"number\">1</span>          <span class=\"comment\">\" 在右側窗口中顯示taglist窗口</span></span><br><span class=\"line\"><span class=\"keyword\">nnoremap</span> <span class=\"symbol\">&lt;silent&gt;</span> <span class=\"symbol\">&lt;F8&gt;</span> :TlistToggle<span class=\"symbol\">&lt;CR&gt;</span> <span class=\"comment\">\" F8 為開啟/關閉 Tlist 的快速鍵</span></span><br></pre></td></tr></table></figure>\n\n<p><code>ctrl + w</code> 再加方向鍵可以切換 window，例如加右鍵就是跳到右邊的 window。</p>\n<h3 id=\"patch\"><a href=\"#patch\" class=\"headerlink\" title=\"patch\"></a>patch</h3><p>有時候切換 tab 會出現 error <code>Taglist error: Error detected while processing function &lt;SNR&gt;29_Tlist_Refresh_Folds</code>，可用 <a href=\"http://vim.1045645.n5.nabble.com/attachment/3321902/0/taglist.diff\" target=\"_blank\" rel=\"noopener\">patch</a> 解決：<code>$ patch -p0 ~/.vim/plugin/taglist.vim taglist.diff</code></p>\n<h2 id=\"cscope\"><a href=\"#cscope\" class=\"headerlink\" title=\"cscope\"></a>cscope</h2><p><code>$ sudo apt-get install cscope</code></p>\n<p>切到 project 的資料夾產生 cscope 資料庫：</p>\n<p><code>$ cscope -RC</code></p>\n<p>之後用 vim 開啟 source code，可用 <code>:cs</code> 指令使用 cscope 的功能。也可以在 <code>~/.vim/plugin</code> 中放 <a href=\"http://cscope.sourceforge.net/cscope_maps.vim\" target=\"_blank\" rel=\"noopener\">cscope_map.vim</a> 加快捷鍵：</p>\n<figure class=\"highlight livescript\"><table><tr><td class=\"code\"><pre><span class=\"line\">ctrl+<span class=\"string\">\\</span> s <span class=\"string\">\"s表Symbol，列出所有參考到游標所在字串的地方，包含定義和呼叫。</span></span><br><span class=\"line\"><span class=\"string\">ctrl+\\ g \"</span>Find <span class=\"keyword\">this</span> definition</span><br><span class=\"line\">ctrl+<span class=\"string\">\\</span> c <span class=\"string\">\"c表Call，列出所有以游標所在字串當函數名的地方。</span></span><br><span class=\"line\"><span class=\"string\">ctrl+\\ t \"</span>t表Text，列出專案中所有出現游標所在字串的地方。</span><br><span class=\"line\">ctrl+<span class=\"string\">\\</span> f <span class=\"string\">\"f表File，以游標所在字串當檔名，開啟之。</span></span><br><span class=\"line\"><span class=\"string\">ctrl+\\ i \"</span>i表Include，以游標所在字串當檔名，列出所有include此檔的檔案。</span><br><span class=\"line\">ctrl+<span class=\"string\">\\</span> d <span class=\"string\">\"d表calleD，以游標所在字串當函式名，列出所有此函式呼叫的函式。</span></span><br></pre></td></tr></table></figure>\n\n\n<h2 id=\"自動-highlight\"><a href=\"#自動-highlight\" class=\"headerlink\" title=\"自動 highlight\"></a>自動 highlight</h2><p>在 <code>.vim/plugin</code> 加入 <code>autohighlight.vim</code>：</p>\n<figure class=\"highlight vim\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">\" Highlight all instances of word under cursor, when idle.</span></span><br><span class=\"line\"><span class=\"comment\">\" Useful when studying strange source code.</span></span><br><span class=\"line\"><span class=\"comment\">\" Type z/ to toggle highlighting on/off.</span></span><br><span class=\"line\"><span class=\"keyword\">nnoremap</span> <span class=\"keyword\">z</span>/ :<span class=\"keyword\">if</span> AutoHighlightToggle()<span class=\"symbol\">&lt;Bar&gt;</span><span class=\"keyword\">set</span> hls<span class=\"symbol\">&lt;Bar&gt;</span><span class=\"keyword\">endif</span><span class=\"symbol\">&lt;CR&gt;</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span>! <span class=\"title\">AutoHighlightToggle</span><span class=\"params\">()</span></span></span><br><span class=\"line\">  <span class=\"keyword\">let</span> @/ = <span class=\"string\">''</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> <span class=\"built_in\">exists</span>(<span class=\"string\">'#auto_highlight'</span>)</span><br><span class=\"line\">    au! auto_highlight</span><br><span class=\"line\">    augroup! auto_highlight</span><br><span class=\"line\">    <span class=\"keyword\">setl</span> updatetime=<span class=\"number\">4000</span></span><br><span class=\"line\">    <span class=\"keyword\">echo</span> <span class=\"string\">'Highlight current word: off'</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span></span><br><span class=\"line\">  <span class=\"keyword\">else</span></span><br><span class=\"line\">    <span class=\"keyword\">augroup</span> auto_highlight</span><br><span class=\"line\">      au!</span><br><span class=\"line\">      <span class=\"keyword\">au</span> CursorHold * <span class=\"keyword\">let</span> @/ = <span class=\"string\">'\\V\\&lt;'</span>.<span class=\"built_in\">escape</span>(<span class=\"built_in\">expand</span>(<span class=\"string\">'&lt;cword&gt;'</span>), <span class=\"string\">'\\'</span>).<span class=\"string\">'\\&gt;'</span></span><br><span class=\"line\">    <span class=\"keyword\">augroup</span> end</span><br><span class=\"line\">    <span class=\"keyword\">setl</span> updatetime=<span class=\"number\">500</span></span><br><span class=\"line\">    <span class=\"keyword\">echo</span> <span class=\"string\">'Highlight current word: ON'</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">1</span></span><br><span class=\"line\">  <span class=\"keyword\">endif</span></span><br><span class=\"line\"><span class=\"keyword\">endfunction</span></span><br></pre></td></tr></table></figure>\n\n<p>輸入 <code>z/</code> 可開關自動 highlight 的功能。</p>\n<p><a href=\"http://vim.wikia.com/wiki/Auto_highlight_current_word_when_idle\" target=\"_blank\" rel=\"noopener\">reference here</a></p>\n<h2 id=\"a-vim\"><a href=\"#a-vim\" class=\"headerlink\" title=\"a.vim\"></a>a.vim</h2><p>在 header 及 source 之間切換。<a href=\"http://www.vim.org/scripts/script.php?script_id=31\" target=\"_blank\" rel=\"noopener\">script</a></p>\n<p>切換指令為 <code>:A</code>。</p>\n<h2 id=\"自動補括號\"><a href=\"#自動補括號\" class=\"headerlink\" title=\"自動補括號\"></a>自動補括號</h2><p><a href=\"http://www.vim.org/scripts/script.php?script_id=3599\" target=\"_blank\" rel=\"noopener\">Auto Pairs</a></p>\n<p>將 script 放到 <code>~/.vim/plugin/</code> 底下。</p>\n<h2 id=\"Ref\"><a href=\"#Ref\" class=\"headerlink\" title=\"Ref\"></a>Ref</h2><ul>\n<li><a href=\"http://vim.wikia.com/wiki/Go_to_definition_using_g\" target=\"_blank\" rel=\"noopener\">http://vim.wikia.com/wiki/Go_to_definition_using_g</a></li>\n</ul>\n","tags":["Linux","Tip"]},{"title":"Visual Studio Code","url":"/vscode/","content":"<h2 id=\"Build-amp-Debug-C\"><a href=\"#Build-amp-Debug-C\" class=\"headerlink\" title=\"Build &amp; Debug C++\"></a>Build &amp; Debug C++</h2><p>安裝 extension <code>C/C++</code> (<code>ms-vscode.cpptools</code>)。</p>\n<h3 id=\"Build\"><a href=\"#Build\" class=\"headerlink\" title=\"Build\"></a>Build</h3><p><code>ctrl + ship + p</code> 輸入 <code>tasks</code>，選擇 <code>Configure Task</code>，選個 template 來改。或者直接在 <code>.vscode/</code> 下新增 <code>tasks.json</code>：</p>\n<figure class=\"highlight json\"><table><tr><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"comment\">// See https://go.microsoft.com/fwlink/?LinkId=733558</span></span><br><span class=\"line\">    <span class=\"comment\">// for the documentation about the tasks.json format</span></span><br><span class=\"line\">    <span class=\"attr\">\"version\"</span>: <span class=\"string\">\"2.0.0\"</span>,</span><br><span class=\"line\">    <span class=\"attr\">\"tasks\"</span>: [</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"attr\">\"label\"</span>: <span class=\"string\">\"build\"</span>,</span><br><span class=\"line\">            <span class=\"attr\">\"type\"</span>: <span class=\"string\">\"shell\"</span>,</span><br><span class=\"line\">            <span class=\"attr\">\"command\"</span>: <span class=\"string\">\"make\"</span>,</span><br><span class=\"line\">            <span class=\"attr\">\"args\"</span>: [</span><br><span class=\"line\">            ],</span><br><span class=\"line\">            <span class=\"attr\">\"group\"</span>: <span class=\"string\">\"build\"</span>,</span><br><span class=\"line\">            <span class=\"attr\">\"presentation\"</span>: &#123;</span><br><span class=\"line\">                <span class=\"attr\">\"reveal\"</span>: <span class=\"string\">\"silent\"</span></span><br><span class=\"line\">            &#125;,</span><br><span class=\"line\">            <span class=\"attr\">\"problemMatcher\"</span>: [</span><br><span class=\"line\">                <span class=\"string\">\"$gcc\"</span></span><br><span class=\"line\">            ]</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    ]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>這是有 <code>Makefile</code> 的設定方式，<code>command</code> 也可以用 <code>g++</code> 配合 <code>args</code>。</p>\n<h3 id=\"Debug\"><a href=\"#Debug\" class=\"headerlink\" title=\"Debug\"></a>Debug</h3><p>左邊切到 Debug 按上面的齒輪可以設定 <code>launch.json</code>，也可以直接在 <code>.vscode/</code> 下新增設定檔。</p>\n<figure class=\"highlight json\"><table><tr><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"comment\">// Use IntelliSense to learn about possible attributes.</span></span><br><span class=\"line\">    <span class=\"comment\">// Hover to view descriptions of existing attributes.</span></span><br><span class=\"line\">    <span class=\"comment\">// For more information, visit: https://go.microsoft.com/fwlink/?linkid=830387</span></span><br><span class=\"line\">    <span class=\"attr\">\"version\"</span>: <span class=\"string\">\"0.2.0\"</span>,</span><br><span class=\"line\">    <span class=\"attr\">\"configurations\"</span>: [</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"attr\">\"name\"</span>: <span class=\"string\">\"(gdb) Launch\"</span>,</span><br><span class=\"line\">            <span class=\"attr\">\"type\"</span>: <span class=\"string\">\"cppdbg\"</span>,</span><br><span class=\"line\">            <span class=\"attr\">\"request\"</span>: <span class=\"string\">\"launch\"</span>,</span><br><span class=\"line\">            <span class=\"attr\">\"program\"</span>: <span class=\"string\">\"$&#123;workspaceFolder&#125;/a.out\"</span>,\t\t<span class=\"comment\">// 指定執行檔</span></span><br><span class=\"line\">            <span class=\"attr\">\"args\"</span>: [],</span><br><span class=\"line\">            <span class=\"attr\">\"stopAtEntry\"</span>: <span class=\"literal\">false</span>,</span><br><span class=\"line\">            <span class=\"attr\">\"cwd\"</span>: <span class=\"string\">\"$&#123;workspaceFolder&#125;\"</span>,</span><br><span class=\"line\">            <span class=\"attr\">\"environment\"</span>: [],</span><br><span class=\"line\">            <span class=\"attr\">\"externalConsole\"</span>: <span class=\"literal\">true</span>,</span><br><span class=\"line\">            <span class=\"attr\">\"MIMode\"</span>: <span class=\"string\">\"gdb\"</span>,</span><br><span class=\"line\">            <span class=\"attr\">\"setupCommands\"</span>: [</span><br><span class=\"line\">                &#123;</span><br><span class=\"line\">                    <span class=\"attr\">\"description\"</span>: <span class=\"string\">\"Enable pretty-printing for gdb\"</span>,</span><br><span class=\"line\">                    <span class=\"attr\">\"text\"</span>: <span class=\"string\">\"-enable-pretty-printing\"</span>,</span><br><span class=\"line\">                    <span class=\"attr\">\"ignoreFailures\"</span>: <span class=\"literal\">true</span></span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            ],</span><br><span class=\"line\">            <span class=\"attr\">\"preLaunchTask\"</span>: <span class=\"string\">\"build\"</span>\t\t<span class=\"comment\">// debug 前要執行的 task, 對應 tasks.json 的 taskName</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    ]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>設定好之後按 F5 就可以 Debug 囉～</p>\n<p>breakpoint 只要在 code line number 左邊按出紅點點就可以啦～（<code>g++</code> 要記得 <code>-g</code>）</p>\n<h2 id=\"Extension\"><a href=\"#Extension\" class=\"headerlink\" title=\"Extension\"></a>Extension</h2><h3 id=\"workspace-推薦-extension\"><a href=\"#workspace-推薦-extension\" class=\"headerlink\" title=\"workspace 推薦 extension\"></a>workspace 推薦 extension</h3><p>在 <code>.vscode/</code> 底下加入 <code>extensions.json</code>，可以在裡面列推薦跟不推薦的 extension。</p>\n<figure class=\"highlight json\"><table><tr><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"comment\">// See http://go.microsoft.com/fwlink/?LinkId=827846 to learn about workspace recommendations.</span></span><br><span class=\"line\">    <span class=\"comment\">// Extension identifier format: $&#123;publisher&#125;.$&#123;name&#125;. Example: vscode.csharp</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// List of extensions which should be recommended for users of this workspace.</span></span><br><span class=\"line\">    <span class=\"attr\">\"recommendations\"</span>: [</span><br><span class=\"line\">        <span class=\"string\">\"ms-vscode.cpptools\"</span>,</span><br><span class=\"line\">        <span class=\"string\">\"donjayamanne.githistory\"</span></span><br><span class=\"line\">    ],</span><br><span class=\"line\">    <span class=\"comment\">// List of extensions recommended by VS Code that should not be recommended for users of this workspace.</span></span><br><span class=\"line\">    <span class=\"attr\">\"unwantedRecommendations\"</span>: [</span><br><span class=\"line\"></span><br><span class=\"line\">    ]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"Git-History\"><a href=\"#Git-History\" class=\"headerlink\" title=\"Git History\"></a>Git History</h3><p><code>ctrl + shift + p</code> 後打 <code>git h</code> 可以看 git log、file 跟 line history。</p>\n<p>選一個 commit 點下面的修改檔案還可以看 diff。</p>\n<h3 id=\"Sublime-Text-Keymap-and-Settings-Importer\"><a href=\"#Sublime-Text-Keymap-and-Settings-Importer\" class=\"headerlink\" title=\"Sublime Text Keymap and Settings Importer\"></a>Sublime Text Keymap and Settings Importer</h3><p>如果習慣 sublime 的 keymap 可以用這個 extension，其他還有 Visual Studio、Eclipse 等等的 keymap。</p>\n<h2 id=\"Troubleshooting\"><a href=\"#Troubleshooting\" class=\"headerlink\" title=\"Troubleshooting\"></a>Troubleshooting</h2><h3 id=\"檔案太多-vscode-無法-watch-changes\"><a href=\"#檔案太多-vscode-無法-watch-changes\" class=\"headerlink\" title=\"檔案太多 vscode 無法 watch changes\"></a>檔案太多 vscode 無法 watch changes</h3><p><a href=\"https://code.visualstudio.com/docs/setup/linux#_visual-studio-code-is-unable-to-watch-for-file-changes-in-this-large-workspace-error-enospc\" target=\"_blank\" rel=\"noopener\">這裡</a>說可以修改 <code>/etc/sysctl.conf</code>，加上：</p>\n<figure class=\"highlight ini\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">fs.inotify.max_user_watches</span>=<span class=\"number\">524288</span></span><br></pre></td></tr></table></figure>\n\n<p>然後下 <code>sudo sysctl -p</code> load 進設定。</p>\n<p>也可以設定 vscode 的 <code>files.watcherExclude</code> 來 exclude 一些不想 watch changes 的 folder。</p>\n<h2 id=\"Ref\"><a href=\"#Ref\" class=\"headerlink\" title=\"Ref\"></a>Ref</h2><ul>\n<li><a href=\"https://code.visualstudio.com/docs/editor/tasks\" target=\"_blank\" rel=\"noopener\">Integrate with External Tools via Tasks</a></li>\n<li><a href=\"https://ithelp.ithome.com.tw/articles/10190235\" target=\"_blank\" rel=\"noopener\">https://ithelp.ithome.com.tw/articles/10190235</a></li>\n</ul>\n","tags":["C++","vscode"]},{"title":"win10 與 linux 多重開機的糾葛(?)","url":"/win10-and-linux-dual-system-note/","content":"<p>原本電腦有用 UEFI 裝的 win7 跟 debian，用 grub2 開機。</p>\n<h2 id=\"多灌-win10\"><a href=\"#多灌-win10\" class=\"headerlink\" title=\"多灌 win10\"></a>多灌 win10</h2><p><del>其實從來沒搞懂 UEFI 在幹嘛，只知道比古早時代的 BIOS 新，然後常常造成我灌系統的困擾（喂）。</del></p>\n<p>這次用新硬碟裝 win10，原本用 legacy mode 裝起來，但 <code>update-grub</code> 抓不到，在 <code>/etc/grub.d/40_custom</code> 寫 google 來的各種 menuentry 也不行。改用 UEFI mode 裝 win10，它一下說找不到磁碟分割表（明明看起來就有），一下又說無法設定重開機所以不能裝，但明明我 BIOS 裡的 boot priority 已經選那顆新硬碟了（不過事後懷疑說不定應該要選 win7 的那顆才對）。在 BIOS 裡東調西調，從相容 legacy mode 換成 windows 8/10 又換成 windows 8/10 的另一種模式總算裝起來（裝完還把我 linux 那顆硬碟的 SATA port 關掉不知道是怎樣= =）。</p>\n<p>看起來 win10 把自己的開機區裝到原本 win7 的 UEFI 系統，所以不動原本 grub 設定的情況下，從原本開 win7 的 partition 進去，就可以再選 win10 或 win7 開機。只是如果要開 win7，它會再重開一次……= =a…..（後來懷疑說不定是因為 win10 預設不會「真關機」，所以某些情況下開 win7 會需要重開，不過只是猜測，沒試過）</p>\n<p>grub2 要加開機選項一般只要 <code>update-grub</code>。如果有自訂需求，到 <code>/etc/grub.d/</code> 底下手動加再 <code>update-grub</code>。</p>\n<h2 id=\"在-Linux-mount-成-read-only-的-NTFS\"><a href=\"#在-Linux-mount-成-read-only-的-NTFS\" class=\"headerlink\" title=\"在 Linux mount 成 read-only 的 NTFS\"></a>在 Linux mount 成 read-only 的 NTFS</h2><p>裝 win10 後的某天，我在 linux 裡要存檔案到原本 windows 下放資料的硬碟（理所當然的是 NTFS）。</p>\n<p>嗯？為什麼寫不進去？ro？為什麼變 ro 了？之前都可以 rw 啊。</p>\n<p><code>umount</code> 又 <code>mount</code> 了一陣，ro 就是 ro，錯誤訊息看起來是說 windows 休眠中，所以不給 mount rw 免得壞掉。</p>\n<p>蛤？？？windows 休眠中？？？可是我現在是開機成 linux 啊？？？哪來的 windows？？？感覺就是 win10 的錯（喂）。重開機進 win10，再重開進 linux，嗯？又好了？從 win10 關機，開機進 linux，又 ro。</p>\n<p><a href=\"https://www.howtogeek.com/236807/how-to-mount-your-windows-10-or-8-system-drive-on-linux/\" target=\"_blank\" rel=\"noopener\">這篇</a> 給了我答案。簡單來說，win10 的 shut down 不是真的 shut down，reboot 才會真的 shut down<del>（講人話）</del>。好吧，把那個快速啟動關掉，我也不差那幾秒。win10 關機，開機進 linux，耶，世界一片美好。</p>\n","tags":["Linux","Misc"]},{"title":"Dynamic Linking Basic","url":"/Dynamic-Linking-Basic/","content":"<h2 id=\"Static-Linking-的問題\"><a href=\"#Static-Linking-的問題\" class=\"headerlink\" title=\"Static Linking 的問題\"></a>Static Linking 的問題</h2><p>static link 拆分了可執行檔，讓不同人或組織可以開發自己的 module，最後再 link 成執行檔。隨著系統變複雜，OS 裡有多個 process 在執行，當多個 process 以 static linking 連結相同的 library 時，例如擁有 <code>printf()</code> 的 standard library，memory 會有多份類似的 library 程式碼，造成浪費。</p>\n<p>另一個問題是 static linking 不易更新 module。例如 App 這個程式用到 <code>Lib.o</code>，<code>Lib.o</code> 更新時（<code>Lib.o</code> 可能是別人提供的 module，App 開發者無法控制其版本），App 的開發者必須拿 <code>App.o</code> 跟 <code>Lib.o</code> 再 link 成新版 App，再給發佈新版 App。</p>\n<h2 id=\"Dynamic-Linking-基本概念\"><a href=\"#Dynamic-Linking-基本概念\" class=\"headerlink\" title=\"Dynamic Linking 基本概念\"></a>Dynamic Linking 基本概念</h2><p>為了解決 static link 在 memory 浪費以及不易更新的問題，最簡單的做法是將程式拆成多個 module，不在 compile 時期 link library，等到執行時才 link。如此一來就能只放一份共用 module 在 memory，需要該 module 的 executable file 就去 link。</p>\n<p>不過現實世界總是不那麼美好，dynamic linking 還是會遇到其他問題，例如如果 program A 需要 1.0 版的 module、program B 需要 2.0 版的 module，或者一個程式更新共用 module 之後，其他程式因為 interface 相依性問題就壞了。</p>\n<p>Linux 稱 ELF 動態連結檔為 Dynamic Shared Objects（DSO），簡稱 shared object，通常以 <code>.so</code> 為副檔名。Windows 則稱為 Dynamical Linking Library，以 <code>.dll</code> 為副檔名。這系列筆記會混用 DSO、shared object、shared library、module 等詞，皆指動態連結檔。</p>\n<h2 id=\"Usage-in-Linux\"><a href=\"#Usage-in-Linux\" class=\"headerlink\" title=\"Usage in Linux\"></a>Usage in Linux</h2><p>先用簡單範例看看 Linux 上如何使用 dynamic link。</p>\n<h3 id=\"source-code\"><a href=\"#source-code\" class=\"headerlink\" title=\"source code\"></a>source code</h3><figure class=\"highlight c\"><figcaption><span>foo.h</span></figcaption><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">ifndef</span> _LIB_H</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> _LIB_H</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">foo</span><span class=\"params\">(<span class=\"keyword\">int</span> a, <span class=\"keyword\">int</span> b)</span></span>;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight c\"><figcaption><span>foo.c</span></figcaption><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">foo</span><span class=\"params\">(<span class=\"keyword\">int</span> a, <span class=\"keyword\">int</span> b)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (a + b);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight c\"><figcaption><span>main.c</span></figcaption><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">\"lib.h\"</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    foo(<span class=\"number\">3</span>, <span class=\"number\">4</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"compile-amp-link\"><a href=\"#compile-amp-link\" class=\"headerlink\" title=\"compile &amp; link\"></a>compile &amp; link</h3><figure class=\"highlight crystal\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ gcc -fPIC -shared -o <span class=\"class\"><span class=\"keyword\">lib</span>.<span class=\"title\">so</span> <span class=\"title\">lib</span>.<span class=\"title\">c</span></span></span><br><span class=\"line\">$ gcc -o main.dyn main.c ./<span class=\"class\"><span class=\"keyword\">lib</span>.<span class=\"title\">so</span></span></span><br></pre></td></tr></table></figure>\n\n<p><code>-shared</code> 表示要編出 shared object。link 出 <code>main.dyn</code> 時，linker 會看 <code>foo()</code> 是定義在其他 static object file 還是在 DSO 裡，如果在 DSO 裡就會標示這個 symbol 為 dynamic linking，等到 load 才進行 symbol relocation。上面第二行要寫 <code>./lib.so</code> 是為了讓 linker 知道 <code>foo()</code> 是在 DSO 裡，而且 <code>main.dyn</code> 也會記錄 <code>lib.so</code> 的路徑。</p>\n<figure class=\"highlight crystal\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ ldd main.dyn </span><br><span class=\"line\">linux-vdso.so.<span class=\"number\">1</span> (<span class=\"number\">0x00007fff29986000</span>)</span><br><span class=\"line\">./<span class=\"class\"><span class=\"keyword\">lib</span>.<span class=\"title\">so</span> (0<span class=\"title\">x00007febdc1b6000</span>)</span></span><br><span class=\"line\">libc.so.<span class=\"number\">6</span> =&gt; <span class=\"regexp\">/lib/x</span>86_64-linux-gnu/libc.so.<span class=\"number\">6</span> (<span class=\"number\">0x00007febdbe0b000</span>)</span><br><span class=\"line\">/lib64/ld-linux-x86-<span class=\"number\">64</span>.so.<span class=\"number\">2</span> (<span class=\"number\">0x00007febdc3b7000</span>)</span><br></pre></td></tr></table></figure>\n\n<p>比較常用的寫法是 <code>-l</code> 指定 library、<code>-L</code> 指定找 library 的 path，例如 <code>-lfoo -L./</code> 會找 <code>libfoo.so</code> 來 link，尋找順序則是先找目前目錄再找系統預設目錄。這種寫法在 <code>main.dyn</code> 裡只會記錄 <code>lib.so</code>、不會有路徑，執行時會從系統以及相關參數所設的路徑找 library，如果找不到會跳 error。</p>\n<figure class=\"highlight crystal\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ readelf -h <span class=\"class\"><span class=\"keyword\">lib</span>.<span class=\"title\">so</span> | <span class=\"title\">grep</span> <span class=\"title\">Type</span></span></span><br><span class=\"line\">  <span class=\"symbol\">Type:</span>                              DYN (Shared object file)</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight routeros\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ readelf -s lib.so</span><br><span class=\"line\"></span><br><span class=\"line\">Symbol table <span class=\"string\">'.dynsym'</span> contains 13 entries:</span><br><span class=\"line\">   Num:    Value          Size<span class=\"built_in\"> Type </span>   Bind   Vis      Ndx Name</span><br><span class=\"line\">     <span class=\"built_in\">..</span>.</span><br><span class=\"line\">     8: 0000000000000660    20 FUNC    GLOBAL<span class=\"built_in\"> DEFAULT </span>  11 foo</span><br><span class=\"line\">     <span class=\"built_in\">..</span>.</span><br><span class=\"line\">Symbol table <span class=\"string\">'.symtab'</span> contains 53 entries:</span><br><span class=\"line\">   Num:    Value          Size<span class=\"built_in\"> Type </span>   Bind   Vis      Ndx Name</span><br><span class=\"line\">    <span class=\"built_in\">..</span>.</span><br><span class=\"line\">    46: 0000000000000660    20 FUNC    GLOBAL<span class=\"built_in\"> DEFAULT </span>  11 foo</span><br><span class=\"line\">    <span class=\"built_in\">..</span>.</span><br></pre></td></tr></table></figure>\n\n<p><code>lib.so</code> 的 symbol table 有給 dynamic link 用的 <code>.dynsym</code> section 跟一般的 <code>.symtab</code> section。</p>\n<figure class=\"highlight routeros\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ readelf -s main.dyn</span><br><span class=\"line\"></span><br><span class=\"line\">Symbol table <span class=\"string\">'.dynsym'</span> contains 12 entries:</span><br><span class=\"line\">   Num:    Value          Size<span class=\"built_in\"> Type </span>   Bind   Vis      Ndx Name</span><br><span class=\"line\">     <span class=\"built_in\">..</span>.</span><br><span class=\"line\">     4: 0000000000000000     0 FUNC    GLOBAL<span class=\"built_in\"> DEFAULT </span> UND foo</span><br><span class=\"line\">Symbol table <span class=\"string\">'.symtab'</span> contains 65 entries:</span><br><span class=\"line\">   Num:    Value          Size<span class=\"built_in\"> Type </span>   Bind   Vis      Ndx Name</span><br><span class=\"line\">    <span class=\"built_in\">..</span>.</span><br><span class=\"line\">    56: 0000000000000000     0 FUNC    GLOBAL<span class=\"built_in\"> DEFAULT </span> UND foo</span><br></pre></td></tr></table></figure>\n\n<p>重點來啦，<code>main.dyn</code> 是 dynamic link <code>lib.so</code> 的可執行檔，它的 symbol table 標示了 <code>foo</code> 仍然是 undefined，而且在 <code>.dynsym</code> 裡也有這個 symbol。<code>.dynsym</code> section 不會出現在其他 object file 裡的 symbol。</p>\n<h3 id=\"virtual-memory-space\"><a href=\"#virtual-memory-space\" class=\"headerlink\" title=\"virtual memory space\"></a>virtual memory space</h3><p>編出 static linking 版本的執行檔：<code>ld -e main main.o lib.o -o main.st</code> 。執行後 <code>cat /proc/&lt;pid&gt;/maps</code> 可以看到 process 的 virtual memory space：</p>\n<figure class=\"highlight angelscript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">00400000</span><span class=\"number\">-00401000</span> r-xp <span class=\"number\">00000000</span> <span class=\"number\">08</span>:<span class=\"number\">01</span> <span class=\"number\">11409244</span>                           /home/cjw/source/dynamic-link/main.st</span><br><span class=\"line\"><span class=\"number\">7f</span>feaa7bb000<span class=\"number\">-7f</span>feaa7dc000 rw-p <span class=\"number\">00000000</span> <span class=\"number\">00</span>:<span class=\"number\">00</span> <span class=\"number\">0</span>                          [stack]</span><br><span class=\"line\"><span class=\"number\">7f</span>feaa7ed000<span class=\"number\">-7f</span>feaa7ef000 r-xp <span class=\"number\">00000000</span> <span class=\"number\">00</span>:<span class=\"number\">00</span> <span class=\"number\">0</span>                          [vdso]</span><br><span class=\"line\"><span class=\"number\">7f</span>feaa7ef000<span class=\"number\">-7f</span>feaa7f1000 r--p <span class=\"number\">00000000</span> <span class=\"number\">00</span>:<span class=\"number\">00</span> <span class=\"number\">0</span>                          [vvar]</span><br><span class=\"line\">ffffffffff600000-ffffffffff601000 r-xp <span class=\"number\">00000000</span> <span class=\"number\">00</span>:<span class=\"number\">00</span> <span class=\"number\">0</span>                  [vsyscall]</span><br></pre></td></tr></table></figure>\n\n<p>簡單明瞭 load 進 <code>main.st</code>，比較 dynamic linking 的 <code>main.dyn</code>：</p>\n<figure class=\"highlight angelscript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">00400000</span><span class=\"number\">-00401000</span> r-xp <span class=\"number\">00000000</span> <span class=\"number\">08</span>:<span class=\"number\">01</span> <span class=\"number\">11409246</span>                           /home/cjw/source/dynamic-link/main.dyn</span><br><span class=\"line\"><span class=\"number\">00600000</span><span class=\"number\">-00601000</span> rw-p <span class=\"number\">00000000</span> <span class=\"number\">08</span>:<span class=\"number\">01</span> <span class=\"number\">11409246</span>                           /home/cjw/source/dynamic-link/main.dyn</span><br><span class=\"line\"><span class=\"number\">7f</span>dee17b3000<span class=\"number\">-7f</span>dee1954000 r-xp <span class=\"number\">00000000</span> <span class=\"number\">08</span>:<span class=\"number\">01</span> <span class=\"number\">7864382</span>                    /lib/x86_64-linux-gnu/libc<span class=\"number\">-2.19</span>.so</span><br><span class=\"line\"><span class=\"number\">7f</span>dee1954000<span class=\"number\">-7f</span>dee1b54000 ---p <span class=\"number\">001</span>a1000 <span class=\"number\">08</span>:<span class=\"number\">01</span> <span class=\"number\">7864382</span>                    /lib/x86_64-linux-gnu/libc<span class=\"number\">-2.19</span>.so</span><br><span class=\"line\"><span class=\"number\">7f</span>dee1b54000<span class=\"number\">-7f</span>dee1b58000 r--p <span class=\"number\">001</span>a1000 <span class=\"number\">08</span>:<span class=\"number\">01</span> <span class=\"number\">7864382</span>                    /lib/x86_64-linux-gnu/libc<span class=\"number\">-2.19</span>.so</span><br><span class=\"line\"><span class=\"number\">7f</span>dee1b58000<span class=\"number\">-7f</span>dee1b5a000 rw-p <span class=\"number\">001</span>a5000 <span class=\"number\">08</span>:<span class=\"number\">01</span> <span class=\"number\">7864382</span>                    /lib/x86_64-linux-gnu/libc<span class=\"number\">-2.19</span>.so</span><br><span class=\"line\"><span class=\"number\">7f</span>dee1b5a000<span class=\"number\">-7f</span>dee1b5e000 rw-p <span class=\"number\">00000000</span> <span class=\"number\">00</span>:<span class=\"number\">00</span> <span class=\"number\">0</span></span><br><span class=\"line\"><span class=\"number\">7f</span>dee1b5e000<span class=\"number\">-7f</span>dee1b5f000 r-xp <span class=\"number\">00000000</span> <span class=\"number\">08</span>:<span class=\"number\">01</span> <span class=\"number\">11409245</span>                   /home/cjw/source/dynamic-link/lib.so</span><br><span class=\"line\"><span class=\"number\">7f</span>dee1b5f000<span class=\"number\">-7f</span>dee1d5e000 ---p <span class=\"number\">00001000</span> <span class=\"number\">08</span>:<span class=\"number\">01</span> <span class=\"number\">11409245</span>                   /home/cjw/source/dynamic-link/lib.so</span><br><span class=\"line\"><span class=\"number\">7f</span>dee1d5e000<span class=\"number\">-7f</span>dee1d5f000 rw-p <span class=\"number\">00000000</span> <span class=\"number\">08</span>:<span class=\"number\">01</span> <span class=\"number\">11409245</span>                   /home/cjw/source/dynamic-link/lib.so</span><br><span class=\"line\"><span class=\"number\">7f</span>dee1d5f000<span class=\"number\">-7f</span>dee1d7f000 r-xp <span class=\"number\">00000000</span> <span class=\"number\">08</span>:<span class=\"number\">01</span> <span class=\"number\">7864371</span>                    /lib/x86_64-linux-gnu/ld<span class=\"number\">-2.19</span>.so</span><br><span class=\"line\"><span class=\"number\">7f</span>dee1f5e000<span class=\"number\">-7f</span>dee1f61000 rw-p <span class=\"number\">00000000</span> <span class=\"number\">00</span>:<span class=\"number\">00</span> <span class=\"number\">0</span></span><br><span class=\"line\"><span class=\"number\">7f</span>dee1f7d000<span class=\"number\">-7f</span>dee1f7f000 rw-p <span class=\"number\">00000000</span> <span class=\"number\">00</span>:<span class=\"number\">00</span> <span class=\"number\">0</span></span><br><span class=\"line\"><span class=\"number\">7f</span>dee1f7f000<span class=\"number\">-7f</span>dee1f80000 r--p <span class=\"number\">00020000</span> <span class=\"number\">08</span>:<span class=\"number\">01</span> <span class=\"number\">7864371</span>                    /lib/x86_64-linux-gnu/ld<span class=\"number\">-2.19</span>.so</span><br><span class=\"line\"><span class=\"number\">7f</span>dee1f80000<span class=\"number\">-7f</span>dee1f81000 rw-p <span class=\"number\">00021000</span> <span class=\"number\">08</span>:<span class=\"number\">01</span> <span class=\"number\">7864371</span>                    /lib/x86_64-linux-gnu/ld<span class=\"number\">-2.19</span>.so</span><br><span class=\"line\"><span class=\"number\">7f</span>dee1f81000<span class=\"number\">-7f</span>dee1f82000 rw-p <span class=\"number\">00000000</span> <span class=\"number\">00</span>:<span class=\"number\">00</span> <span class=\"number\">0</span></span><br><span class=\"line\"><span class=\"number\">7f</span>ffbbf58000<span class=\"number\">-7f</span>ffbbf79000 rw-p <span class=\"number\">00000000</span> <span class=\"number\">00</span>:<span class=\"number\">00</span> <span class=\"number\">0</span>                          [stack]</span><br><span class=\"line\"><span class=\"number\">7f</span>ffbbfce000<span class=\"number\">-7f</span>ffbbfd0000 r-xp <span class=\"number\">00000000</span> <span class=\"number\">00</span>:<span class=\"number\">00</span> <span class=\"number\">0</span>                          [vdso]</span><br><span class=\"line\"><span class=\"number\">7f</span>ffbbfd0000<span class=\"number\">-7f</span>ffbbfd2000 r--p <span class=\"number\">00000000</span> <span class=\"number\">00</span>:<span class=\"number\">00</span> <span class=\"number\">0</span>                          [vvar]</span><br><span class=\"line\">ffffffffff600000-ffffffffff601000 r-xp <span class=\"number\">00000000</span> <span class=\"number\">00</span>:<span class=\"number\">00</span> <span class=\"number\">0</span>                  [vsyscall]</span><br></pre></td></tr></table></figure>\n\n<p>除了 <code>main.dyn</code> 跟 <code>lib.so</code> 之外也 load 進 C Runtime <code>/lib/x86_64-linux-gnu/libc-2.19.so</code> 以及動態連結器 <code>/lib/x86_64-linux-gnu/ld-2.19.so</code>。</p>\n<p>那麼 DSO 會 load 到哪呢？從下面 <code>lib.so</code> 的 segment 來看，它會被 load 到的 address 是 <code>0x00000000</code>，但顯然這個 address 不合法。compile time 無法知道 DSO 會被 load 去哪，是在 runtime 才決定（最簡單的想法是 OS 找到一塊放得下 DSO 的 memory 放）。這也是可以想像的，如果 DSO 跟 executable file 一樣編譯時就決定自己要 load 到某個 address，多個 DSO 在系統裡可能會互撞。kill 掉原本的 <code>main.dyn</code> 再跑一次會發現 load <code>lib.so</code> 的 address 不一樣。</p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">$</span> <span class=\"string\">readelf</span> <span class=\"string\">-l</span> <span class=\"string\">lib.so</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"string\">Elf</span> <span class=\"string\">file</span> <span class=\"string\">type</span> <span class=\"string\">is</span> <span class=\"string\">DYN</span> <span class=\"string\">(Shared</span> <span class=\"string\">object</span> <span class=\"string\">file)</span></span><br><span class=\"line\"><span class=\"string\">Entry</span> <span class=\"string\">point</span> <span class=\"number\">0x560</span></span><br><span class=\"line\"><span class=\"string\">There</span> <span class=\"string\">are</span> <span class=\"number\">6</span> <span class=\"string\">program</span> <span class=\"string\">headers,</span> <span class=\"string\">starting</span> <span class=\"string\">at</span> <span class=\"string\">offset</span> <span class=\"number\">64</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"attr\">Program Headers:</span></span><br><span class=\"line\">  <span class=\"string\">Type</span>           <span class=\"string\">Offset</span>             <span class=\"string\">VirtAddr</span>           <span class=\"string\">PhysAddr</span></span><br><span class=\"line\">                 <span class=\"string\">FileSiz</span>            <span class=\"string\">MemSiz</span>              <span class=\"string\">Flags</span>  <span class=\"string\">Align</span></span><br><span class=\"line\">  <span class=\"string\">LOAD</span>           <span class=\"number\">0x0000000000000000</span> <span class=\"number\">0x0000000000000000</span> <span class=\"number\">0x0000000000000000</span></span><br><span class=\"line\">                 <span class=\"number\">0x0000000000000704</span> <span class=\"number\">0x0000000000000704</span>  <span class=\"string\">R</span> <span class=\"string\">E</span>    <span class=\"number\">200000</span></span><br><span class=\"line\">  <span class=\"string\">LOAD</span>           <span class=\"number\">0x0000000000000708</span> <span class=\"number\">0x0000000000200708</span> <span class=\"number\">0x0000000000200708</span></span><br><span class=\"line\">                 <span class=\"number\">0x0000000000000230</span> <span class=\"number\">0x0000000000000238</span>  <span class=\"string\">RW</span>     <span class=\"number\">200000</span></span><br><span class=\"line\">  <span class=\"string\">DYNAMIC</span>        <span class=\"number\">0x0000000000000720</span> <span class=\"number\">0x0000000000200720</span> <span class=\"number\">0x0000000000200720</span></span><br><span class=\"line\">                 <span class=\"number\">0x00000000000001c0</span> <span class=\"number\">0x00000000000001c0</span>  <span class=\"string\">RW</span>     <span class=\"number\">8</span></span><br><span class=\"line\">  <span class=\"string\">NOTE</span>           <span class=\"number\">0x0000000000000190</span> <span class=\"number\">0x0000000000000190</span> <span class=\"number\">0x0000000000000190</span></span><br><span class=\"line\">                 <span class=\"number\">0x0000000000000024</span> <span class=\"number\">0x0000000000000024</span>  <span class=\"string\">R</span>      <span class=\"number\">4</span></span><br><span class=\"line\">  <span class=\"string\">GNU_EH_FRAME</span>   <span class=\"number\">0x0000000000000680</span> <span class=\"number\">0x0000000000000680</span> <span class=\"number\">0x0000000000000680</span></span><br><span class=\"line\">                 <span class=\"number\">0x000000000000001c</span> <span class=\"number\">0x000000000000001c</span>  <span class=\"string\">R</span>      <span class=\"number\">4</span></span><br><span class=\"line\">  <span class=\"string\">GNU_STACK</span>      <span class=\"number\">0x0000000000000000</span> <span class=\"number\">0x0000000000000000</span> <span class=\"number\">0x0000000000000000</span></span><br><span class=\"line\">                 <span class=\"number\">0x0000000000000000</span> <span class=\"number\">0x0000000000000000</span>  <span class=\"string\">RW</span>     <span class=\"number\">10</span></span><br><span class=\"line\"></span><br><span class=\"line\"> <span class=\"attr\">Section to Segment mapping:</span></span><br><span class=\"line\">  <span class=\"string\">Segment</span> <span class=\"string\">Sections...</span></span><br><span class=\"line\">   <span class=\"number\">00</span>     <span class=\"string\">.note.gnu.build-id</span> <span class=\"string\">.gnu.hash</span> <span class=\"string\">.dynsym</span> <span class=\"string\">.dynstr</span> <span class=\"string\">.gnu.version</span> <span class=\"string\">.gnu.version_r</span> <span class=\"string\">.rela.dyn</span> <span class=\"string\">.rela.plt</span> <span class=\"string\">.init</span> <span class=\"string\">.plt</span> <span class=\"string\">.text</span> <span class=\"string\">.fini</span> <span class=\"string\">.eh_frame_hdr</span> <span class=\"string\">.eh_frame</span></span><br><span class=\"line\">   <span class=\"number\">01</span>     <span class=\"string\">.init_array</span> <span class=\"string\">.fini_array</span> <span class=\"string\">.jcr</span> <span class=\"string\">.dynamic</span> <span class=\"string\">.got</span> <span class=\"string\">.got.plt</span> <span class=\"string\">.data</span> <span class=\"string\">.bss</span></span><br><span class=\"line\">   <span class=\"number\">02</span>     <span class=\"string\">.dynamic</span></span><br><span class=\"line\">   <span class=\"number\">03</span>     <span class=\"string\">.note.gnu.build-id</span></span><br><span class=\"line\">   <span class=\"number\">04</span>     <span class=\"string\">.eh_frame_hdr</span></span><br><span class=\"line\">   <span class=\"number\">05</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Related-posts-amp-Ref\"><a href=\"#Related-posts-amp-Ref\" class=\"headerlink\" title=\"Related posts &amp; Ref\"></a>Related posts &amp; Ref</h2><ul>\n<li><a href=\"/Dynamic-Linking-PIC/\">Dynamic Linking PIC</a></li>\n<li><a href=\"/Dynamic-Linking-Relocation/\">Dynamic Linking Relocation</a></li>\n<li><a href=\"/Shared-Library-Versioning/\">Shared Library Versioning</a></li>\n<li><a href=\"/Use-Shared-Library-in-Linux/\">Use Shared Library in Linux</a></li>\n<li><a href=\"/Explicit-Runtime-Linking/\">Explicit Runtime Linking</a></li>\n<li>《程式設計師的自我修養》ch7</li>\n<li><a href=\"https://www.bottomupcs.com/chapter08.xhtml\" target=\"_blank\" rel=\"noopener\">https://www.bottomupcs.com/chapter08.xhtml</a></li>\n<li><a href=\"https://hackmd.io/s/HkK7Uf4Ml\" target=\"_blank\" rel=\"noopener\">你所不知道的 C 語言：動態連結器篇</a></li>\n</ul>\n","tags":["Linux","System Software"]},{"title":"Dynamic Linking Position-independent Code（PIC）","url":"/Dynamic-Linking-PIC/","content":"<h2 id=\"Dynamic-linking-遇到的問題\"><a href=\"#Dynamic-linking-遇到的問題\" class=\"headerlink\" title=\"Dynamic linking 遇到的問題\"></a>Dynamic linking 遇到的問題</h2><p>Dynamic linking 想解決的一大問題是 memory 浪費。直覺想法是如果能讓不同 process 都會使用到的 library 在 memory 只有一份就能節省空間。對不同 process 來說 library 的內容必須是相同的才能共用。library 主要是 instruction 以及 data （executable file 都是這樣辣），data 不可能在 process 間共用，因為每個 process 都需要它自己的 data，不然會互相干擾（好像有古代系統是共用的…），因此能共用的主要是 instruction。</p>\n<p>excutable file、object file 以及 library 等 binary file 中 instruction 會以不同定址方式 access symbol，絕對定址模式會將 symbol 的 virtual address 寫進 instruction，相對定址模式則跟 instruction 及 data 之間的相對位置有關。也就是說，無論是 executable file 還是要共用的 library，instruction 都可能涉及 symbol 的 address 資訊。</p>\n<p>不像 executable file，library 在 compile time 無法知道會被 load 到哪，因為系統裡會有多個 library，如果各自指定要 load 到哪可能會撞到，所以得等到 runtime 由系統決定，其中 symbol 位置也要到 runtime 才能決定。這使得 compile time 無法修改 instruction 內的 address 資訊，也就是 static linking 做的事。</p>\n<p>另一方面，即使在 runtime 修改 library 的 instruction，也會造成不同 process 實際上有不同的 library instruction 而無法共用。例如 library A 使用某個外部 symbol <code>foo</code>，process 1 跟 process 2 都有使用 library A，但它們分別以 library B 跟 library C 來提供 symbol <code>foo</code> 給 library A。此時，process 1 的 <code>foo</code> 的 address 在 library B，process 2 則在 library C，runtime 修改 library A instruction 會有兩種版本。</p>\n<h2 id=\"Position-independent-Code（PIC）\"><a href=\"#Position-independent-Code（PIC）\" class=\"headerlink\" title=\"Position-independent Code（PIC）\"></a>Position-independent Code（PIC）</h2><p>上面的問題基本上是因為 instruction 裡含有 symbol address 相關資訊，就出現 Position-independent Code（PIC）「與位置無關的程式碼」來解決。</p>\n<p>由於 process 有各自的 data section 而且可以修改裡面的值，PIC 將 library 會被修改的部分（instruction 中的 address 相關資訊）放到 data section，讓 instruction 跟 address 無關而能共用。</p>\n<p>library 的 address reference 可分為 library 內與跨 library，各自又再分成 reference 到資料或 instruction（function call 或 jump），處理方式主要依據 library 內或跨 library 而不同。</p>\n<h3 id=\"library-內\"><a href=\"#library-內\" class=\"headerlink\" title=\"library 內\"></a>library 內</h3><p>同一 library 內的 instruction 跟資料間相對位置是固定的，所以可以用相對位置來 access 資料、call function 或 jump。</p>\n<h3 id=\"跨-library\"><a href=\"#跨-library\" class=\"headerlink\" title=\"跨 library\"></a>跨 library</h3><p>ELF 在 data section 放一個指向其他 library 的 symbol 的 pointer array，稱為 Global Offset Table（GOT）。instruction 可以從 GOT 找到對應的 element 進行間接 reference。先找到 GOT（不同平台有不同作法，可以用相對定址也可以有特殊 register 記錄），再從 GOT 以及 instruction 所知道的「該 symbol 在 GOT 裡的 offset」得到 element，最後得到 symbol address。</p>\n<p>GOT 由 linker 載入 library 時填填內容，同樣使用 relocation table 的 entry 標示需要修改的位置及如何修改。relocation table 不會管 offset 指向的位置是什麼，改那個地方的內容就對了，放 GOT element 就會改 GOT。至於變數與 call function 的差別在 GOT element 存的是變數還是 function 的 address，不過實際上 ELF 有區分變數跟 function，這部份下一篇再說。</p>\n<p>雖然 GOT 可以達到 PIC，但代價是 access symbol 的速度會變慢，因為要先找到 GOT 再間接定址。</p>\n<h3 id=\"Example\"><a href=\"#Example\" class=\"headerlink\" title=\"Example\"></a>Example</h3><figure class=\"highlight c\"><figcaption><span>foo.c</span></figcaption><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">extern</span> <span class=\"keyword\">int</span> sum;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">foo</span><span class=\"params\">(<span class=\"keyword\">int</span> a, <span class=\"keyword\">int</span> b)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">int</span>* p = (<span class=\"keyword\">int</span>*)<span class=\"number\">123</span>;    <span class=\"comment\">// avoid to be placed in .bss</span></span><br><span class=\"line\">    p = &amp;sum;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> a + b;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight llvm\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ gcc -<span class=\"keyword\">c</span> foo.<span class=\"keyword\">c</span></span><br><span class=\"line\">$ gcc -fPIC -<span class=\"keyword\">c</span> foo.<span class=\"keyword\">c</span> -o foo.o.pic</span><br></pre></td></tr></table></figure>\n\n<p>有 <code>-fPIC</code> 跟沒有的差別：</p>\n<figure class=\"highlight angelscript\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ objdump -d foo.o</span><br><span class=\"line\"></span><br><span class=\"line\">foo.o:     file format elf64-x86<span class=\"number\">-64</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">Disassembly of section .text:</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"number\">0000000000000000</span> &lt;foo&gt;:</span><br><span class=\"line\">   <span class=\"number\">0</span>:   <span class=\"number\">55</span>                      push   %rbp</span><br><span class=\"line\">   <span class=\"number\">1</span>:   <span class=\"number\">48</span> <span class=\"number\">89</span> e5                mov    %rsp,%rbp</span><br><span class=\"line\">   <span class=\"number\">4</span>:   <span class=\"number\">89</span> <span class=\"number\">7</span>d fc                mov    %edi,<span class=\"number\">-0x4</span>(%rbp)</span><br><span class=\"line\">   <span class=\"number\">7</span>:   <span class=\"number\">89</span> <span class=\"number\">75</span> f8                mov    %esi,<span class=\"number\">-0x8</span>(%rbp)</span><br><span class=\"line\">   a:   <span class=\"number\">48</span> c7 <span class=\"number\">05</span> <span class=\"number\">00</span> <span class=\"number\">00</span> <span class=\"number\">00</span> <span class=\"number\">00</span>    movq   $<span class=\"number\">0x0</span>,<span class=\"number\">0x0</span>(%rip)        # <span class=\"number\">15</span> &lt;foo+<span class=\"number\">0x15</span>&gt;</span><br><span class=\"line\">  <span class=\"number\">11</span>:   <span class=\"number\">00</span> <span class=\"number\">00</span> <span class=\"number\">00</span> <span class=\"number\">00</span> </span><br><span class=\"line\">  <span class=\"number\">15</span>:   <span class=\"number\">8</span>b <span class=\"number\">55</span> fc                mov    <span class=\"number\">-0x4</span>(%rbp),%edx</span><br><span class=\"line\">  <span class=\"number\">18</span>:   <span class=\"number\">8</span>b <span class=\"number\">45</span> f8                mov    <span class=\"number\">-0x8</span>(%rbp),%eax</span><br><span class=\"line\">  <span class=\"number\">1</span>b:   <span class=\"number\">01</span> d0                   add    %edx,%eax</span><br><span class=\"line\">  <span class=\"number\">1</span>d:   <span class=\"number\">5</span>d                      pop    %rbp</span><br><span class=\"line\">  <span class=\"number\">1</span>e:   c3                      retq   </span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">$ objdump -d foo.o.pic</span><br><span class=\"line\"></span><br><span class=\"line\">foo.o.pic:     file format elf64-x86<span class=\"number\">-64</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">Disassembly of section .text:</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"number\">0000000000000000</span> &lt;foo&gt;:</span><br><span class=\"line\">   <span class=\"number\">0</span>:   <span class=\"number\">55</span>                      push   %rbp</span><br><span class=\"line\">   <span class=\"number\">1</span>:   <span class=\"number\">48</span> <span class=\"number\">89</span> e5                mov    %rsp,%rbp</span><br><span class=\"line\">   <span class=\"number\">4</span>:   <span class=\"number\">89</span> <span class=\"number\">7</span>d fc                mov    %edi,<span class=\"number\">-0x4</span>(%rbp)</span><br><span class=\"line\">   <span class=\"number\">7</span>:   <span class=\"number\">89</span> <span class=\"number\">75</span> f8                mov    %esi,<span class=\"number\">-0x8</span>(%rbp)</span><br><span class=\"line\">   a:   <span class=\"number\">48</span> <span class=\"number\">8</span>b <span class=\"number\">05</span> <span class=\"number\">00</span> <span class=\"number\">00</span> <span class=\"number\">00</span> <span class=\"number\">00</span>    mov    <span class=\"number\">0x0</span>(%rip),%rax        # <span class=\"number\">11</span> &lt;foo+<span class=\"number\">0x11</span>&gt;</span><br><span class=\"line\">  <span class=\"number\">11</span>:   <span class=\"number\">48</span> <span class=\"number\">89</span> <span class=\"number\">05</span> <span class=\"number\">00</span> <span class=\"number\">00</span> <span class=\"number\">00</span> <span class=\"number\">00</span>    mov    %rax,<span class=\"number\">0x0</span>(%rip)        # <span class=\"number\">18</span> &lt;foo+<span class=\"number\">0x18</span>&gt;</span><br><span class=\"line\">  <span class=\"number\">18</span>:   <span class=\"number\">8</span>b <span class=\"number\">55</span> fc                mov    <span class=\"number\">-0x4</span>(%rbp),%edx</span><br><span class=\"line\">  <span class=\"number\">1</span>b:   <span class=\"number\">8</span>b <span class=\"number\">45</span> f8                mov    <span class=\"number\">-0x8</span>(%rbp),%eax</span><br><span class=\"line\">  <span class=\"number\">1</span>e:   <span class=\"number\">01</span> d0                   add    %edx,%eax</span><br><span class=\"line\">  <span class=\"number\">20</span>:   <span class=\"number\">5</span>d                      pop    %rbp</span><br><span class=\"line\">  <span class=\"number\">21</span>:   c3                      retq</span><br></pre></td></tr></table></figure>\n\n<p>結果是用 <code>-fPIC</code> compile 出來跟沒有用的 object file 不一樣<del>（好像廢話）</del>，而且沒有 <code>-fPIC</code> 無法 link 成 shared object。</p>\n<figure class=\"highlight nimrod\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ gcc -<span class=\"literal\">shared</span> foo.o -o foo.so</span><br><span class=\"line\">/usr/bin/ld: foo.o: relocation <span class=\"type\">R_X86_64_32S</span> against `sum' can <span class=\"keyword\">not</span> be used <span class=\"keyword\">when</span> making a <span class=\"literal\">shared</span> <span class=\"keyword\">object</span>; recompile <span class=\"keyword\">with</span> -fPIC</span><br></pre></td></tr></table></figure>\n\n<p>relocation table 如果有 <code>R_X86_64_32S</code> 定址無法變成 DSO。</p>\n<figure class=\"highlight routeros\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ readelf -r foo.o</span><br><span class=\"line\"></span><br><span class=\"line\">Relocation section <span class=\"string\">'.rela.text'</span> at offset 0x240 contains 2 entries:</span><br><span class=\"line\">  Offset          <span class=\"builtin-name\">Info</span>          <span class=\"built_in\"> Type </span>          Sym. Value    Sym. Name + Addend</span><br><span class=\"line\">00000000000d  000300000002 R_X86_64_PC32     0000000000000000 .data - 8</span><br><span class=\"line\">000000000011  000a0000000b R_X86_64_32S      0000000000000000 sum + 0</span><br><span class=\"line\"></span><br><span class=\"line\">Relocation section <span class=\"string\">'.rela.eh_frame'</span> at offset 0x270 contains 1 entries:</span><br><span class=\"line\">  Offset          <span class=\"builtin-name\">Info</span>          <span class=\"built_in\"> Type </span>          Sym. Value    Sym. Name + Addend</span><br><span class=\"line\">000000000020  000200000002 R_X86_64_PC32     0000000000000000 .text + 0</span><br><span class=\"line\"></span><br><span class=\"line\">$ readelf -r foo.o.pic</span><br><span class=\"line\"></span><br><span class=\"line\">Relocation section <span class=\"string\">'.rela.text'</span> at offset 0x278 contains 2 entries:</span><br><span class=\"line\">  Offset          <span class=\"builtin-name\">Info</span>          <span class=\"built_in\"> Type </span>          Sym. Value    Sym. Name + Addend</span><br><span class=\"line\">00000000000d  000b00000009 R_X86_64_GOTPCREL 0000000000000000 sum - 4</span><br><span class=\"line\">000000000014  000300000002 R_X86_64_PC32     0000000000000000 .data - 4</span><br><span class=\"line\"></span><br><span class=\"line\">Relocation section <span class=\"string\">'.rela.eh_frame'</span> at offset 0x2a8 contains 1 entries:</span><br><span class=\"line\">  Offset          <span class=\"builtin-name\">Info</span>          <span class=\"built_in\"> Type </span>          Sym. Value    Sym. Name + Addend</span><br><span class=\"line\">000000000020  000200000002 R_X86_64_PC32     0000000000000000 .text + 0</span><br></pre></td></tr></table></figure>\n\n<p>再看看 shared library 的 section 們，只列出比較相關的部份。</p>\n<figure class=\"highlight angelscript\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ gcc -fPIC -<span class=\"keyword\">shared</span> -o foo.so foo.c</span><br><span class=\"line\">$ readelf -S foo.so</span><br><span class=\"line\">There are <span class=\"number\">27</span> section headers, starting at offset <span class=\"number\">0x1170</span>:</span><br><span class=\"line\"></span><br><span class=\"line\">Section Headers:</span><br><span class=\"line\">  [Nr] Name              Type             Address           Offset</span><br><span class=\"line\">       Size              EntSize          Flags  Link  Info  Align</span><br><span class=\"line\">  ...</span><br><span class=\"line\">  [ <span class=\"number\">3</span>] .dynsym           DYNSYM           <span class=\"number\">00000000000001f</span>8  <span class=\"number\">000001f</span>8</span><br><span class=\"line\">       <span class=\"number\">0000000000000150</span>  <span class=\"number\">0000000000000018</span>   A       <span class=\"number\">4</span>     <span class=\"number\">2</span>     <span class=\"number\">8</span></span><br><span class=\"line\">  [ <span class=\"number\">4</span>] .dynstr           STRTAB           <span class=\"number\">0000000000000348</span>  <span class=\"number\">00000348</span></span><br><span class=\"line\">       <span class=\"number\">00000000000000</span>ab  <span class=\"number\">0000000000000000</span>   A       <span class=\"number\">0</span>     <span class=\"number\">0</span>     <span class=\"number\">1</span></span><br><span class=\"line\">  ...</span><br><span class=\"line\">  [ <span class=\"number\">7</span>] .rela.dyn         RELA             <span class=\"number\">0000000000000430</span>  <span class=\"number\">00000430</span></span><br><span class=\"line\">       <span class=\"number\">00000000000000</span>d8  <span class=\"number\">0000000000000018</span>   A       <span class=\"number\">3</span>     <span class=\"number\">0</span>     <span class=\"number\">8</span></span><br><span class=\"line\">  [ <span class=\"number\">8</span>] .rela.plt         RELA             <span class=\"number\">0000000000000508</span>  <span class=\"number\">00000508</span></span><br><span class=\"line\">       <span class=\"number\">0000000000000030</span>  <span class=\"number\">0000000000000018</span>  AI       <span class=\"number\">3</span>    <span class=\"number\">10</span>     <span class=\"number\">8</span></span><br><span class=\"line\">  ...</span><br><span class=\"line\">  [<span class=\"number\">10</span>] .plt              PROGBITS         <span class=\"number\">0000000000000560</span>  <span class=\"number\">00000560</span></span><br><span class=\"line\">       <span class=\"number\">0000000000000030</span>  <span class=\"number\">0000000000000010</span>  AX       <span class=\"number\">0</span>     <span class=\"number\">0</span>     <span class=\"number\">16</span></span><br><span class=\"line\">  ...</span><br><span class=\"line\">  [<span class=\"number\">18</span>] .dynamic          DYNAMIC          <span class=\"number\">0000000000200760</span>  <span class=\"number\">00000760</span></span><br><span class=\"line\">       <span class=\"number\">00000000000001</span>c0  <span class=\"number\">0000000000000010</span>  WA       <span class=\"number\">4</span>     <span class=\"number\">0</span>     <span class=\"number\">8</span></span><br><span class=\"line\">  [<span class=\"number\">19</span>] .got              PROGBITS         <span class=\"number\">0000000000200920</span>  <span class=\"number\">00000920</span></span><br><span class=\"line\">       <span class=\"number\">0000000000000030</span>  <span class=\"number\">0000000000000008</span>  WA       <span class=\"number\">0</span>     <span class=\"number\">0</span>     <span class=\"number\">8</span></span><br><span class=\"line\">  [<span class=\"number\">20</span>] .got.plt          PROGBITS         <span class=\"number\">0000000000200950</span>  <span class=\"number\">00000950</span></span><br><span class=\"line\">       <span class=\"number\">0000000000000028</span>  <span class=\"number\">0000000000000008</span>  WA       <span class=\"number\">0</span>     <span class=\"number\">0</span>     <span class=\"number\">8</span></span><br><span class=\"line\">  ...</span><br></pre></td></tr></table></figure>\n\n\n<h2 id=\"Lazy-Binding\"><a href=\"#Lazy-Binding\" class=\"headerlink\" title=\"Lazy Binding\"></a>Lazy Binding</h2><p>dynamic linking 以犧牲一點效能達到模組使用的靈活度。效能降低發生在兩個地方：程式開始執行時的 linking 工作以及 GOT 帶來的間接定址。</p>\n<p>程式裡可能有很多 function 在執行過程中不會或很少被用到，例如錯誤處理跟少用的功能。一開始執行就 link 所有 library 裡的 function 顯然有點浪費，畢竟可能花時間 link 了卻沒用到。如果等到 function 第一次被使用時才 bind symbol（找 symbol、relocate 等等）可以加快程式啟動的速度，這個方法稱為 lazy binding。</p>\n<p>ELF 用 Procedure Linkage Table（PLT）來實作 lazy binding。在沒有 lazy binding 前，會藉由 GOT 進行間接跳轉來 access 另一個模組的 function 。有了 lazy binding 表示一開始 load 模組時不會把 GOT 填完，所以使用 GOT 跳轉前要多一層 PLT 的處理：如果 GOT element 沒有值，會先由 dynamic linker 找到該 function 的 address，填入 GOT 後跳去該 function 執行。之後再使用到同一個 function，由於 GOT 裡已經有值，可以直接進行間接跳轉。</p>\n<h2 id=\"Related-posts-amp-Ref\"><a href=\"#Related-posts-amp-Ref\" class=\"headerlink\" title=\"Related posts &amp; Ref\"></a>Related posts &amp; Ref</h2><ul>\n<li><a href=\"/Dynamic-Linking-Basic/\">Dynamic Linking Basic</a></li>\n<li><a href=\"/Dynamic-Linking-Relocation/\">Dynamic Linking Relocation</a></li>\n<li><a href=\"/Shared-Library-Versioning/\">Shared Library Versioning</a></li>\n<li><a href=\"/Use-Shared-Library-in-Linux/\">Use Shared Library in Linux</a></li>\n<li><a href=\"/Explicit-Runtime-Linking/\">Explicit Runtime Linking</a></li>\n<li>《程式設計師的自我修養》ch7</li>\n<li><a href=\"https://www.bottomupcs.com/chapter08.xhtml\" target=\"_blank\" rel=\"noopener\">https://www.bottomupcs.com/chapter08.xhtml</a></li>\n<li><a href=\"https://hackmd.io/s/HkK7Uf4Ml\" target=\"_blank\" rel=\"noopener\">你所不知道的 C 語言：動態連結器篇</a></li>\n</ul>\n","tags":["System Software"]},{"title":"Dynamic Linking Relocation","url":"/Dynamic-Linking-Relocation/","content":"<p><a href=\"/Load-process/\">Load process</a> 在 dynamic linking 的差別是 load 完執行檔後 OS 會先看 ELF 的 <code>.interp</code> section 知道要 load 哪個 dynamic linker，OS load dynamic linker 並將控制權先交給它，在 linux 下是 <code>/lib/x86_64-linux-gnu/ld-2.19.so</code>（很明顯也是個 shared library）。</p>\n<p>dynamic linker 做的事情分成三步：</p>\n<ol>\n<li>啟動</li>\n<li>load 所有需要的 shared library</li>\n<li>relocation &amp; initialization</li>\n</ol>\n<p>dynamic linker 本身也是個 shared library，但它有一些限制，例如不能有依賴的 shared library、不能使用 global 變數、不能 call function 等等。在啟動階段，dynamic linker 會先找到自己的 GOT，而 GOT 第一個 entry 存的是 <code>.dynamic</code> section 的 offset。<code>.dynamic</code> section 保存了 dynamic linker 需要的資訊，例如依賴哪些 shared library，dynamic symbol table、dynamic relocation table 的位置等等。<code>readelf -d</code> 可以查看 <code>.dynamic</code> section。</p>\n<p>透過 <code>.dynamic</code> 裡的資訊，linker 可以知道自己的 relocation table 以及 symbol table，能對自己進行 relocation。linker 做完針對自己的 relocation 後，才能開始使用 global 變數、call function 等等。</p>\n<p>啟動完成後，dynamic linker 將自己的 symbol 以及 executable file 的 symbol 合併到 global symbol table。接著開始從 executable file 的  <code>.dynamic</code> 得知依賴哪些 shared library，一一打開 shared library 並將之 load 到 memory 中、建立 mapping，並且將 shared library 的 symbol 合併到 global symbol table，再搜尋 shared library 的 dependency。如此 traverse 整棵 shared library dependency tree 之後，即 load 完所需的 shared library。通常會以 BFS traverse dependency tree。</p>\n<p>symbol 的部份，ELF 以 dynamic symbol table 保存模組間 import 及 export symbol 的關係，位於 <code>.dynsym</code>，作用以及記錄的資訊跟 <code>.symtab</code> 差不多，但只記錄給其他模組使用的 symbol 以及使用其他模組的 symbol。</p>\n<p>traverse dependency tree 的順序跟 symbol 的優先度有關──當兩個 shared library 有相同的 symbol 時要使用誰的？在 Linux 中會優先使用先 load 的 symbol。也就是說，shared library 的 load 順序會影響 symbol 的優先度，而 link 時指定的 library 順序會影響 load 的順序。</p>\n<p>接著，linker 開始 traverse executable file 以及 shared library 的 relocation table，使用 global symbol table 來修正 GOT 及 PLT 內的 address。dynamic linking 中的 relocation table <code>.rela.dyn</code> 用來修正 <code>.got</code> 及 data section，<code>.rela.plt</code> 則修正 <code>.got.plt</code> section 內的 address。relocation 完成後，如果 shared library 擁有 <code>.init</code> section，dynamic linker 會執行它以進行對 shared library 的初始化。</p>\n<p>最後，dynamic linker 將控制權交給程式的入口開始執行。</p>\n<h2 id=\"Relocation-example\"><a href=\"#Relocation-example\" class=\"headerlink\" title=\"Relocation example\"></a>Relocation example</h2><p>雖然簡單來說 dynamic linker 會在 load shared library 時進行 relocation，但如<a href=\"/Dynamic-Linking-PIC/\">Dynamic Linking PIC</a>所說的，實際上 ELF 是以 lazy binding 來 bind symbol。用個簡單例子看看怎麼做的：</p>\n<figure class=\"highlight h\"><figcaption><span>foo.h</span></figcaption><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">ifndef</span> __FOO_H</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> __FOO_H</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">foo</span><span class=\"params\">(<span class=\"keyword\">int</span> x, <span class=\"keyword\">int</span> y)</span></span>;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight c\"><figcaption><span>foo.c</span></figcaption><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">foo</span><span class=\"params\">(<span class=\"keyword\">int</span> x, <span class=\"keyword\">int</span> y)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (x + y);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight h\"><figcaption><span>bar.h</span></figcaption><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">ifndef</span> __BAR_H</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> __BAR_H</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">bar</span><span class=\"params\">(<span class=\"keyword\">int</span> a, <span class=\"keyword\">int</span> b, <span class=\"keyword\">int</span> n)</span></span>;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight c\"><figcaption><span>bar.c</span></figcaption><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">\"foo.h\"</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">bar</span><span class=\"params\">(<span class=\"keyword\">int</span> a, <span class=\"keyword\">int</span> b, <span class=\"keyword\">int</span> n)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    foo(a, b);</span><br><span class=\"line\">    foo(b, n);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight h\"><figcaption><span>main.c</span></figcaption><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">\"bar.h\"</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    bar(<span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">10</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight stylus\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ gcc -g -shared -fPIC foo<span class=\"selector-class\">.c</span> -o libfoo.so</span><br><span class=\"line\">$ gcc -g -shared -fPIC bar<span class=\"selector-class\">.c</span> -o libbar.so</span><br><span class=\"line\">$ gcc -g main<span class=\"selector-class\">.c</span> ./libfoo<span class=\"selector-class\">.so</span> ./libbar<span class=\"selector-class\">.so</span> -o main</span><br></pre></td></tr></table></figure>\n\n<p>最後編 executable file 時指定的 library 順序會影響 load library 的順序。</p>\n<p>在 <code>main()</code>、<code>bar()</code> 跟 <code>foo()</code> 設中斷點，停在 <code>main()</code> 之後觀察 <code>foo</code> 的 relocation 資訊：</p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">$</span> <span class=\"string\">gdb</span> <span class=\"string\">./main</span></span><br><span class=\"line\"><span class=\"string\">Reading</span> <span class=\"string\">symbols</span> <span class=\"string\">from</span> <span class=\"string\">./main...done.</span></span><br><span class=\"line\"><span class=\"string\">(gdb)</span> <span class=\"string\">b</span> <span class=\"string\">main</span></span><br><span class=\"line\"><span class=\"attr\">Breakpoint 1 at 0x40067a:</span> <span class=\"string\">file</span> <span class=\"string\">main.c,</span> <span class=\"string\">line</span> <span class=\"number\">5</span><span class=\"string\">.</span></span><br><span class=\"line\"><span class=\"string\">(gdb)</span> <span class=\"string\">b</span> <span class=\"string\">bar</span></span><br><span class=\"line\"><span class=\"string\">Breakpoint</span> <span class=\"number\">2</span> <span class=\"string\">at</span> <span class=\"number\">0x400550</span></span><br><span class=\"line\"><span class=\"string\">(gdb)</span> <span class=\"string\">b</span> <span class=\"string\">foo</span></span><br><span class=\"line\"><span class=\"string\">Function</span> <span class=\"string\">\"foo\"</span> <span class=\"string\">not</span> <span class=\"string\">defined.</span></span><br><span class=\"line\"><span class=\"string\">Make</span> <span class=\"string\">breakpoint</span> <span class=\"string\">pending</span> <span class=\"string\">on</span> <span class=\"string\">future</span> <span class=\"string\">shared</span> <span class=\"string\">library</span> <span class=\"string\">load?</span> <span class=\"string\">(y</span> <span class=\"string\">or</span> <span class=\"string\">[n])</span> <span class=\"string\">y</span></span><br><span class=\"line\"><span class=\"string\">Breakpoint</span> <span class=\"number\">3</span> <span class=\"string\">(foo)</span> <span class=\"string\">pending.</span></span><br><span class=\"line\"><span class=\"string\">(gdb)</span> <span class=\"string\">r</span></span><br><span class=\"line\"><span class=\"attr\">Starting program:</span> <span class=\"string\">/home/cjw/source/dynamic-link/relocate/main</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"string\">Breakpoint</span> <span class=\"number\">1</span><span class=\"string\">,</span> <span class=\"string\">main</span> <span class=\"string\">()</span> <span class=\"string\">at</span> <span class=\"string\">main.c:5</span></span><br><span class=\"line\"><span class=\"number\">5</span>           <span class=\"string\">bar(2,</span> <span class=\"number\">3</span><span class=\"string\">,</span> <span class=\"number\">10</span><span class=\"string\">);</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"string\">$</span> <span class=\"string\">cat</span> <span class=\"string\">/proc/`pgrep</span> <span class=\"string\">main`/maps</span></span><br><span class=\"line\"><span class=\"number\">00400000</span><span class=\"number\">-00401000</span> <span class=\"string\">r-xp</span> <span class=\"number\">00000000</span> <span class=\"number\">08</span><span class=\"string\">:24</span> <span class=\"number\">8259464</span>                            <span class=\"string\">/home/cjw/source/dynamic-link/relocate/main</span></span><br><span class=\"line\"><span class=\"number\">00600000</span><span class=\"number\">-00601000</span> <span class=\"string\">rw-p</span> <span class=\"number\">00000000</span> <span class=\"number\">08</span><span class=\"string\">:24</span> <span class=\"number\">8259464</span>                            <span class=\"string\">/home/cjw/source/dynamic-link/relocate/main</span></span><br><span class=\"line\"><span class=\"string\">7ffff762f000-7ffff77d0000</span> <span class=\"string\">r-xp</span> <span class=\"number\">00000000</span> <span class=\"number\">08</span><span class=\"string\">:22</span> <span class=\"number\">1572872</span>                    <span class=\"string\">/lib/x86_64-linux-gnu/libc-2.19.so</span></span><br><span class=\"line\"><span class=\"string\">7ffff77d0000-7ffff79d0000</span> <span class=\"string\">---p</span> <span class=\"string\">001a1000</span> <span class=\"number\">08</span><span class=\"string\">:22</span> <span class=\"number\">1572872</span>                    <span class=\"string\">/lib/x86_64-linux-gnu/libc-2.19.so</span></span><br><span class=\"line\"><span class=\"string\">7ffff79d0000-7ffff79d4000</span> <span class=\"string\">r--p</span> <span class=\"string\">001a1000</span> <span class=\"number\">08</span><span class=\"string\">:22</span> <span class=\"number\">1572872</span>                    <span class=\"string\">/lib/x86_64-linux-gnu/libc-2.19.so</span></span><br><span class=\"line\"><span class=\"string\">7ffff79d4000-7ffff79d6000</span> <span class=\"string\">rw-p</span> <span class=\"string\">001a5000</span> <span class=\"number\">08</span><span class=\"string\">:22</span> <span class=\"number\">1572872</span>                    <span class=\"string\">/lib/x86_64-linux-gnu/libc-2.19.so</span></span><br><span class=\"line\"><span class=\"string\">7ffff79d6000-7ffff79da000</span> <span class=\"string\">rw-p</span> <span class=\"number\">00000000</span> <span class=\"number\">00</span><span class=\"string\">:00</span> <span class=\"number\">0</span></span><br><span class=\"line\"><span class=\"string\">7ffff79da000-7ffff79db000</span> <span class=\"string\">r-xp</span> <span class=\"number\">00000000</span> <span class=\"number\">08</span><span class=\"string\">:24</span> <span class=\"number\">8259463</span>                    <span class=\"string\">/home/cjw/source/dynamic-link/relocate/libbar.so</span></span><br><span class=\"line\"><span class=\"string\">7ffff79db000-7ffff7bda000</span> <span class=\"string\">---p</span> <span class=\"number\">00001000</span> <span class=\"number\">08</span><span class=\"string\">:24</span> <span class=\"number\">8259463</span>                    <span class=\"string\">/home/cjw/source/dynamic-link/relocate/libbar.so</span></span><br><span class=\"line\"><span class=\"string\">7ffff7bda000-7ffff7bdb000</span> <span class=\"string\">rw-p</span> <span class=\"number\">00000000</span> <span class=\"number\">08</span><span class=\"string\">:24</span> <span class=\"number\">8259463</span>                    <span class=\"string\">/home/cjw/source/dynamic-link/relocate/libbar.so</span></span><br><span class=\"line\"><span class=\"string\">7ffff7bdb000-7ffff7bdc000</span> <span class=\"string\">r-xp</span> <span class=\"number\">00000000</span> <span class=\"number\">08</span><span class=\"string\">:24</span> <span class=\"number\">8259445</span>                    <span class=\"string\">/home/cjw/source/dynamic-link/relocate/libfoo.so</span></span><br><span class=\"line\"><span class=\"string\">7ffff7bdc000-7ffff7ddb000</span> <span class=\"string\">---p</span> <span class=\"number\">00001000</span> <span class=\"number\">08</span><span class=\"string\">:24</span> <span class=\"number\">8259445</span>                    <span class=\"string\">/home/cjw/source/dynamic-link/relocate/libfoo.so</span></span><br><span class=\"line\"><span class=\"string\">7ffff7ddb000-7ffff7ddc000</span> <span class=\"string\">rw-p</span> <span class=\"number\">00000000</span> <span class=\"number\">08</span><span class=\"string\">:24</span> <span class=\"number\">8259445</span>                    <span class=\"string\">/home/cjw/source/dynamic-link/relocate/libfoo.so</span></span><br><span class=\"line\"><span class=\"string\">7ffff7ddc000-7ffff7dfc000</span> <span class=\"string\">r-xp</span> <span class=\"number\">00000000</span> <span class=\"number\">08</span><span class=\"string\">:22</span> <span class=\"number\">1572869</span>                    <span class=\"string\">/lib/x86_64-linux-gnu/ld-2.19.so</span></span><br><span class=\"line\"><span class=\"string\">7ffff7fd5000-7ffff7fd8000</span> <span class=\"string\">rw-p</span> <span class=\"number\">00000000</span> <span class=\"number\">00</span><span class=\"string\">:00</span> <span class=\"number\">0</span></span><br><span class=\"line\"><span class=\"string\">7ffff7ff6000-7ffff7ff8000</span> <span class=\"string\">rw-p</span> <span class=\"number\">00000000</span> <span class=\"number\">00</span><span class=\"string\">:00</span> <span class=\"number\">0</span></span><br><span class=\"line\"><span class=\"string\">7ffff7ff8000-7ffff7ffa000</span> <span class=\"string\">r-xp</span> <span class=\"number\">00000000</span> <span class=\"number\">00</span><span class=\"string\">:00</span> <span class=\"number\">0</span>                          <span class=\"string\">[vdso]</span></span><br><span class=\"line\"><span class=\"string\">7ffff7ffa000-7ffff7ffc000</span> <span class=\"string\">r--p</span> <span class=\"number\">00000000</span> <span class=\"number\">00</span><span class=\"string\">:00</span> <span class=\"number\">0</span>                          <span class=\"string\">[vvar]</span></span><br><span class=\"line\"><span class=\"string\">7ffff7ffc000-7ffff7ffd000</span> <span class=\"string\">r--p</span> <span class=\"number\">00020000</span> <span class=\"number\">08</span><span class=\"string\">:22</span> <span class=\"number\">1572869</span>                    <span class=\"string\">/lib/x86_64-linux-gnu/ld-2.19.so</span></span><br><span class=\"line\"><span class=\"string\">7ffff7ffd000-7ffff7ffe000</span> <span class=\"string\">rw-p</span> <span class=\"number\">00021000</span> <span class=\"number\">08</span><span class=\"string\">:22</span> <span class=\"number\">1572869</span>                    <span class=\"string\">/lib/x86_64-linux-gnu/ld-2.19.so</span></span><br><span class=\"line\"><span class=\"string\">7ffff7ffe000-7ffff7fff000</span> <span class=\"string\">rw-p</span> <span class=\"number\">00000000</span> <span class=\"number\">00</span><span class=\"string\">:00</span> <span class=\"number\">0</span></span><br><span class=\"line\"><span class=\"string\">7ffffffdd000-7ffffffff000</span> <span class=\"string\">rw-p</span> <span class=\"number\">00000000</span> <span class=\"number\">00</span><span class=\"string\">:00</span> <span class=\"number\">0</span>                          <span class=\"string\">[stack]</span></span><br><span class=\"line\"><span class=\"string\">ffffffffff600000-ffffffffff601000</span> <span class=\"string\">r-xp</span> <span class=\"number\">00000000</span> <span class=\"number\">00</span><span class=\"string\">:00</span> <span class=\"number\">0</span>                  <span class=\"string\">[vsyscall]</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"string\">$</span> <span class=\"string\">readelf</span> <span class=\"string\">-r</span> <span class=\"string\">libbar.so</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"string\">Relocation</span> <span class=\"string\">section</span> <span class=\"string\">'.rela.dyn'</span> <span class=\"attr\">at offset 0x430 contains 8 entries:</span></span><br><span class=\"line\">  <span class=\"string\">Offset</span>          <span class=\"string\">Info</span>           <span class=\"string\">Type</span>           <span class=\"string\">Sym.</span> <span class=\"string\">Value</span>    <span class=\"string\">Sym.</span> <span class=\"string\">Name</span> <span class=\"string\">+</span> <span class=\"string\">Addend</span></span><br><span class=\"line\"><span class=\"string\">...</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"string\">Relocation</span> <span class=\"string\">section</span> <span class=\"string\">'.rela.plt'</span> <span class=\"attr\">at offset 0x4f0 contains 3 entries:</span></span><br><span class=\"line\">  <span class=\"string\">Offset</span>          <span class=\"string\">Info</span>           <span class=\"string\">Type</span>           <span class=\"string\">Sym.</span> <span class=\"string\">Value</span>    <span class=\"string\">Sym.</span> <span class=\"string\">Name</span> <span class=\"string\">+</span> <span class=\"string\">Addend</span></span><br><span class=\"line\"><span class=\"number\">000000200980</span>  <span class=\"number\">000300000007</span> <span class=\"string\">R_X86_64_JUMP_SLO</span> <span class=\"number\">0000000000000000</span> <span class=\"string\">__gmon_start__</span> <span class=\"string\">+</span> <span class=\"number\">0</span></span><br><span class=\"line\"><span class=\"number\">000000200988</span>  <span class=\"number\">000400000007</span> <span class=\"string\">R_X86_64_JUMP_SLO</span> <span class=\"number\">0000000000000000</span> <span class=\"string\">foo</span> <span class=\"string\">+</span> <span class=\"number\">0</span></span><br><span class=\"line\"><span class=\"number\">000000200990</span>  <span class=\"number\">000700000007</span> <span class=\"string\">R_X86_64_JUMP_SLO</span> <span class=\"number\">0000000000000000</span> <span class=\"string\">__cxa_finalize</span> <span class=\"string\">+</span> <span class=\"number\">0</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"string\">(gdb)</span> <span class=\"string\">x/1xbg</span> <span class=\"number\">0x7ffff79da000</span><span class=\"string\">+0x000000200988</span></span><br><span class=\"line\"><span class=\"attr\">0x7ffff7bda988:</span> <span class=\"number\">0x00007ffff79da586</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"string\">(gdb)</span> <span class=\"string\">info</span> <span class=\"string\">address</span> <span class=\"string\">foo</span></span><br><span class=\"line\"><span class=\"string\">Symbol</span> <span class=\"string\">\"foo\"</span> <span class=\"string\">is</span> <span class=\"string\">a</span> <span class=\"string\">function</span> <span class=\"string\">at</span> <span class=\"string\">address</span> <span class=\"number\">0x7ffff7bdb660</span><span class=\"string\">.</span></span><br></pre></td></tr></table></figure>\n\n<p><code>libbar.so</code> 裡需要修正 address 的位置是 <code>0x7ffff79da000 + 0x000000200988</code>，因為 library 要到 load 的時候才能知道起始位置，所以必須用 offset 算出要修改的地方，因為還沒用過 <code>foo</code>，這個 address 的內容還不是 <code>foo</code> 的 address。</p>\n<figure class=\"highlight angelscript\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ readelf -S libbar.so</span><br><span class=\"line\">...</span><br><span class=\"line\">  [<span class=\"number\">20</span>] .got.plt          PROGBITS         <span class=\"number\">0000000000200968</span>  <span class=\"number\">00000968</span></span><br><span class=\"line\">       <span class=\"number\">0000000000000030</span>  <span class=\"number\">0000000000000008</span>  WA       <span class=\"number\">0</span>     <span class=\"number\">0</span>     <span class=\"number\">8</span></span><br><span class=\"line\">...</span><br></pre></td></tr></table></figure>\n\n<p>從 relocation entry 來看，relocate 的 offset 是 <code>0x000000200988</code>，在 <code>.got.plt</code> 裡。<code>0x7ffff7bda988</code> 這個位置在 load <code>libbar.so</code> 的第三個 segment，屬性是 <code>rw-p</code>，是可以修改的。</p>\n<p>繼續跑看第一次 call <code>foo()</code>：</p>\n<figure class=\"highlight angelscript\"><table><tr><td class=\"code\"><pre><span class=\"line\">(gdb) c</span><br><span class=\"line\">Continuing.</span><br><span class=\"line\"></span><br><span class=\"line\">Breakpoint <span class=\"number\">2</span>, bar (a=<span class=\"number\">2</span>, b=<span class=\"number\">3</span>, n=<span class=\"number\">10</span>) at bar.c:<span class=\"number\">7</span></span><br><span class=\"line\"><span class=\"number\">7</span>           foo(a, b);</span><br><span class=\"line\">(gdb) x/<span class=\"number\">10</span>i $pc</span><br><span class=\"line\">=&gt; <span class=\"number\">0x7ffff79da6b1</span> &lt;bar+<span class=\"number\">17</span>&gt;:     mov    <span class=\"number\">-0x8</span>(%rbp),%edx</span><br><span class=\"line\">   <span class=\"number\">0x7ffff79da6b4</span> &lt;bar+<span class=\"number\">20</span>&gt;:     mov    <span class=\"number\">-0x4</span>(%rbp),%eax</span><br><span class=\"line\">   <span class=\"number\">0x7ffff79da6b7</span> &lt;bar+<span class=\"number\">23</span>&gt;:     mov    %edx,%esi</span><br><span class=\"line\">   <span class=\"number\">0x7ffff79da6b9</span> &lt;bar+<span class=\"number\">25</span>&gt;:     mov    %eax,%edi</span><br><span class=\"line\">   <span class=\"number\">0x7ffff79da6bb</span> &lt;bar+<span class=\"number\">27</span>&gt;:     callq  <span class=\"number\">0x7ffff79da580</span> &lt;<span class=\"symbol\">foo@</span>plt&gt;</span><br><span class=\"line\">   <span class=\"number\">0x7ffff79da6c0</span> &lt;bar+<span class=\"number\">32</span>&gt;:     mov    <span class=\"number\">-0xc</span>(%rbp),%edx</span><br><span class=\"line\">   <span class=\"number\">0x7ffff79da6c3</span> &lt;bar+<span class=\"number\">35</span>&gt;:     mov    <span class=\"number\">-0x8</span>(%rbp),%eax</span><br><span class=\"line\">   <span class=\"number\">0x7ffff79da6c6</span> &lt;bar+<span class=\"number\">38</span>&gt;:     mov    %edx,%esi</span><br><span class=\"line\">   <span class=\"number\">0x7ffff79da6c8</span> &lt;bar+<span class=\"number\">40</span>&gt;:     mov    %eax,%edi</span><br><span class=\"line\">   <span class=\"number\">0x7ffff79da6ca</span> &lt;bar+<span class=\"number\">42</span>&gt;:     callq  <span class=\"number\">0x7ffff79da580</span> &lt;<span class=\"symbol\">foo@</span>plt&gt;</span><br><span class=\"line\">(gdb) b *<span class=\"number\">0x7ffff79da6bb</span></span><br><span class=\"line\">(gdb) c</span><br><span class=\"line\">(gdb) x/<span class=\"number\">1</span>i $pc</span><br><span class=\"line\">=&gt; <span class=\"number\">0x7ffff79da6bb</span> &lt;bar+<span class=\"number\">27</span>&gt;:     callq  <span class=\"number\">0x7ffff79da580</span> &lt;<span class=\"symbol\">foo@</span>plt&gt;</span><br><span class=\"line\">(gdb) si</span><br><span class=\"line\"><span class=\"number\">0x00007ffff79da580</span> <span class=\"keyword\">in</span> <span class=\"symbol\">foo@</span>plt () <span class=\"keyword\">from</span> ./libbar.so</span><br><span class=\"line\">(gdb) x/<span class=\"number\">3</span>i $pc</span><br><span class=\"line\">=&gt; <span class=\"number\">0x7ffff79da580</span> &lt;<span class=\"symbol\">foo@</span>plt&gt;:    jmpq   *<span class=\"number\">0x200402</span>(%rip)        # <span class=\"number\">0x7ffff7bda988</span></span><br><span class=\"line\">   <span class=\"number\">0x7ffff79da586</span> &lt;<span class=\"symbol\">foo@</span>plt+<span class=\"number\">6</span>&gt;:  pushq  $<span class=\"number\">0x1</span></span><br><span class=\"line\">   <span class=\"number\">0x7ffff79da58b</span> &lt;<span class=\"symbol\">foo@</span>plt+<span class=\"number\">11</span>&gt;: jmpq   <span class=\"number\">0x7ffff79da560</span></span><br><span class=\"line\">(gdb) si</span><br><span class=\"line\"><span class=\"number\">0x00007ffff79da586</span> <span class=\"keyword\">in</span> <span class=\"symbol\">foo@</span>plt () <span class=\"keyword\">from</span> ./libbar.so</span><br><span class=\"line\"><span class=\"number\">2</span>: x/i $pc</span><br><span class=\"line\">=&gt; <span class=\"number\">0x7ffff79da586</span> &lt;<span class=\"symbol\">foo@</span>plt+<span class=\"number\">6</span>&gt;:  pushq  $<span class=\"number\">0x1</span></span><br><span class=\"line\">(gdb) </span><br><span class=\"line\"><span class=\"number\">0x00007ffff79da58b</span> <span class=\"keyword\">in</span> <span class=\"symbol\">foo@</span>plt () <span class=\"keyword\">from</span> ./libbar.so</span><br><span class=\"line\"><span class=\"number\">2</span>: x/i $pc</span><br><span class=\"line\">=&gt; <span class=\"number\">0x7ffff79da58b</span> &lt;<span class=\"symbol\">foo@</span>plt+<span class=\"number\">11</span>&gt;: jmpq   <span class=\"number\">0x7ffff79da560</span></span><br><span class=\"line\">(gdb) </span><br><span class=\"line\"><span class=\"number\">0x00007ffff79da560</span> <span class=\"keyword\">in</span> ?? () <span class=\"keyword\">from</span> ./libbar.so</span><br><span class=\"line\"><span class=\"number\">2</span>: x/i $pc</span><br><span class=\"line\">=&gt; <span class=\"number\">0x7ffff79da560</span>:      pushq  <span class=\"number\">0x20040a</span>(%rip)        # <span class=\"number\">0x7ffff7bda970</span></span><br><span class=\"line\">(gdb) </span><br><span class=\"line\"><span class=\"number\">0x00007ffff79da566</span> <span class=\"keyword\">in</span> ?? () <span class=\"keyword\">from</span> ./libbar.so</span><br><span class=\"line\"><span class=\"number\">2</span>: x/i $pc</span><br><span class=\"line\">=&gt; <span class=\"number\">0x7ffff79da566</span>:      jmpq   *<span class=\"number\">0x20040c</span>(%rip)        # <span class=\"number\">0x7ffff7bda978</span></span><br><span class=\"line\">(gdb) x/<span class=\"number\">3</span>i $pc</span><br><span class=\"line\">=&gt; <span class=\"number\">0x7ffff79da566</span>:      jmpq   *<span class=\"number\">0x20040c</span>(%rip)        # <span class=\"number\">0x7ffff7bda978</span></span><br><span class=\"line\">   <span class=\"number\">0x7ffff79da56c</span>:      nopl   <span class=\"number\">0x0</span>(%rax)</span><br><span class=\"line\">   <span class=\"number\">0x7ffff79da570</span> &lt;<span class=\"symbol\">__gmon_start__@</span>plt&gt;: jmpq   *<span class=\"number\">0x20040a</span>(%rip)        # <span class=\"number\">0x7ffff7bda980</span></span><br><span class=\"line\">(gdb) si</span><br><span class=\"line\">_dl_runtime_resolve () at ../sysdeps/x86_64/dl-trampoline.S:<span class=\"number\">34</span></span><br><span class=\"line\"><span class=\"number\">34</span>      ../sysdeps/x86_64/dl-trampoline.S: No such file <span class=\"keyword\">or</span> directory.</span><br><span class=\"line\"><span class=\"number\">2</span>: x/i $pc</span><br><span class=\"line\">=&gt; <span class=\"number\">0x7ffff7df02b0</span> &lt;_dl_runtime_resolve&gt;:        sub    $<span class=\"number\">0x38</span>,%rsp</span><br><span class=\"line\">(gdb) x/<span class=\"number\">1</span>xbg <span class=\"number\">0x7ffff7bda978</span></span><br><span class=\"line\"><span class=\"number\">0x7ffff7bda978</span>: <span class=\"number\">0x00007ffff7df02b0</span></span><br></pre></td></tr></table></figure>\n\n<p><code>0x7ffff79da580</code> 是 <code>foo</code> 在 PLT 裡的位置，call <code>foo()</code> 的時候會跳過去。這個位置位於 load <code>libbar.so</code> 的第一個 segment，屬性 <code>r-xp</code>，可執行，同時也代表 PLT 是被放在可執行的 segment 裡。到 <code>foo@plt</code> 後會再跳到 <code>foo</code> 在 <code>.got.plt</code> 的 entry 所指的 address，也就是前面看到的 <code>0x00007ffff79da586</code>，同時也是 <code>foo@plt</code> 的下一個指令，最後在 <code>0x7ffff79da566:      jmpq   *0x20040c(%rip)        # 0x7ffff7bda978</code> 會跳到 <code>0x7ffff7bda978</code> 記錄的位置 <code>0x00007ffff7df02b0</code>，即 <code>_dl_runtime_resolve</code> 的入口，到這邊當然是要 resolve symbol 啦，至於中間 push 的動作跟給 <code>_dl_runtime_resolve</code> 參數有關。</p>\n<p>設中斷點在 call 完 <code>foo()</code> 之後，看看 resolve 完 <code>foo</code> 在 <code>.got.plt</code> 裡對應的 entry 會如何：</p>\n<figure class=\"highlight routeros\"><table><tr><td class=\"code\"><pre><span class=\"line\">(gdb) b <span class=\"number\">*0</span>x7ffff79da6c0</span><br><span class=\"line\">Breakpoint 5 at 0x7ffff79da6c0: file bar.c, line 8.</span><br><span class=\"line\">(gdb) c</span><br><span class=\"line\">Continuing.</span><br><span class=\"line\"></span><br><span class=\"line\">Breakpoint 3, foo (<span class=\"attribute\">x</span>=2, <span class=\"attribute\">y</span>=3) at foo.c:3</span><br><span class=\"line\">3           return (x + y);</span><br><span class=\"line\">2: x/i <span class=\"variable\">$pc</span></span><br><span class=\"line\">=&gt; 0x7ffff7bdb66a &lt;foo+10&gt;:     mov    -0x4(%rbp),%edx</span><br><span class=\"line\">1: <span class=\"variable\">$pc</span> = (void (*)()) 0x7ffff7bdb66a &lt;foo+10&gt;</span><br><span class=\"line\">(gdb) c</span><br><span class=\"line\">Continuing.</span><br><span class=\"line\"></span><br><span class=\"line\">Breakpoint 5, bar (<span class=\"attribute\">a</span>=2, <span class=\"attribute\">b</span>=3, <span class=\"attribute\">n</span>=10) at bar.c:8</span><br><span class=\"line\">8           foo(b, n);</span><br><span class=\"line\">2: x/i <span class=\"variable\">$pc</span></span><br><span class=\"line\">=&gt; 0x7ffff79da6c0 &lt;bar+32&gt;:     mov    -0xc(%rbp),%edx</span><br><span class=\"line\">1: <span class=\"variable\">$pc</span> = (void (*)()) 0x7ffff79da6c0 &lt;bar+32&gt;</span><br><span class=\"line\">(gdb) x/7i <span class=\"variable\">$pc</span></span><br><span class=\"line\">=&gt; 0x7ffff79da6c0 &lt;bar+32&gt;:     mov    -0xc(%rbp),%edx</span><br><span class=\"line\">   0x7ffff79da6c3 &lt;bar+35&gt;:     mov    -0x8(%rbp),%eax</span><br><span class=\"line\">   0x7ffff79da6c6 &lt;bar+38&gt;:     mov    %edx,%esi</span><br><span class=\"line\">   0x7ffff79da6c8 &lt;bar+40&gt;:     mov    %eax,%edi</span><br><span class=\"line\">   0x7ffff79da6ca &lt;bar+42&gt;:     callq  0x7ffff79da580 &lt;foo@plt&gt;</span><br><span class=\"line\">   0x7ffff79da6cf &lt;bar+47&gt;:     leaveq </span><br><span class=\"line\">   0x7ffff79da6d0 &lt;bar+48&gt;:     retq   </span><br><span class=\"line\">(gdb) x/1xbg 0x7ffff79da000+0x000000200988</span><br><span class=\"line\">0x7ffff7bda988: 0x00007ffff7bdb660</span><br><span class=\"line\">(gdb) <span class=\"builtin-name\">info</span><span class=\"built_in\"> address </span>foo</span><br><span class=\"line\">Symbol <span class=\"string\">\"foo\"</span> is a function at<span class=\"built_in\"> address </span>0x7ffff7bdb660.</span><br></pre></td></tr></table></figure>\n\n<p>出現 <code>foo</code> 的 address 啦！</p>\n<p>再看第二次 call <code>foo()</code> 會怎樣：</p>\n<figure class=\"highlight angelscript\"><table><tr><td class=\"code\"><pre><span class=\"line\">(gdb) b *<span class=\"number\">0x7ffff79da6ca</span></span><br><span class=\"line\">Breakpoint <span class=\"number\">6</span> at <span class=\"number\">0x7ffff79da6ca</span>: file bar.c, line <span class=\"number\">8.</span></span><br><span class=\"line\">(gdb) c</span><br><span class=\"line\">Continuing.</span><br><span class=\"line\"></span><br><span class=\"line\">Breakpoint <span class=\"number\">6</span>, <span class=\"number\">0x00007ffff79da6ca</span> <span class=\"keyword\">in</span> bar (a=<span class=\"number\">2</span>, b=<span class=\"number\">3</span>, n=<span class=\"number\">10</span>) at bar.c:<span class=\"number\">8</span></span><br><span class=\"line\"><span class=\"number\">8</span>           foo(b, n);</span><br><span class=\"line\"><span class=\"number\">2</span>: x/i $pc</span><br><span class=\"line\">=&gt; <span class=\"number\">0x7ffff79da6ca</span> &lt;bar+<span class=\"number\">42</span>&gt;:     callq  <span class=\"number\">0x7ffff79da580</span> &lt;<span class=\"symbol\">foo@</span>plt&gt;</span><br><span class=\"line\">(gdb) si</span><br><span class=\"line\"><span class=\"number\">0x00007ffff79da580</span> <span class=\"keyword\">in</span> <span class=\"symbol\">foo@</span>plt () <span class=\"keyword\">from</span> ./libbar.so</span><br><span class=\"line\"><span class=\"number\">2</span>: x/i $pc</span><br><span class=\"line\">=&gt; <span class=\"number\">0x7ffff79da580</span> &lt;<span class=\"symbol\">foo@</span>plt&gt;:    jmpq   *<span class=\"number\">0x200402</span>(%rip)        # <span class=\"number\">0x7ffff7bda988</span></span><br><span class=\"line\"><span class=\"number\">1</span>: $pc = (<span class=\"built_in\">void</span> (*)()) <span class=\"number\">0x7ffff79da580</span> &lt;<span class=\"symbol\">foo@</span>plt&gt;</span><br><span class=\"line\">(gdb) x/<span class=\"number\">5</span>i $pc</span><br><span class=\"line\">=&gt; <span class=\"number\">0x7ffff79da580</span> &lt;<span class=\"symbol\">foo@</span>plt&gt;:    jmpq   *<span class=\"number\">0x200402</span>(%rip)        # <span class=\"number\">0x7ffff7bda988</span></span><br><span class=\"line\">   <span class=\"number\">0x7ffff79da586</span> &lt;<span class=\"symbol\">foo@</span>plt+<span class=\"number\">6</span>&gt;:  pushq  $<span class=\"number\">0x1</span></span><br><span class=\"line\">   <span class=\"number\">0x7ffff79da58b</span> &lt;<span class=\"symbol\">foo@</span>plt+<span class=\"number\">11</span>&gt;: jmpq   <span class=\"number\">0x7ffff79da560</span></span><br><span class=\"line\">   <span class=\"number\">0x7ffff79da590</span> &lt;<span class=\"symbol\">__cxa_finalize@</span>plt&gt;: jmpq   *<span class=\"number\">0x2003fa</span>(%rip)        # <span class=\"number\">0x7ffff7bda990</span></span><br><span class=\"line\">   <span class=\"number\">0x7ffff79da596</span> &lt;<span class=\"symbol\">__cxa_finalize@</span>plt+<span class=\"number\">6</span>&gt;:       pushq  $<span class=\"number\">0x2</span></span><br><span class=\"line\">(gdb) si</span><br><span class=\"line\">foo (x=<span class=\"number\">2</span>, y=<span class=\"number\">3</span>) at foo.c:<span class=\"number\">2</span></span><br><span class=\"line\"><span class=\"number\">2</span>       &#123;</span><br><span class=\"line\"><span class=\"number\">2</span>: x/i $pc</span><br><span class=\"line\">=&gt; <span class=\"number\">0x7ffff7bdb660</span> &lt;foo&gt;:        push   %rbp</span><br><span class=\"line\"><span class=\"number\">1</span>: $pc = (<span class=\"built_in\">void</span> (*)()) <span class=\"number\">0x7ffff7bdb660</span> &lt;foo&gt;</span><br></pre></td></tr></table></figure>\n\n<p>一樣跳到 <code>foo@plt</code>，接著會跳到 <code>foo</code> 於 <code>.got.plt</code> 所記錄的 address，現在是 <code>foo()</code> 的 address 了所以就會進 <code>foo()</code> 了！</p>\n<p>總結上面的 lazy binding 行為，call function 時會跳到 PLT 裡執行，進到 PLT 的第一個指令是跳到 symbol 於 GOT 裡所指向的位置。第一次 call 時 GOT 記錄的 address 會是 PLT 對應的下一個指令，相當於繼續執行 PLT 的 instruction，接著一路 call 到 resolve symbol 的 function 找 symbol 以及將 address 填進 GOT。之後再 call 到相同 function 一樣會先到 PLT，但第一個指令就會從 GOT 得到正確 address、跳去該 function 執行。</p>\n<p>觀察 <code>main</code> 裡的 <code>bar</code> 也會有類似的情況，只是 <code>main</code> 因為是 executable file，relocation entry 的 offset 已經是 load 進 memory 的 address，可以不用像 shared library 那樣要用 load 的 memory 開頭算 offset。</p>\n<h2 id=\"Initialization\"><a href=\"#Initialization\" class=\"headerlink\" title=\"Initialization\"></a>Initialization</h2><p>除了一般會進入 shared library 的 <code>.init</code> section 進行初始化外，GCC 還提供了 shared library 的 constructor 及 destructor 擴充語法，可以讓 function 在 load shared library 時執行以做更多初始化的動作，宣告語法如下：</p>\n<figure class=\"highlight delphi\"><table><tr><td class=\"code\"><pre><span class=\"line\">void __attribute__((<span class=\"function\"><span class=\"keyword\">constructor</span>)) <span class=\"title\">init</span><span class=\"params\">()</span>;</span></span><br><span class=\"line\">void __attribute__((<span class=\"function\"><span class=\"keyword\">destructor</span>)) <span class=\"title\">fini</span><span class=\"params\">()</span>;</span></span><br></pre></td></tr></table></figure>\n\n<p>使用這種 constructor 跟 destructor 必須使用系統預設的 standard runtime library 以及啟動檔案，不可以用 <code>-nostartfiles</code> 以及 <code>-nostdlib</code> 參數。constructor 會在 load shared library 時執行（執行 main 之前），而 destructor 則會在執行 <code>exit()</code> 時執行。如果是 <a href=\"/Explicit-Runtime-Linking/\">Explicit Runtime Linking</a>，constructor 會在 <code>dlopen()</code> 時執行，destructor 則在 <code>dlclose()</code> 時執行。</p>\n<h2 id=\"Murmur-amp-省略的細節\"><a href=\"#Murmur-amp-省略的細節\" class=\"headerlink\" title=\"Murmur &amp; 省略的細節\"></a>Murmur &amp; 省略的細節</h2><p>上面這樣順順列下來看起來好簡單，但其實我找 GOT 跟 PLT 到底在做什麼找～很～久～一直錯把 GOT 當 PLT，就搞不懂是在幹嘛……</p>\n<p>PIC 跟 GOT/PLT 還有不少細節，例如 ELF 怎麼處理 library 內跟跨 library 的 function call？變數的 relocation 怎麼做的？resolve function 怎麼知道要找哪個 symbol？這些先暫時略過，不然我永遠寫不完……Orz</p>\n<h2 id=\"Related-posts-amp-Ref\"><a href=\"#Related-posts-amp-Ref\" class=\"headerlink\" title=\"Related posts &amp; Ref\"></a>Related posts &amp; Ref</h2><ul>\n<li><a href=\"/Dynamic-Linking-Basic/\">Dynamic Linking Basic</a></li>\n<li><a href=\"/Dynamic-Linking-PIC/\">Dynamic Linking PIC</a></li>\n<li><a href=\"/Shared-Library-Versioning/\">Shared Library Versioning</a></li>\n<li><a href=\"/Use-Shared-Library-in-Linux/\">Use Shared Library in Linux</a></li>\n<li><a href=\"/Explicit-Runtime-Linking/\">Explicit Runtime Linking</a></li>\n<li>《程式設計師的自我修養》ch7</li>\n<li><a href=\"https://www.bottomupcs.com/chapter08.xhtml\" target=\"_blank\" rel=\"noopener\">https://www.bottomupcs.com/chapter08.xhtml</a></li>\n<li><a href=\"https://hackmd.io/s/HkK7Uf4Ml\" target=\"_blank\" rel=\"noopener\">你所不知道的 C 語言：動態連結器篇</a></li>\n</ul>\n","tags":["System Software"]},{"title":"Exception Handling","url":"/Exception-Handling/","content":"<p>前陣子寫 code 遇到 exception 或程式執行錯誤該丟出 exception 的情況，雖然知道 try catch 跟 throw exception，但「什麼時候」要「如何使用」exception 卻沒個概念然後搞得一團亂。只好來念念《例外處理設計的逆襲》，順便整理下嗑完書的簡略筆記。</p>\n<h2 id=\"區分-Fault、Error、Failure、Exception\"><a href=\"#區分-Fault、Error、Failure、Exception\" class=\"headerlink\" title=\"區分 Fault、Error、Failure、Exception\"></a>區分 Fault、Error、Failure、Exception</h2><p>首先區分幾個名詞的概念，不然這些東西都很像，不分清楚講到後來都不知道在講些什麼了。</p>\n<ul>\n<li>（從外部看）一個 <strong>component 沒有提供正確服務稱為 service failure</strong>，簡稱 failure。</li>\n<li><strong>error 是種「狀態」</strong>，表示 component 內部處於錯誤狀態。這種狀態可能導致 component 執行失敗，造成 failure。</li>\n<li><strong>fault 則是導致 error 發生的「原因」</strong>。</li>\n<li>程式語言以 exception 表達 error 與 failure 的概念。<ul>\n<li>從不同角度來看（如 caller 跟 callee），exception 可以代表 error 也可以代表 failure。</li>\n<li>遇到某種情況要不要丟出 exception，決定方式之一是看在該 function 的語意及功能下，該狀況是不是屬於「目前可能處在不正確的狀態」或「被 call 的 function 沒做好該做的事」。如果是，當然就丟出 exception。</li>\n</ul>\n</li>\n</ul>\n<a id=\"more\"></a>\n\n<h3 id=\"Fault-的種類\"><a href=\"#Fault-的種類\" class=\"headerlink\" title=\"Fault 的種類\"></a>Fault 的種類</h3><p>依據「存在時間長短」，fault 可區分為：</p>\n<ul>\n<li>transient fault<br>出現一次就消失，重新執行一次操作又能正常執行。</li>\n<li>intermittent fault<br>出現後消失，接著重複出現。例如 memory leak，重新啟動後能正常使用，但過陣子 memory 又爆掉。</li>\n<li>permanent fault<br>發生後除非將有問題的 component 換掉或修好，否則 component 會一直處於 failure 狀態，如 bug。</li>\n</ul>\n<p>依據「產生原因」，fault 可區分為：</p>\n<ul>\n<li>design fault<br>就是 bug，如誤解需求、邏輯寫錯等等。design fault 屬於 permanent fault，除非 deveoper 修好，不然不會自己消失的啦～<del>（我也希望有一天 bug 會自己修好）</del></li>\n<li>component fault<br>硬體 component failure 產生的 error，或者 software component 與 software component、software component 與執行環境、software component 與硬體環境，彼此互動時所產生的不正常情況。component fault 有可能是 transient fault、intermittent fault 或 permanent fault，因此有不同的處理方式。針對 transient fault 只要 retry 系統就能恢復正常，例如 call REST API 時網路抖了一下連不上。但 intermittent 與 permanent fault 得釐清 root cause，單純的 retry 無法解決問題。</li>\n</ul>\n<h2 id=\"Exception-Handling-vs-Fault-Tolerant\"><a href=\"#Exception-Handling-vs-Fault-Tolerant\" class=\"headerlink\" title=\"Exception Handling vs Fault Tolerant\"></a>Exception Handling vs Fault Tolerant</h2><p>一個 software component 發生 error，必須加以處理以免變成 failure。error handling 可分為兩種：</p>\n<ul>\n<li>exception handling：負責處理 component fault（可預期的錯誤狀況）。</li>\n<li>fault-tolerant programming：負責處理 design fault（不可預期的錯誤狀況）。</li>\n</ul>\n<p>因為程式語言並沒有特別區分兩者，所以實作上無論是 exception handling 還是 fault-tolerent programming 都使用程式語言的 exception handling 機制來處理。</p>\n<p>exception handling 跟 fault-tolerant programming 的成本差很多。如果要做到 fault-tolerant，像 Java 的 <code>NullPointerException</code> 會變成得在程式中處理的 exception，但這在大多數時候（尤其是內部 function 間的呼叫）算是 design fault，而且會出現 <code>NullPointerException</code> 的地方很多，所有地方都要處理當然會提升開發成本。</p>\n<p>fault-tolerant，容錯，顧名思義是「能容忍程式裡的錯誤，就算是程式有錯也要能夠正常執行」。fault-tolerant 設計通常用在需要非常 robust 的應用系統，像飛機啊軍事啊等等。<del>（沒弄好會死人的系統）</del></p>\n<p>區分 exception handling 跟 fault-tolerant programming 並且確認開發的軟體系統需要多強的 robustness、能付出多少成本，就能知道在實作上需要處理哪些 exception，才不會一下這邊處理了屬於 design fault 的 exception 一下那邊又不處理一團亂。</p>\n<h2 id=\"定義強健度等級\"><a href=\"#定義強健度等級\" class=\"headerlink\" title=\"定義強健度等級\"></a>定義強健度等級</h2><p>例外處理設計的第一步是定義強健度等級。強健度等級是例外處理的需求，有了需求開發時就知道要如何處理 exception。</p>\n<h3 id=\"等級-0：未定義（undefined）\"><a href=\"#等級-0：未定義（undefined）\" class=\"headerlink\" title=\"等級 0：未定義（undefined）\"></a>等級 0：未定義（undefined）</h3><p>沒特別定義跟做什麼的時候。</p>\n<p>簡單說，一切都是混亂不清。caller 無法確定 service 是否有完成任務。發生問題時 caller 可能知道也可能不知道、service 的狀態是不明或者錯誤狀態。發生問題後 service 可能終止也可能繼續跑。</p>\n<h3 id=\"等級-1：錯誤回報（Error-reporting）\"><a href=\"#等級-1：錯誤回報（Error-reporting）\" class=\"headerlink\" title=\"等級 1：錯誤回報（Error-reporting）\"></a>等級 1：錯誤回報（Error-reporting）</h3><p><strong>service 發生錯誤時一定要讓 caller 知道</strong>。caller 能確切知道 service 是否有成功達成任務。發生問題時 service 的狀態可能是不明或錯誤狀態。發生問題後 service 必須終止執行，因為狀態已經不明，繼續執行可能會造成更多錯誤。</p>\n<p>要達到這個等級就是把 exception 都往外丟，然後在主程式捕捉所有 exception 並回報給 user 或 developer 知道。</p>\n<h3 id=\"等級-2：狀態回復（State-recovery）\"><a href=\"#等級-2：狀態回復（State-recovery）\" class=\"headerlink\" title=\"等級 2：狀態回復（State-recovery）\"></a>等級 2：狀態回復（State-recovery）</h3><p>又稱 weakly tolerant。</p>\n<p>有 error-reporting 的要求，並且<strong>錯誤發生後 service 須保證系統依然處在正確狀態</strong>。因為狀態依然正確，所以發生問題後系統仍然可以繼續執行。</p>\n<p>要達到此等級，要多做 <strong>error handling 以及 cleanup</strong>，讓系統回復到正確狀態並且釋放資源，例如把修改過的 db 做 rollback 以及釋放要來的 memory。</p>\n<h3 id=\"等級-3：行為回復（Behavior-recovery）\"><a href=\"#等級-3：行為回復（Behavior-recovery）\" class=\"headerlink\" title=\"等級 3：行為回復（Behavior-recovery）\"></a>等級 3：行為回復（Behavior-recovery）</h3><p>又稱 strongly tolerant。</p>\n<p><strong>service failure 時會試圖排除困難，達成原本應該做到的任務。</strong></p>\n<p>除了狀態回復需要做的事情外，行為回復還要想替代方案達成原本的任務。為了不讓下次執行任務依然失敗，會先啟動 fault handling 排除造成失敗的原因，再套用 retry 等技巧來嘗試繼續提供服務。</p>\n<p>目前遇到的都沒有那麼複雜，往往是對 transient fault 直接 retry，例如連不上對方 server 就等個幾秒再試一次。</p>\n<h4 id=\"無論如何都無法回復行為？\"><a href=\"#無論如何都無法回復行為？\" class=\"headerlink\" title=\"無論如何都無法回復行為？\"></a>無論如何都無法回復行為？</h4><p>將強健度等級降為 2。</p>\n<p>如果行為回復失敗，service 要嘗試達到狀態回復，如果依然失敗，再降到錯誤回報等級。</p>\n<h3 id=\"如何使用強健度等級？\"><a href=\"#如何使用強健度等級？\" class=\"headerlink\" title=\"如何使用強健度等級？\"></a>如何使用強健度等級？</h3><p>這回答了我「在程式中遇到 exception 該怎麼處理？」的問題，算是個準則吧。</p>\n<ul>\n<li>預設所有 function 要達到強健度等級 1。<ul>\n<li>系統開發到一定程度才較容易知道 exception 該在哪層處理以及如何處理、哪些 function 需要提升強健度。要求 function 都達到錯誤回報可以在開發時將問題曝露出來，讓 developer 比較容易 debug、決定如何處理 exception。</li>\n<li>要求 function 達到錯誤回報，能讓 developer 在開發正常流程的階段知道遇到 exception 該怎麼處理（往外丟就對了），減少各自用各自方式處理的混亂。<del>（別說每個人處理方式不同會亂，我自己寫沒想好都會一團亂了啊哈哈）</del></li>\n<li>實作上只要在主程式統一捕捉 exception 就不會讓程式不預期的當掉，也可以統一做 logging，其他 function 只要安心丟出 exception 即可。</li>\n</ul>\n</li>\n<li>針對特定 function 要求達到強健度等級 2。<ul>\n<li>例如資料庫處理。</li>\n</ul>\n</li>\n<li>除非特別要求或者會很難用，否則不特別要求做到行為回復。<ul>\n<li>像在 call REST 之類 API 會做 retry，retry 一定次數依然失敗後才當作 failure。</li>\n</ul>\n</li>\n</ul>\n<p>在正常功能尚未完成時不太容易決定 exception handling 該做在系統的哪一層，過早的例外處理實作不見得有用。甚至開發早期可能無法判斷該如何處理，要等到系統正常功能開發得差不多才有足夠多的資訊知道如何處理例外。一開始規定強健度等級在 1 或 2，開發後期有更充足的 context 後再決定是否要提升強健度等級。</p>\n<p>強健度等級也是隨著軟體開發漸漸提升的，不需要一開始就要達到很高的強健度（畢竟一開始通常沒有那個時間）。</p>\n<h2 id=\"try、catch-以及-finally-block-的責任\"><a href=\"#try、catch-以及-finally-block-的責任\" class=\"headerlink\" title=\"try、catch 以及 finally block 的責任\"></a>try、catch 以及 finally block 的責任</h2><h3 id=\"try-block\"><a href=\"#try-block\" class=\"headerlink\" title=\"try block\"></a>try block</h3><ul>\n<li>實作 function 的功能，包含主要方法與替代方法。</li>\n<li>為恢復狀態做準備，例如建立 checkpoint。</li>\n<li>回報系統錯誤。如果發生錯誤導致無法提供正確服務，而且該錯誤無法在 function 內部處理，則可以在此直接回報服務 failure（丟出 exception）。</li>\n</ul>\n<h3 id=\"catch-block\"><a href=\"#catch-block\" class=\"headerlink\" title=\"catch block\"></a>catch block</h3><ul>\n<li>進行 error handling 與 fault handling。<ul>\n<li>error handling 是如果系統因為發生問題而處於 error 狀態，需要修正這種 error 狀態，讓系統回復到可以繼續運行的正常狀態。</li>\n<li>fault handling 則是要嘗試排除造成錯誤的根本原因。要程式來做這件事頗難，所以通常交由人來處理。</li>\n</ul>\n</li>\n<li>回報錯誤狀況。<ul>\n<li>failure 可以在 try block 也可以在 catch block 回報，看是在哪裡發生。</li>\n<li>回報的方式有丟出 exception、在螢幕上印出錯誤訊息、寫到 log 等等。</li>\n</ul>\n</li>\n<li>控制 retry 流程。<ul>\n<li>如果 exception 發生後要以 retry 的方式處理，可以在 catch block 控制 retry 流程。</li>\n<li>舉例來說，在 catch block 檢查 retry 次數，超過某個次數就算失敗、丟出 exception。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"finally-block\"><a href=\"#finally-block\" class=\"headerlink\" title=\"finally block\"></a>finally block</h3><ul>\n<li>釋放資源並且回報釋放資源失敗的狀況。</li>\n<li>如果在 try block 做了 checkpoint，在這裡要把 checkpoint 砍掉免得佔用 resource。</li>\n</ul>\n<h2 id=\"實作的二三事\"><a href=\"#實作的二三事\" class=\"headerlink\" title=\"實作的二三事\"></a>實作的二三事</h2><p>exception handling 的基本做法就是以語意清楚的 exception 回報所有發生的問題，之後再針對需要更 robust 的部份去做狀態或行為回復。</p>\n<p>前面多是概念，總要講點實作面，但我又不想一一列舉各種實作小技巧，簡單寫點二三事就好。</p>\n<h3 id=\"越底層越不特別處理-exception\"><a href=\"#越底層越不特別處理-exception\" class=\"headerlink\" title=\"越底層越不特別處理 exception\"></a>越底層越不特別處理 exception</h3><p>通常寫某個 module 是因為它現在會在某種應用情境下使用到，但越底層的 module 就越不要針對目前的應用情境去處理問題或 exception，只要往上丟 exception 就好。底層 module 針對特定情境處理 exception，會讓 module 難以在其他情境中使用，降低 module 的 reusable。</p>\n<h3 id=\"用不同-exception-class-區分不同-fault\"><a href=\"#用不同-exception-class-區分不同-fault\" class=\"headerlink\" title=\"用不同 exception class 區分不同 fault\"></a>用不同 exception class 區分不同 fault</h3><p>主要是區分 design fault 與 component fault。</p>\n<p>以不同的 exception class 區分兩種 fault 後，開發時就能依照需要 exception handling 還是 fault-tolerant 知道是否需要處理特定 exception。debug 時也比較容易知道發生什麼問題，是有機會回復的問題還是是 bug。</p>\n<p>對於丟出 exception 的 module，也可以藉由丟出不同的 exception 區分程式中的 fault 是哪種。</p>\n<p>我想分清楚不同 fault 對實作跟 debug 是有好處的。</p>\n<h3 id=\"error-reporting-catch-exception-in-main-function\"><a href=\"#error-reporting-catch-exception-in-main-function\" class=\"headerlink\" title=\"error-reporting + catch exception in main function\"></a>error-reporting + catch exception in main function</h3><p>在達到強健度等級 1 error reporting 時，function 們就是丟出 exception。exception 一直往上傳，為了避免程式不預期結束，可以在 main function 或 thread entry point 或程式的各 entry point 加上 try catch，在 catch block 捕捉所有的 exception 並且寫入 log。這樣 logging 的動作只在最外層做一次，內部 function 不需要特別再管 logging。</p>\n<h3 id=\"不要在-console-印-exception\"><a href=\"#不要在-console-印-exception\" class=\"headerlink\" title=\"不要在 console 印 exception\"></a>不要在 console 印 exception</h3><p>「遇到 exception 不知道怎麼處理，就把它印出來就好啦！這樣就有處裡啦！」</p>\n<p>問題是，印在 console 的東西很難被注意到，所以 exception 只印在 console 跟被忽略差不了多少，甚至還有已經處理 exception 的錯覺。</p>\n<p>因為現在程式多是圖形介面，印在 console 不只使用者不會看到，連 developer 都可能因為 console 太多東西而忽略 exception。</p>\n<h3 id=\"用哪裡出了問題來命名-exception\"><a href=\"#用哪裡出了問題來命名-exception\" class=\"headerlink\" title=\"用哪裡出了問題來命名 exception\"></a>用哪裡出了問題來命名 exception</h3><p>用哪裡出了問題、出了什麼問題來命名，而不是用誰丟出 exception。</p>\n<h3 id=\"關於-exception-object-所帶的資訊\"><a href=\"#關於-exception-object-所帶的資訊\" class=\"headerlink\" title=\"關於 exception object 所帶的資訊\"></a>關於 exception object 所帶的資訊</h3><p>從 exception 的名稱、其繼承結構、身上帶的其他 exception、error code 以及訊息等等可以知道發生的問題的資訊，能在 exception 上越清楚的附上這些資訊，越有利於 error handling 以及 debug。</p>\n<h3 id=\"將低階層-exception-轉成高階層所理解的-exception\"><a href=\"#將低階層-exception-轉成高階層所理解的-exception\" class=\"headerlink\" title=\"將低階層 exception 轉成高階層所理解的 exception\"></a>將低階層 exception 轉成高階層所理解的 exception</h3><p>不要將低階層的 implementation exception 直接傳給上層的人，因為這樣收到 exception 的人會被底層的實作細節綁住，造成不必要的相依性。</p>\n<h3 id=\"exception-handling-失敗怎麼辦？\"><a href=\"#exception-handling-失敗怎麼辦？\" class=\"headerlink\" title=\"exception handling 失敗怎麼辦？\"></a>exception handling 失敗怎麼辦？</h3><p>簡單說，丟出一個代表「例外處理失敗」的例外。將「代表例外處理失敗的例外」附在原本 exception 上，再丟出原本的 exception。</p>\n<h3 id=\"用-checkpoint-class-做狀態回復\"><a href=\"#用-checkpoint-class-做狀態回復\" class=\"headerlink\" title=\"用 checkpoint class 做狀態回復\"></a>用 checkpoint class 做狀態回復</h3><p>以 checkpoint class 負責狀態回復相關的動作，這個 class 具有保存狀態、回復狀態以及丟棄狀態等功能。</p>\n<p>在 try block 改變系統狀態前保存狀態，發生 exception 後在 catch block 回復狀態，最後無論有無發生 exception 都在 finally block 丟棄先前保存的狀態。</p>\n<p>保存及回復狀態的實作會因功能不同而不同。使用 checkpoint 回復狀態可以簡化例外處理程式，並且分開狀態回復的實作跟正常功能的實作。</p>\n","tags":["Exception Handling"]},{"title":"Explicit Runtime Linking","url":"/Explicit-Runtime-Linking/","content":"<p>explicit runtime linking 讓程式可以在執行過程中控制 load 及 unload 模組。這種方式讓載入模組變得更靈活，可以在程式需要時才載入某個模組，載入什麼模組也可以依執行狀況決定。因為不需要在一開始載入所有模組，所以可以減少啟動時間跟記憶體用量。另外，因為可以在執行期才載入，也就能在不關閉程式的情況下新增、刪除及更新模組。</p>\n<p>在程式碼裡指定了什麼時候要 load 哪個模組，對程式來說它就「知道」要有載入模組的動作。如果是以 dynamic linker 來 load 跟 link，模組跟 library 對程式是透明的，它不知道它用了什麼。兩者的差別即在手動或自動 load shared library，以及load 的時機。</p>\n<p>另一方面，如果需要知道一個程式依賴哪些模組，例如移植時要將所有相關模組移植到其他平台以確保所有功能正常。這時以 explicit runtime linking 載入的模組可能增加檢查 dependency 的難度，因為無法用 <code>ldd</code> 得知依賴的模組，可能要等到用到某個功能時才當掉或無法使用。當然這問題並不是太大的缺點，可以透過適當管理 dependency library 以及以一致的方式撰寫 explicit linking 程式碼來避免。</p>\n<p>linux 以四個 function 來達到 explicit runtime linking，分別是 <code>dlopen()</code>、<code>dlsym()</code>、<code>dlerror()</code> 以及 <code>dlclose()</code>，它們宣告在 <code>&lt;dlfcn.h&gt;</code>，link 時須 <code>-ldl</code>。</p>\n<h2 id=\"dlopen\"><a href=\"#dlopen\" class=\"headerlink\" title=\"dlopen()\"></a>dlopen()</h2><p><code>dlopen()</code> 開啟一個 dynamic library，將其 load 到 process 的 adddress space，並完成初始化。</p>\n<p><code>void *dlopen(const char *filename, int flag);</code></p>\n<p>第一個參數 <code>filename</code> 很簡單，就是 dynamic library 的路徑。如果是絕對路徑就能直接打開 dynamic library，如果是相對路徑則會依照某個順序尋找 library，詳細的順序可參考 <code>man dlopen</code>。</p>\n<p><code>flag</code> 必須指定 <code>RTLD_LAZY</code> 或 <code>RTLD_NOW</code> 之一，<code>RTLD_LAZY</code> 表示 lazy binding，也就是 symbol 在第一次被用到的時候才 resolve。lazy binding 只用於 function，variable 會在 library load 時就 bind 好。<code>RTLD_NOW</code> 當然就是在 load library 的時候就會把所有 symbol 都 resolve。除了 <code>RTLD_LAZY</code> 跟 <code>RTLD_NOW</code> 之外，還有 <code>RTLD_GLOBAL</code> 可以跟他們一起使用，表示之後載入的 library 都可以使用這個 library 的 symbol。其他更多 flag 就參考 manual 囉。</p>\n<p><code>dlopen()</code> return 一個 handle，之後的操作要傳這個 handle 給其他 function。如果 load 失敗，會 return NULL。如果要 load 的 library 之前已經 load 過，會 return 跟之前相同的 handle。</p>\n<p>如果 load 進來的 library 依賴其他 shared library（link 時指定，非 explicit runtime linking），<code>dlopen()</code> 會自動 load 那些 shared library。</p>\n<h2 id=\"dlsym\"><a href=\"#dlsym\" class=\"headerlink\" title=\"dlsym()\"></a>dlsym()</h2><p>讓我們可以找到 library 的 symbol。</p>\n<p><code>void *dlsym(void *handle, const char *symbol);</code></p>\n<p><code>handle</code> 是剛剛 <code>dlopen()</code> return 的 handle。</p>\n<p><code>symbol</code> 是要找的 symbol 的名字，如果找不到 symbol 會 return NULL。找到 symbol 會 return 該 symbol 的 address。根據 manual，return 值是 NULL 無法當作找不到 symbol 的判斷，因為 return 值有可能真的是 NULL<em>（不過我想不到這種狀況的例子…）</em>，須配合 <code>dlerror()</code> 才能確認是不是有找到 symbol：首先 call <code>dlerror()</code> 清掉前面的 error，接著 call <code>dlsym()</code> 找 symbol，再 call <code>dlerror()</code> 看是否有 error 來判斷是否找到 symbol。</p>\n<p>如果多個 library 有相同的 symbol 會用哪個？<code>dlsym()</code> 會以 BFS 找 library 的 dependency tree，直到找到 symbol 或完全找不到為止。也就是說 load 順序會決定 symbol 同名時使用到誰，先 load 會先用。</p>\n<h2 id=\"dlerror\"><a href=\"#dlerror\" class=\"headerlink\" title=\"dlerror()\"></a>dlerror()</h2><p>call <code>dlopen()</code>、<code>dlsym()</code> 跟 <code>dlclose()</code> 之後可以 call <code>dlerror()</code> 看上次呼叫有沒有成功。如果成功 <code>dlerror()</code> 會 return NULL，反之則 return error 相關資訊。</p>\n<p><code>char *dlerror(void);</code></p>\n<h2 id=\"dlclose\"><a href=\"#dlclose\" class=\"headerlink\" title=\"dlclose()\"></a>dlclose()</h2><p>用來 unload library。</p>\n<p><code>int dlclose(void *handle);</code></p>\n<p>系統會用 counter 紀錄一個 library load 的次數，也就是 <code>dlopen()</code> 時加一，<code>dlclose()</code> 則減一，當 counter 變成 0 時 library 才會真的被 unload 掉。unload 的順序跟 load 相反，會先執行 <code>.finit</code> section 的程式碼，接著從 symbol table 中移除相關 symbol，取消 process address space 跟 library 的 memory mapping，最後關閉 library 檔案。</p>\n<p>成功 return 0，失敗 return 非 0 值。</p>\n<h2 id=\"Example\"><a href=\"#Example\" class=\"headerlink\" title=\"Example\"></a>Example</h2><p>簡單用個例子實作跟驗證。以下共有 <code>libfoo.so</code>、<code>libbar.so</code> 跟 <code>libkar.so</code> 三個 library，主程式 <code>main.c</code> 以 explicit runtime linking load <code>libfoo.so</code>，而 <code>libfoo.so</code> 依賴 <code>libbar.so</code> 以及 <code>libkar.so</code>，後兩者有相同名稱的 function。</p>\n<figure class=\"highlight c\"><figcaption><span>bar.c</span></figcaption><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">bar</span><span class=\"params\">()</span> </span>&#123; <span class=\"built_in\">printf</span>(<span class=\"string\">\"bar() in bar.c\\n\"</span>); &#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight c\"><figcaption><span>kar.c</span></figcaption><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">bar</span><span class=\"params\">()</span> </span>&#123; <span class=\"built_in\">printf</span>(<span class=\"string\">\"bar() in kar.c\\n\"</span>); &#125;</span><br></pre></td></tr></table></figure>\n\n<p>compile with </p>\n<figure class=\"highlight mipsasm\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ gcc -g -fPIC -<span class=\"keyword\">shared </span>-o libbar.so <span class=\"keyword\">bar.c</span></span><br><span class=\"line\"><span class=\"keyword\">$ </span>gcc -g -fPIC -<span class=\"keyword\">shared </span>-o libkar.so kar.c</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight c\"><figcaption><span>foo.c</span></figcaption><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">int</span> zoo = <span class=\"number\">1</span>;</span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> coo = <span class=\"number\">5566</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">foo</span><span class=\"params\">(<span class=\"keyword\">int</span> a, <span class=\"keyword\">int</span> b)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"foo = %x, &amp;zoo = %x, &amp;coo = %x\\n\"</span>, foo, &amp;zoo, &amp;coo);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> a + b;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">int</span> <span class=\"title\">koo</span><span class=\"params\">(<span class=\"keyword\">int</span> n)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> n + coo;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>compile with <code>gcc -g -fPIC -shared -o libfoo.so foo.c ./libbar.so ./libkar.so</code></p>\n<figure class=\"highlight c\"><figcaption><span>main.c</span></figcaption><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;dlfcn.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">void</span>* handle = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    handle = dlopen(<span class=\"string\">\"./libfoo.so\"</span>, RTLD_LAZY);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (handle == <span class=\"literal\">NULL</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"Load library failed. error: %s\\n\"</span>, dlerror());</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">int</span> (*fn)(<span class=\"keyword\">int</span>, <span class=\"keyword\">int</span>) = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    dlerror();  <span class=\"comment\">// clear error condition</span></span><br><span class=\"line\">    fn = dlsym(handle, <span class=\"string\">\"foo\"</span>);</span><br><span class=\"line\"><span class=\"comment\">//    fn = dlsym(handle, \"koo\");    // fail</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">char</span>* error = dlerror();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (error != <span class=\"literal\">NULL</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"Load symbol failed. error: %s\\n\"</span>, error);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"fn = %x\\n\"</span>, fn);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">int</span> ret = fn(<span class=\"number\">3</span>, <span class=\"number\">5</span>);</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"ret = %d\\n\"</span>, ret);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// doesn't check error</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span>* p = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    p = dlsym(handle, <span class=\"string\">\"zoo\"</span>);</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"p = %x\\n\"</span>, p);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">int</span>* c = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    c = dlsym(handle, <span class=\"string\">\"coo\"</span>);</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"c = %x, *c = %d\\n\"</span>, c, *c);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">void</span> (*bar)() = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    bar = dlsym(handle, <span class=\"string\">\"bar\"</span>);</span><br><span class=\"line\">    bar();</span><br><span class=\"line\"></span><br><span class=\"line\">    getchar();  <span class=\"comment\">// just pause process</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (dlclose(handle) != <span class=\"number\">0</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"Close library fail. error: %s\\n\"</span>, dlerror());</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>compile with <code>gcc -g -o main main.c -ldl</code></p>\n<p>執行結果顯示拿到主程式 <code>libfoo.so</code> 裡 symbol 的 address，以及 load 到 <code>libbar.so</code> 裡的 <code>bar()</code>：</p>\n<figure class=\"highlight nix\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ ./main </span><br><span class=\"line\"><span class=\"attr\">fn</span> = ef40f740</span><br><span class=\"line\"><span class=\"attr\">foo</span> = ef40f740, &amp;<span class=\"attr\">zoo</span> = ef60faf0, &amp;<span class=\"attr\">coo</span> = ef40f7a8</span><br><span class=\"line\"><span class=\"attr\">ret</span> = <span class=\"number\">8</span></span><br><span class=\"line\"><span class=\"attr\">p</span> = ef60faf0</span><br><span class=\"line\"><span class=\"attr\">c</span> = ef40f7a8, *<span class=\"attr\">c</span> = <span class=\"number\">5566</span></span><br><span class=\"line\">bar() <span class=\"keyword\">in</span> bar.c</span><br></pre></td></tr></table></figure>\n\n<p>process 的 address space：</p>\n<figure class=\"highlight angelscript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">00400000</span><span class=\"number\">-00401000</span> r-xp <span class=\"number\">00000000</span> <span class=\"number\">08</span>:<span class=\"number\">01</span> <span class=\"number\">11409326</span>                           /home/cjw/source/<span class=\"keyword\">explicit</span>-load/main</span><br><span class=\"line\"><span class=\"number\">00600000</span><span class=\"number\">-00601000</span> rw-p <span class=\"number\">00000000</span> <span class=\"number\">08</span>:<span class=\"number\">01</span> <span class=\"number\">11409326</span>                           /home/cjw/source/<span class=\"keyword\">explicit</span>-load/main</span><br><span class=\"line\"><span class=\"number\">02552000</span><span class=\"number\">-02573000</span> rw-p <span class=\"number\">00000000</span> <span class=\"number\">00</span>:<span class=\"number\">00</span> <span class=\"number\">0</span>                                  [heap]</span><br><span class=\"line\"><span class=\"number\">7fe9</span>bee48000<span class=\"number\">-7fe9</span>bee49000 r-xp <span class=\"number\">00000000</span> <span class=\"number\">08</span>:<span class=\"number\">01</span> <span class=\"number\">11409316</span>                   /home/cjw/source/<span class=\"keyword\">explicit</span>-load/libkar.so</span><br><span class=\"line\"><span class=\"number\">7fe9</span>bee49000<span class=\"number\">-7fe9</span>bf048000 ---p <span class=\"number\">00001000</span> <span class=\"number\">08</span>:<span class=\"number\">01</span> <span class=\"number\">11409316</span>                   /home/cjw/source/<span class=\"keyword\">explicit</span>-load/libkar.so</span><br><span class=\"line\"><span class=\"number\">7fe9</span>bf048000<span class=\"number\">-7fe9</span>bf049000 rw-p <span class=\"number\">00000000</span> <span class=\"number\">08</span>:<span class=\"number\">01</span> <span class=\"number\">11409316</span>                   /home/cjw/source/<span class=\"keyword\">explicit</span>-load/libkar.so</span><br><span class=\"line\"><span class=\"number\">7fe9</span>bf049000<span class=\"number\">-7fe9</span>bf04a000 r-xp <span class=\"number\">00000000</span> <span class=\"number\">08</span>:<span class=\"number\">01</span> <span class=\"number\">11409324</span>                   /home/cjw/source/<span class=\"keyword\">explicit</span>-load/libbar.so</span><br><span class=\"line\"><span class=\"number\">7fe9</span>bf04a000<span class=\"number\">-7fe9</span>bf249000 ---p <span class=\"number\">00001000</span> <span class=\"number\">08</span>:<span class=\"number\">01</span> <span class=\"number\">11409324</span>                   /home/cjw/source/<span class=\"keyword\">explicit</span>-load/libbar.so</span><br><span class=\"line\"><span class=\"number\">7fe9</span>bf249000<span class=\"number\">-7fe9</span>bf24a000 rw-p <span class=\"number\">00000000</span> <span class=\"number\">08</span>:<span class=\"number\">01</span> <span class=\"number\">11409324</span>                   /home/cjw/source/<span class=\"keyword\">explicit</span>-load/libbar.so</span><br><span class=\"line\"><span class=\"number\">7fe9</span>bf24a000<span class=\"number\">-7fe9</span>bf24b000 r-xp <span class=\"number\">00000000</span> <span class=\"number\">08</span>:<span class=\"number\">01</span> <span class=\"number\">11409329</span>                   /home/cjw/source/<span class=\"keyword\">explicit</span>-load/libfoo.so</span><br><span class=\"line\"><span class=\"number\">7fe9</span>bf24b000<span class=\"number\">-7fe9</span>bf44a000 ---p <span class=\"number\">00001000</span> <span class=\"number\">08</span>:<span class=\"number\">01</span> <span class=\"number\">11409329</span>                   /home/cjw/source/<span class=\"keyword\">explicit</span>-load/libfoo.so</span><br><span class=\"line\"><span class=\"number\">7fe9</span>bf44a000<span class=\"number\">-7fe9</span>bf44b000 rw-p <span class=\"number\">00000000</span> <span class=\"number\">08</span>:<span class=\"number\">01</span> <span class=\"number\">11409329</span>                   /home/cjw/source/<span class=\"keyword\">explicit</span>-load/libfoo.so</span><br><span class=\"line\"><span class=\"number\">7fe9</span>bf44b000<span class=\"number\">-7fe9</span>bf5ec000 r-xp <span class=\"number\">00000000</span> <span class=\"number\">08</span>:<span class=\"number\">01</span> <span class=\"number\">7864382</span>                    /lib/x86_64-linux-gnu/libc<span class=\"number\">-2.19</span>.so</span><br><span class=\"line\"><span class=\"number\">7fe9</span>bf5ec000<span class=\"number\">-7fe9</span>bf7ec000 ---p <span class=\"number\">001</span>a1000 <span class=\"number\">08</span>:<span class=\"number\">01</span> <span class=\"number\">7864382</span>                    /lib/x86_64-linux-gnu/libc<span class=\"number\">-2.19</span>.so</span><br><span class=\"line\"><span class=\"number\">7fe9</span>bf7ec000<span class=\"number\">-7fe9</span>bf7f0000 r--p <span class=\"number\">001</span>a1000 <span class=\"number\">08</span>:<span class=\"number\">01</span> <span class=\"number\">7864382</span>                    /lib/x86_64-linux-gnu/libc<span class=\"number\">-2.19</span>.so</span><br><span class=\"line\"><span class=\"number\">7fe9</span>bf7f0000<span class=\"number\">-7fe9</span>bf7f2000 rw-p <span class=\"number\">001</span>a5000 <span class=\"number\">08</span>:<span class=\"number\">01</span> <span class=\"number\">7864382</span>                    /lib/x86_64-linux-gnu/libc<span class=\"number\">-2.19</span>.so</span><br><span class=\"line\"><span class=\"number\">7fe9</span>bf7f2000<span class=\"number\">-7fe9</span>bf7f6000 rw-p <span class=\"number\">00000000</span> <span class=\"number\">00</span>:<span class=\"number\">00</span> <span class=\"number\">0</span> </span><br><span class=\"line\"><span class=\"number\">7fe9</span>bf7f6000<span class=\"number\">-7fe9</span>bf7f9000 r-xp <span class=\"number\">00000000</span> <span class=\"number\">08</span>:<span class=\"number\">01</span> <span class=\"number\">7864385</span>                    /lib/x86_64-linux-gnu/libdl<span class=\"number\">-2.19</span>.so</span><br><span class=\"line\"><span class=\"number\">7fe9</span>bf7f9000<span class=\"number\">-7fe9</span>bf9f8000 ---p <span class=\"number\">00003000</span> <span class=\"number\">08</span>:<span class=\"number\">01</span> <span class=\"number\">7864385</span>                    /lib/x86_64-linux-gnu/libdl<span class=\"number\">-2.19</span>.so</span><br><span class=\"line\"><span class=\"number\">7fe9</span>bf9f8000<span class=\"number\">-7fe9</span>bf9f9000 r--p <span class=\"number\">00002000</span> <span class=\"number\">08</span>:<span class=\"number\">01</span> <span class=\"number\">7864385</span>                    /lib/x86_64-linux-gnu/libdl<span class=\"number\">-2.19</span>.so</span><br><span class=\"line\"><span class=\"number\">7fe9</span>bf9f9000<span class=\"number\">-7fe9</span>bf9fa000 rw-p <span class=\"number\">00003000</span> <span class=\"number\">08</span>:<span class=\"number\">01</span> <span class=\"number\">7864385</span>                    /lib/x86_64-linux-gnu/libdl<span class=\"number\">-2.19</span>.so</span><br><span class=\"line\"><span class=\"number\">7fe9</span>bf9fa000<span class=\"number\">-7fe9</span>bfa1a000 r-xp <span class=\"number\">00000000</span> <span class=\"number\">08</span>:<span class=\"number\">01</span> <span class=\"number\">7864371</span>                    /lib/x86_64-linux-gnu/ld<span class=\"number\">-2.19</span>.so</span><br><span class=\"line\"><span class=\"number\">7fe9</span>bfbf9000<span class=\"number\">-7fe9</span>bfbfc000 rw-p <span class=\"number\">00000000</span> <span class=\"number\">00</span>:<span class=\"number\">00</span> <span class=\"number\">0</span> </span><br><span class=\"line\"><span class=\"number\">7fe9</span>bfc16000<span class=\"number\">-7fe9</span>bfc1a000 rw-p <span class=\"number\">00000000</span> <span class=\"number\">00</span>:<span class=\"number\">00</span> <span class=\"number\">0</span> </span><br><span class=\"line\"><span class=\"number\">7fe9</span>bfc1a000<span class=\"number\">-7fe9</span>bfc1b000 r--p <span class=\"number\">00020000</span> <span class=\"number\">08</span>:<span class=\"number\">01</span> <span class=\"number\">7864371</span>                    /lib/x86_64-linux-gnu/ld<span class=\"number\">-2.19</span>.so</span><br><span class=\"line\"><span class=\"number\">7fe9</span>bfc1b000<span class=\"number\">-7fe9</span>bfc1c000 rw-p <span class=\"number\">00021000</span> <span class=\"number\">08</span>:<span class=\"number\">01</span> <span class=\"number\">7864371</span>                    /lib/x86_64-linux-gnu/ld<span class=\"number\">-2.19</span>.so</span><br><span class=\"line\"><span class=\"number\">7fe9</span>bfc1c000<span class=\"number\">-7fe9</span>bfc1d000 rw-p <span class=\"number\">00000000</span> <span class=\"number\">00</span>:<span class=\"number\">00</span> <span class=\"number\">0</span> </span><br><span class=\"line\"><span class=\"number\">7f</span>fdd05ea000<span class=\"number\">-7f</span>fdd060b000 rw-p <span class=\"number\">00000000</span> <span class=\"number\">00</span>:<span class=\"number\">00</span> <span class=\"number\">0</span>                          [stack]</span><br><span class=\"line\"><span class=\"number\">7f</span>fdd0755000<span class=\"number\">-7f</span>fdd0757000 r-xp <span class=\"number\">00000000</span> <span class=\"number\">00</span>:<span class=\"number\">00</span> <span class=\"number\">0</span>                          [vdso]</span><br><span class=\"line\"><span class=\"number\">7f</span>fdd0757000<span class=\"number\">-7f</span>fdd0759000 r--p <span class=\"number\">00000000</span> <span class=\"number\">00</span>:<span class=\"number\">00</span> <span class=\"number\">0</span>                          [vvar]</span><br><span class=\"line\">ffffffffff600000-ffffffffff601000 r-xp <span class=\"number\">00000000</span> <span class=\"number\">00</span>:<span class=\"number\">00</span> <span class=\"number\">0</span>                  [vsyscall]</span><br></pre></td></tr></table></figure>\n\n<p>三個 library 都 load 進來啦～</p>\n<p>用 gdb 在 <code>_init</code> 跟 <code>_fini</code> 設 break point 可以看到在 <code>dlopen()</code> 跟 <code>dlclose()</code> 時會分別執行 <code>libfoo.so</code> 及其他 library 的 <code>_init</code> 及 <code>_fini</code>。同樣適用 GCC 提供的 shared library constructor 及 destructor，<a href=\"/Dynamic-Linking-Relocation/\">Ref</a>。</p>\n<p>可以用 <code>ldd</code> 看 <code>libfoo.so</code> 的 dependency：</p>\n<figure class=\"highlight angelscript\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ ldd libfoo.so </span><br><span class=\"line\">        linux-vdso.so<span class=\"number\">.1</span> (<span class=\"number\">0x00007fffde785000</span>)</span><br><span class=\"line\">        ./libbar.so (<span class=\"number\">0x00007fdf77158000</span>)</span><br><span class=\"line\">        ./libkar.so (<span class=\"number\">0x00007fdf76f57000</span>)</span><br><span class=\"line\">        libc.so<span class=\"number\">.6</span> =&gt; /lib/x86_64-linux-gnu/libc.so<span class=\"number\">.6</span> (<span class=\"number\">0x00007fdf76bac000</span>)</span><br><span class=\"line\">        /lib64/ld-linux-x86<span class=\"number\">-64.</span>so<span class=\"number\">.2</span> (<span class=\"number\">0x00007fdf7755a000</span>)</span><br></pre></td></tr></table></figure>\n\n<p>如果 compile <code>libfoo.so</code> 時改變 link 的 shared library 順序，變成 <code>gcc -g -fPIC -shared -o libfoo.so foo.c ./libkar.so ./libbar.so</code>，load 到的 <code>bar()</code> 會變成是 <code>libkar.so</code> 的。</p>\n<figure class=\"highlight llvm\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ ./main</span><br><span class=\"line\">fn = a<span class=\"number\">259</span><span class=\"keyword\">c</span><span class=\"number\">740</span></span><br><span class=\"line\">foo = a<span class=\"number\">259</span><span class=\"keyword\">c</span><span class=\"number\">740</span>, &amp;zoo = a<span class=\"number\">279</span>caf<span class=\"number\">0</span>, &amp;coo = a<span class=\"number\">259</span><span class=\"keyword\">c</span><span class=\"number\">7</span>a<span class=\"number\">8</span></span><br><span class=\"line\"><span class=\"keyword\">ret</span> = <span class=\"number\">8</span></span><br><span class=\"line\">p = a<span class=\"number\">279</span>caf<span class=\"number\">0</span></span><br><span class=\"line\"><span class=\"keyword\">c</span> = a<span class=\"number\">259</span><span class=\"keyword\">c</span><span class=\"number\">7</span>a<span class=\"number\">8</span>, *<span class=\"keyword\">c</span> = <span class=\"number\">5566</span></span><br><span class=\"line\">bar() in kar.<span class=\"keyword\">c</span></span><br></pre></td></tr></table></figure>\n\n<p><code>ldd</code> 看到的順序也會變：</p>\n<figure class=\"highlight angelscript\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ ldd libfoo.so </span><br><span class=\"line\">        linux-vdso.so<span class=\"number\">.1</span> (<span class=\"number\">0x00007fff4db40000</span>)</span><br><span class=\"line\">        ./libkar.so (<span class=\"number\">0x00007f5b4ddb5000</span>)</span><br><span class=\"line\">        ./libbar.so (<span class=\"number\">0x00007f5b4dbb4000</span>)</span><br><span class=\"line\">...</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Related-posts\"><a href=\"#Related-posts\" class=\"headerlink\" title=\"Related posts\"></a>Related posts</h2><ul>\n<li><a href=\"/Dynamic-Linking-Basic/\">Dynamic Linking Basic</a></li>\n<li><a href=\"/Dynamic-Linking-PIC/\">Dynamic Linking PIC</a></li>\n<li><a href=\"/Dynamic-Linking-Relocation/\">Dynamic Linking Relocation</a></li>\n<li><a href=\"/Shared-Library-Versioning/\">Shared Library Versioning</a></li>\n<li><a href=\"/Use-Shared-Library-in-Linux/\">Use Shared Library in Linux</a></li>\n</ul>\n","tags":["Linux","System Software"]},{"title":"Design Models for Concurrent Algorithems","url":"/design-models-for-concurrent-algorithems/","content":"<p>這篇是設計 concurrent algorithem 的理論概念，沒什麼例子。</p>\n<p>兩種設計 concurrent algorithem 的方法：</p>\n<ul>\n<li>Task Decomposition：計算是一堆獨立的 task，可以由 thread 以任意順序執行。</li>\n<li>Data Decomposition：程式處理大量資料，其中個別 element 的計算可以獨立執行。</li>\n</ul>\n<h2 id=\"Task-Decomposition\"><a href=\"#Task-Decomposition\" class=\"headerlink\" title=\"Task Decomposition\"></a>Task Decomposition</h2><p>task decomposition 的目標是找出完全獨立的計算，才能 concurrent 執行多個 task。但是計算常常互相有關係，這樣的關係稱為 dependency。程式平行化前必須先消除 dependency。</p>\n<p>將 sequential 程式轉成 concurrent 程式要確保原本有順序性的步驟也要依序完成，也就是確保 sequential consistency，使得 concurrent 程式在相同的 input 可以得到跟 sequential 程式一樣的結果。</p>\n<p>concurrent 程式的基本架構：main thread 定義以及準備 task，產生 thread 執行 task，最後等待 thread 們完成工作。</p>\n<p>一種分解 task 的方式是在要進行 concurrent 計算的外層進行分解，接著將 task 分給 thread 執行。另一種是 task 會在計算過程中動態產生，這需要額外程式碼封裝新產生的 task。</p>\n<p>Task Decomposition 要考慮：</p>\n<ol>\n<li>task 是什麼以及如何定義？</li>\n<li>task 間的 dependency 為何以及如何滿足？</li>\n<li>task 如何分派給 thread？</li>\n</ol>\n<h3 id=\"task-是什麼以及如何定義？\"><a href=\"#task-是什麼以及如何定義？\" class=\"headerlink\" title=\"task 是什麼以及如何定義？\"></a>task 是什麼以及如何定義？</h3><p>基本上，要識別出能獨立執行的 task，得依靠對程式以及其計算的理解。要對可能平行化執行的程式模擬兩個 thread 一起執行的狀況<em>（真心覺得這靠練習跟經驗，做多了自然會有莫名的直覺(?)）</em>，以此決定 task 是否彼此獨立或有可接受的 dependency。</p>\n<p>並行化（concurrent）程式執行最頻繁或者計算最繁重的地方可以有比較好的成效。因為並行化需要修改程式碼、驗證以及debug 等等，也會讓程式變得複雜，當然要選擇最有成效的地方做。除此之外，concurrent 程式會比 sequential 程式多出為了並行化的程式碼，例如管理及分派 task，所以會有 overhead。</p>\n<p>找到可以獨立執行的 task 後，拆分 task 需注意：</p>\n<ol>\n<li>task 數量至少要跟 thread 或 core 數量一樣多。<br>確保不會有 idle 的 thread，能達到較好的 load balance。</li>\n<li>每個 task 的計算量（granularity）必須大到能抵消管理 task 及 thread 的 overhead。<br>coarse-grained 代表 granularity 高（task 的計算量高），fine-grained 代表 granularity 低。如果 task 的 granularity 不夠大，光是管理 task 跟 thread 的 overhead 就把效能提升給吃光了。</li>\n</ol>\n<p>這兩個條件看起來有點矛盾，因為在總 task 固定的情況下 task 愈大數量愈少，反之亦然，因此    要在 task 計算量及數量間取得平衡。並行化（concurrent）程式最主要的目的是減少執行時間，如果使用所有 core/thread 卻需要較長執行時間，寧可調整為使用較少 core/thread 但執行時間較短的 task decomposition。</p>\n<p>拆分 task 可能需要多次嘗試，一個切法的效果不太好，就應該嘗試其他分解方式。</p>\n<h3 id=\"task-間的-dependency-為何以及如何滿足？\"><a href=\"#task-間的-dependency-為何以及如何滿足？\" class=\"headerlink\" title=\"task 間的 dependency 為何以及如何滿足？\"></a>task 間的 dependency 為何以及如何滿足？</h3><p>task 間的 dependency 有兩種：</p>\n<ol>\n<li>執行順序的 dependency<br>某些 task 必須等其他 task 完成才能做，可能是需要前面 task 的結果作為參數。<br>要滿足執行順序 dependency 最簡單的方式是將有此 dependency 的 task 交給同一個 thread 執行。但當某 task 需要許多 thread 的 task 完成後才能執行，或者 thread 間有執行順序的限制（例如要 thread1 做完前幾步 thread2 才能執行），而且無法以其他 task decomposition 處理時就得加入 synchoronization 機制來確保 thread 間的執行順序。</li>\n<li>data dependency<br>區分是否有 data dependency 的方法：先列出所有 assignment 左邊的變數，檢查這些變數是否有並行（concurrent）寫入或者寫入與讀取會並行發生的狀況，因為至少要有一個 thread 寫入變數才會有 data dependency。找到 data dependency 後就要看能不能消除 dependency。消除 data dependency 有很多種作法，最簡單的是以互斥存取（mutually exclusive access）的方式 access shared data，也就是使用 lock 或 mutex 保護資料。</li>\n</ol>\n<p>消除 dependency 的方法很多，不見得都得用 mutually exclusive access，如果可以以消除 dependency 的作法來達到 concurrency，就可以減少使用 synchoronization 物件帶來的 overhead。</p>\n<h3 id=\"task-如何分派給-thread？\"><a href=\"#task-如何分派給-thread？\" class=\"headerlink\" title=\"task 如何分派給 thread？\"></a>task 如何分派給 thread？</h3><p>thread 執行時希望各 thread 有差不多的計算量，平衡 thread 們的 loading。</p>\n<p>兩種分派 task 的方式：static scheduling 以及 dynamic scheduling。</p>\n<p>static scheduling 會要並行化（concurrent）的計算外面決定 task 的切分，而且計算過程中不會改變。實作 static scheduling 會讓 N 個 thread 有 0 到 N-1 的唯一識別碼，可以透過識別碼分派 task 給 thread。static scheduling 適用於每個 task 的運算量差不多，或是能預先知道計算量的情況。反之，各 task 計算量變動大或無法預先知道的狀況比較適合 dynamic scheduling。</p>\n<p>dynamic scheduling 在計算過程中才將 task 指派給 thread，會儘量平均各 thread 的計算量，理想上會有較好的 load balance。分派 task 給 thread 以及 thread 找新 task 的邏輯是原先 sequential 程式沒有的，這些額外的邏輯當然有 overhead。</p>\n<p>最簡單的 scheduling 是為 task 加上 index，用 counter 記錄下一個要分派的 task，當 thread 要新 task 時就從 counter 得知拿哪個 task。這個 counter 是 thread 間共用的，因此 access 它需要 mutually exclusive。另一種 dynamic scheduling 使用 shared container 保存 task，通常會用 queue，thread 從 container 拿新 task 執行，例如 producer-consumer 就是這種方式的變形。因為放在 container 裡，task 必須被封裝成可以放進 container 的結構，例如可能是一包描述 task input 的 structure。</p>\n<h2 id=\"Data-Decomposition\"><a href=\"#Data-Decomposition\" class=\"headerlink\" title=\"Data Decomposition\"></a>Data Decomposition</h2><p>計算是一連串更新一個或多個巨大 data structure 中的 element 時，如果這些更新是彼此獨立的，則可以切割 data structure 並將不同部份分給不同 thread 處理，進而達到並行化（concurrent）。切割 data structure 並交給 thread 處理的方法稱為 data decomposition。</p>\n<p>如何將 data structure 切割成多個連續區域（稱為 chunk）取決於 data structure 的 type，例如常見的 array 會依照 dimension 來切割。</p>\n<p>將資料分割成 chunk 也代表將整個計算分解成針對單一 chunk 的 task，這些 task 會分配給 thread 執行。由於資料是已經分解過的，所以 thread 可以安心使用這些 data，不需要擔心其他 thread 也會使用到。但如果計算需要 chunk 鄰近的資料，task 間就得共享這些資料，thread 也需要彼此協調資料存取。</p>\n<p>data decomposition 要考慮：</p>\n<ol>\n<li>如何將資料分割成 chunk？</li>\n<li>如何確保 task 能 access 到其計算所需的所有資料？</li>\n<li>如何分派 chunk 給 thread？</li>\n</ol>\n<h3 id=\"如何將資料分割成-chunk？\"><a href=\"#如何將資料分割成-chunk？\" class=\"headerlink\" title=\"如何將資料分割成 chunk？\"></a>如何將資料分割成 chunk？</h3><p>每個 chunk 都跟 task 有關，要考慮上述 task 的幾個條件，除此之外還需要注意：</p>\n<ol>\n<li>每個 thread 至少分到一個 chunk，每個 thread 分到的 chunk 愈多愈好。</li>\n<li>處理 chunk 的計算量要遠大於分割 data 所產生的 overhead。<ol>\n<li>task 處理 chunk 需要的計算量一樣稱為 granularity，granularity 跟 chunk 中的 element 數量有關。</li>\n<li>分割 data 還需要考慮 chunk 的 shape（就是形狀啦）。chunk 的 shape 決定了跟相鄰 chunk 的關係以及計算時如何處理資料交換，shape 並不見得是畫得出來、看得到的形狀，而是 chunk 之間的「關係」。資料交換是為了計算與更新自己的資料而需要去 access 別人（別的 chunk）的資料。如果每個 chunk 的邊界（處在邊界的 element）都需要資料交換，減少整體邊界數量就能減少資料交換。針對每個 chunk 減少與其相鄰的 chunk 數量也能降低交換資料的程式複雜度，因為一個 chunk 與愈多 chunk 相鄰代表一個 task 跟更多 task 有關聯。</li>\n</ol>\n</li>\n</ol>\n<p>考慮 chunk 的 shape 時，granularity 愈大表示 chunk 擁有的 element 數量愈多，也代表有愈多需要資料交換的 element，因此資料交換的 overhead 愈大，又需要在 shape 與 granularity 之間取得平衡。針對這個問題，一個解法是最大化 volume-to-surface ratio，也就是 chunk 的 element 數量與需要交換資料的邊界比例，也就是 <code>chunk 的 element 數 / chunk 中在邊界的 element 數</code>。例如一個 4 x 8 的資料（想像一個二維陣列），分割成兩個 2 x 8 的 chunk，volume-to-surface ratio 是  16 / 8 = 2，分割兩個 4 x 4 的 chunk 則是 16 / 4 = 4。</p>\n<h3 id=\"如何確保-task-能-access-到其計算所需的所有資料？\"><a href=\"#如何確保-task-能-access-到其計算所需的所有資料？\" class=\"headerlink\" title=\"如何確保 task 能 access 到其計算所需的所有資料？\"></a>如何確保 task 能 access 到其計算所需的所有資料？</h3><p>如果 chunk 內包含計算與更新所需的所有資料，task 間就不需要協調資料交換<del>（這不是廢話）</del>。反之，如果計算需要鄰近 chunk 的資料，就得找出較有效率的資料交換機制。一般有兩種方法：將資料從鄰近 chunk 複製到 task/thread 的 local structure，或者直接 access 鄰近 chunk 的資料。</p>\n<p>如果鄰近 chunk 的資料不會隨著計算改變，複製資料是比較容易的方法，因為不需要處理同步問題。缺點是需要額外的儲存空間存放資料副本。這些額外配置的儲存空間一般稱為 ghost cells。複製資料也需要考慮複製次數，如果次數太多或每次複製太多資料，比較適合直接 access 鄰近 chunk 的資料。</p>\n<p>直接 access 鄰近 chunk 的資料可以利用 thread 間以 shared memory 為基礎的溝通機制，在真正需要資料前也可以不用協調。缺點是必須確保拿到正確的資料，尤其是鄰近 chunk 也會更新其資料的時候。要確保拿到正確的資料，得找出計算過程中資料交換與更新資料間的關係或互動，才能知道如何協調。有些 sequential 程式計算 element 時需要鄰近 element 的舊資料而非更新後的新資料，此時 sequential 程式與 concurrent 程式遇到的問題是一樣的，concurrent 程式有時能借用 sequential 程式的解法。</p>\n<h3 id=\"如何分派-chunk-給-thread？\"><a href=\"#如何分派-chunk-給-thread？\" class=\"headerlink\" title=\"如何分派 chunk 給 thread？\"></a>如何分派 chunk 給 thread？</h3><p>類似 task decomposition，與 chunk 關聯的 task 可以用 static 或 dynamic scheduling 指派給 thread。static scheduling 所有跟資料交換有關的協調可以在計算外面、也就是計算開始前處理好，適合 task 的計算是一致或可預期的情況。如果 task 處理各 chunk 的計算量不一致，dynamic scheduling 可能有比較好的 load balance，但也讓資料更新、交換以及與其他 task 協調變得複雜。</p>\n<p>data decomposition 中 task 是由資料的分解方式定義的，應該以 task 間的關係找出所需的互動，不管這個 task 是由哪個 thread 執行。</p>\n<h2 id=\"選擇-Design-Model-需考量的因素\"><a href=\"#選擇-Design-Model-需考量的因素\" class=\"headerlink\" title=\"選擇 Design Model 需考量的因素\"></a>選擇 Design Model 需考量的因素</h2><p>在做 task 或 data decomposition 時，會考量以下四個因素以建立最有效率的 concurrent solution：</p>\n<ol>\n<li>Efficiency（效率）<br>效率必須考慮 concurrency 帶來的額外 overhead、thread 的調配以及 task 的組織方式等等問題。</li>\n<li>Simplicity<br>concurrent algorithem 愈簡單愈容易開發、debug、驗證以及維護。simplicity 著重在要加多少額外程式碼才能將程式並行化（concurrent）。</li>\n<li>Portability<br>使用不同 multiple threading model 的取捨。</li>\n<li>Scalability<br>考量 concurrent 程式在不同 core/thread 數以及 data set 上的行為如何。照目前的趨勢，機器的 core 數會愈來愈多，concurrent 程式應該要能夠有效率的在不同數量的 thread/core 或不同大小的 data set 上執行。</li>\n</ol>\n<p>重要性：scalability &gt; efficiency &gt; simplicity ~ portability</p>\n<p>有時候 concurrent 程式的 scalability 會在某個階段達到高峰後趨於平緩，這可能是因為 algorithem 的需求或是 threading model 提供的環境。遇到這種狀況要評估是否值得花更多力氣嘗試提高 scalability 或者使用不同的 threading model 重新寫過。</p>\n","tags":["Concurrency"]},{"title":"The Clean Coder","url":"/the-clean-coder/","content":"<p>Bob 大叔的書之一《The Clean Coder》，算是《Clean Code》的續集吧。</p>\n<p>《Clean Code》講怎麼寫 code，《The Clean Coder》講怎麼當 clean coder。記錄些心有戚戚焉的片段跟感想。</p>\n<h2 id=\"測試\"><a href=\"#測試\" class=\"headerlink\" title=\"測試\"></a>測試</h2><blockquote>\n<p>設計「易於測試的程式碼」(p.48)</p>\n</blockquote>\n<p>我想設計良好的程式應該也會好測試？從設計還是從測試出發，最後目標是一樣的，偏好哪種我覺得沒什麼差。</p>\n<p>到目前為止，我大多從設計出發。先想概略設計、class 的責任、class 之間的關係等等，接著實作會邊寫功能邊寫測試，但不是 TDD。通常是實作一小塊、寫那一小塊的測試，而不是先寫測試才實作。即使從設計出發還是需要測試的，因為可以確保程式是對的，之後也不怕修改。</p>\n<p>沒有實際用 TDD 寫 code，只在 dojo 小小玩過，所以說不上從測試出發是不是會導向好設計，能想像的只有因為要測試所以功能切分上應該不會太糟。</p>\n<a id=\"more\"></a>\n\n<blockquote>\n<p>這一策略有時也叫無情重構（merciless refactoring），我稱它叫作「童子軍規則」：對每個模組，每次 check in 程式碼，就要讓它比上次 checked out 時更為簡潔。(p.49)</p>\n</blockquote>\n<p>幾年前曾經聽一位大師說過，不過很多時候不要弄得更亂已經謝天謝地了，偶爾才順手修一點。</p>\n<blockquote>\n<p>如果你有一套覆蓋了所有程式碼的自動化測試，如果那套測試可以隨時快速執行，那麼你根本不會害怕修改程式碼。(p.50)</p>\n</blockquote>\n<blockquote>\n<p>看到混亂的函式時，你的第一反應是：「真是一團糟，這個函式需要整理。」你的第二反應是：「我不會去碰它！」為什麼？因為你知道，如果去動它，就要冒著破壞它的風險；而如果你破壞了它，那麼它就纏上你了。</p>\n<p>但是如果你能確信自己的整理工作不會破壞任何東西，那又會是怎樣的一個情況呢？如果你擁有我剛才提到的那種把握，會怎樣呢？如果你只需按下一個按鈕，然後在 90 秒內便可以確信你的修改沒有破壞任何東西，只是讓程式碼變得更好了，那麼又會是怎樣的一種情況呢？</p>\n<p>這就是 TDD 最強大之處。擁有一套值得信賴的測試，便可完全打消對修改程式碼的全部恐懼。當看見糟糕的程式碼時，就可以放手整理。程式碼會變得具有可塑性，你可以安全地將之雕琢成簡單而滿意的結構。(p.113)</p>\n</blockquote>\n<p>呵呵呵……真的。看到一團亂 code 覺得該整理又立刻覺得不想碰它。改了就得保證它還是正常的，再小的變動都無法確保不會弄壞些什麼。因為就是會自認不會有問題的修改卻在意想不到的地方壞掉（通常 code 愈沒有分清楚權責愈容易發生這種事）。沒測試可能沒發現改壞，沒有完整的測試可能沒發現壞在其他地方。在測試得花費時間的情況下，我通常不會碰路過看到的亂 code，不然就是賭人品簡單測過就「相信它是好的」。完整的自動化測試是個很好的保護措施，如果能確保東西不會改壞，就能安心修整雜亂的 code。</p>\n<p>現實總是不美好，在沒有自動化測試的情況下，我的變通方式是「在加新功能或修改功能時順便整理」。如果可以也會一起加入 unit test。因為會改 code（雖然以一些設計原則來說，加新功能所需修改的 code 應該不多甚至沒有），測試時也會確認舊有功能是否正常，既然本來就要測，就能順便整理啦。</p>\n<h3 id=\"GUI-的測試\"><a href=\"#GUI-的測試\" class=\"headerlink\" title=\"GUI 的測試\"></a>GUI 的測試</h3><blockquote>\n<p>編寫 GUI 的驗收測試時，必須使用 GUI 背後相對穩定的抽象元素。</p>\n</blockquote>\n<blockquote>\n<p>測試系統功能時，應當呼叫真實的 API，而不是 GUI。</p>\n</blockquote>\n<blockquote>\n<p>要把 GUI 和業務邏輯分開。</p>\n</blockquote>\n<blockquote>\n<p>透過 GUI 來進行測試非常容易出問題，除非你要測試的僅僅只有 GUI。因為 GUI 很容易變化，所以針對 GUI 的測試很不穩定。</p>\n</blockquote>\n<blockquote>\n<p>最好把 GUI 和業務規則「去耦合」，在測試 GUI 本身時，用 Stubs（一種測試替身）替代業務規則。(p.139)</p>\n</blockquote>\n<p>像 submit form 用 post data 去測，測試 business logic 要用 API 測而不要用 GUI 操作測。js object 中功能及邏輯部份跟 UI element 分得愈開愈好，這樣才能測功能跟邏輯而不用管變動性很大的 UI element。只有在要測試的東西就是「GUI 本身」才用 GUI 測試。</p>\n<h3 id=\"TDD-三大法則\"><a href=\"#TDD-三大法則\" class=\"headerlink\" title=\"TDD 三大法則\"></a>TDD 三大法則</h3><ol>\n<li>在撰寫一個單元測試（測試失敗的單元測試）前，不可撰寫任何產品程式。</li>\n<li>只撰寫剛好無法通過的單元測試，不能編譯也算無法通過。</li>\n<li>只撰寫剛好能通過當前測試失敗的產品程式。</li>\n</ol>\n<p>看這本書前就聽過某大師講過，還是記錄一下免得難找 XD</p>\n<h3 id=\"測試金字塔\"><a href=\"#測試金字塔\" class=\"headerlink\" title=\"測試金字塔\"></a>測試金字塔</h3><ul>\n<li>人工探索式測試：約 5%</li>\n<li>系統測試：約 10%</li>\n<li>整合測試：約佔 20%</li>\n<li>元件測試：50% 覆蓋</li>\n<li>單元測試：近乎 100% 覆蓋</li>\n</ul>\n<h2 id=\"需求測不準定理\"><a href=\"#需求測不準定理\" class=\"headerlink\" title=\"需求測不準定理\"></a>需求測不準定理</h2><blockquote>\n<p>有一種現象叫作「觀察者效應」或稱為「不確定原則」。每次你向業務方展示一項功能，他們就獲得了比之前更多的資訊，這些新資訊反過頭來又會影響他們對於整個系統的看法。(p.127)</p>\n</blockquote>\n<p>偷拿物理來用！XD</p>\n<blockquote>\n<p>做業務的人和寫程式的人都容易陷入一個陷阱，即「過早進行精細化」。</p>\n<p>一看到需求已經被滿足，關於到底要什麼，他們就會冒出更好的想法──通常那不會是他們當時看到的樣子。(p.127)</p>\n</blockquote>\n<p>這也是 RD 會覺得很幹的地方。</p>\n<p>RD 的心聲：「怎麼拼命滿足了需求，demo 的時候又說要這個要那個？跟之前說的又不一樣，到底是怎樣？」</p>\n<p>雖然我能稍微理解對其他人來說，會以現在看到的東西為基礎再更進一步知道更確切的需求，但我自己在 demo 聽到要這個又要那個，有時候難免升起一把火，尤其是中間要是遇到很麻煩的問題好不容易解掉了之類的。<del>想想好像是修養不夠…</del></p>\n<p>如果體認到「需求一定會一直變」，能做點因應是比較好的，例如用些設計原則跟方式，降低需求變動時的修改難度。</p>\n<blockquote>\n<p>開發人員也會掉進精確化的陷阱。他們知道必須評估整個系統，而且通常認為需要精確評估。但是，事實並非如此。</p>\n<p>首先，即便擁有全面準確的資訊，評估也通常存在著巨大的變數。其次，因為「不確定原則」的存在，所以不可能透過反覆推敲而實現早期的精確性。需求是一定會變化的，所以追求那種精確性是白作工的。</p>\n<p>專業開發人員知道，預估可以並且必須基於「那不怎麼精確的需求」，這些預估只是預估而已。為了強調這點，專業開發人員通常會在預估中使用誤差棒，這樣業務方就能理解不確定性。(p.127)</p>\n</blockquote>\n<p>我曾經希望完整知道整個系統的細節後才評估，可是沒多久就發現辦不太到，有太多因素導致系統某些部份是不那麼確定的，例如 third party 複雜的使用方式、商業流程尚未確定、domain knowledge 不足、系統的隱藏問題等等。以至於無論如何避免，還是會在做下去後發現這裡缺了那裡漏了，或者後來才知道這個 domain 有些觀念是一開始不曉得的。</p>\n<p>既然無法一開始完整知道所有細節，只好換個方法。首先，設計時在一個程度上保持軟體的彈性，但不過度使用複雜的 pattern 增加彈性，只要降低 component 間的耦合度就能讓往後的修改不那麼難。其次，雖然系統中有不確定性很高的地方，卻也有「現在就能確定」的部份，所以我會將不確定的部份劃分在系統的某一塊並且對它有個基本結構的想法，先實作現在確定的部份。隨著時間推進，原本不太確定的部份可能變得確定，例如幾天後拿到 API 文件、確定了商業流程等等，到這時再做細部設計跟實作。</p>\n<blockquote>\n<p>避免過早精細化的辦法是盡可能地「推遲」精細化。(p.127)</p>\n</blockquote>\n<p>我算是在針對系統不確定性高的部份推遲「精細化」，延遲細部確認各種作法跟設計。</p>\n<h3 id=\"三元分析法\"><a href=\"#三元分析法\" class=\"headerlink\" title=\"三元分析法\"></a>三元分析法</h3><p>可以用來預估時程。</p>\n<ul>\n<li>O：樂觀預估（Optimistic Estimate）<ul>\n<li>非常樂觀的數字。如果一切異常順利，可以在這個時間內完成。</li>\n<li>發生機率應小於 1%</li>\n</ul>\n</li>\n<li>N：常規預估（Nominal Estimate）<ul>\n<li>機率最大的數字。</li>\n</ul>\n</li>\n<li>P：悲觀預估（Pessimistic Estimate）<ul>\n<li>非常悲觀的數字。考慮各種意外狀況的預估。</li>\n<li>發生機率應小於 1%</li>\n</ul>\n</li>\n</ul>\n<p>任務的期望完成時間：</p>\n<p><code>u = (O + 4N + P) / 6</code></p>\n<p>任務完成時間的機率分佈標準差，用來衡量不確定性：</p>\n<p><code>a = (P - O) / 6</code></p>\n<p>讓預估時程是個機率分佈，而非一個聽起來確定（實際上根本是瞎猜）的值。</p>\n<h2 id=\"溝通\"><a href=\"#溝通\" class=\"headerlink\" title=\"溝通\"></a>溝通</h2><blockquote>\n<p>通常，各方握手言歡，以為其他人都明白自己的意思。雙方以為取得了共識，然後帶著截然不同的想法離開，這種事屢見不鮮。(p.140)</p>\n</blockquote>\n<p>這超級無敵容易發生。</p>\n<p>人類語言十分不精確，一個字詞對不同人可能有不同意義或解讀。有精確意義的科學或工程術語還好，但大多數討論需求是不會用這種術語的<del>（會逼死客人或業務）</del>，而需求描述卻是軟體開發非常需要清楚確認的部份。如果不確認過某些字詞的精確意義，或者不在過程中不斷的確認彼此的意思，非常容易出現大家都說 A 可是我的是 A、你的是 a、他的是 A’，等到東西做下去才發現怎麼通通不一樣<del>，然後又要改，RD 哭哭</del>。</p>\n<p>Bob 大叔解決溝通問題的方式是使用驗收測試，但我還沒有很了解為什麼驗收測試可以解決溝通問題，是因為驗收測試足夠精確並且是由業務端認可過的？</p>\n<blockquote>\n<p>「凡是不能在 5 分鐘內解決的爭論，都不能靠辯論解決。」這類爭論之所以要花這麼多時間，是因為各方都拿不出「足夠有力的證據」來支持己見。所以這類爭論依據的不是「事實」，而是「信念」。</p>\n<p>在沒有資料的情況下，如果觀點無法在短時間（5 ~ 30 分鐘）內達成一致，就永遠無法達成一致。唯一的解決方法是「去取得資料，讓資料來說話」。</p>\n<p>該怎麼得到解決問題所需要的資料呢？有時候可以做一些實驗，也可以做些模擬或是建立模型。但是有些時候，最好的辦法是拋硬幣來決定到底該如何選擇。</p>\n<p>如果爭論必須解決，就應當要求爭論各方在 5 分鐘內向大家表明問題，然後大家投票。(p.151)</p>\n</blockquote>\n<p>愈缺乏客觀知識、資料或數據的討論，愈容易陷入主觀之爭。而陷入主觀之爭，往往誰也無法說服誰，容易變成長時間的辯論，到最後只是看誰肯先讓步。</p>\n<h2 id=\"專注力\"><a href=\"#專注力\" class=\"headerlink\" title=\"專注力\"></a>專注力</h2><blockquote>\n<p>專業開發人員會學習安排時間，妥善使用自己的專注力點數。我們選擇專注力點數充裕的時候進行程式設計，在專注力點數匱乏時做其他事情。(p.152)</p>\n</blockquote>\n<blockquote>\n<p>一旦專注力點數耗盡，你就無法控制專注力。你仍然可以寫程式，但是多半寫出來的程式需要在第二天重寫，或者在幾週或幾個月之後備受這段程式碼的煎熬。所以，更好的辦法還是花 30 ~ 60 分鐘來換換腦子。(p.153)</p>\n</blockquote>\n<p>想睡覺的時候不要寫 code 不要寫 code 不要寫 code。</p>\n<p>這念書的時候就有所感了，因為我基本上無法熬夜，愈晚腦子愈頓。想睡覺寫出來的東西往往不知道在幹嘛，與其寫出一堆不知道在幹嘛、事後還要重改的東西，不如去休息。這才是效率啊。</p>\n<h2 id=\"壓力\"><a href=\"#壓力\" class=\"headerlink\" title=\"壓力\"></a>壓力</h2><blockquote>\n<p>觀察自己在危機時刻中的反應，就可以瞭解自己的信念。如果在危機中依然遵循著你在常規狀況下遵循的紀律，就說明你確實相信那些紀律。反過來說，如果在危機中改變了行為，就說明你並不真的相信常規行為中的紀律。</p>\n<p>選擇那些「你在危機時刻依然會遵循的紀律原則」，並且在所有工作中都遵守這些紀律。遵守這些紀律原則是避免陷入危機的最好途徑。(p.172)</p>\n</blockquote>\n<blockquote>\n<p>當事情十分困難時，要堅信你的紀律原則。之所以你會將之奉為紀律，是因為他們可以指引你度過高壓時期。(p.173)</p>\n</blockquote>\n<p>我想到飛行訓練或者任何有風險運動的練習。這些活動遇到危機或危險，通常不會希望自己整個亂掉、胡亂跑亂衝，能依靠的應該是平常練習中的訓練、紀律以及習慣。同理，軟體開發遇到危機應該更要依靠平常的習慣跟紀律，而非打亂原本的工作方式。</p>\n<h2 id=\"協作\"><a href=\"#協作\" class=\"headerlink\" title=\"協作\"></a>協作</h2><blockquote>\n<p>深刻理解業務目標。<br>你需要理解「手上正在撰寫的程式碼，其業務價值是什麼」(p.177)</p>\n</blockquote>\n<p>有時候知道業務價值會比較有動力。</p>\n<p>有時候知道業務價值才能判斷 solution 對不對，尤其是討論對象一開始就是 RD 的時候。以目前的經驗來說，RD 似乎很容易直接進入 solution 的細部討論，萬一一開始理解錯業務價值或目標或者一開始 solution 是錯的，後續 RD 間無論如何討論細部都無法達到業務重點。</p>\n<blockquote>\n<p>不正常的團隊最糟糕的症狀是，每位程式設計師在自己的程式碼週邊築起一道高牆，拒絕讓其他程式設計師接觸到這些程式碼。</p>\n<p>將程式碼所有權的各種隔斷全部打破、由整個團隊共同擁有全部程式碼的做法，相較於上述方式要好得多。我讚同這種做法：團隊中每位成員都能簽出任和模組的程式碼，做出任何他們認為合適的修改。我期望擁有程式碼的是整個團隊，而非個人。(p.180)</p>\n<p>儘管每位團隊成員都有自己的位置，但在緊要關頭時，每位團隊成員也要能夠接替其他人的位置。(p.181)</p>\n</blockquote>\n<p>嘛，我同意原作者容易修改自己寫的程式，改起來可能比較快，但這是我唯一想得到這種「護住地盤」行為可能的好處了。所有人都能改所有程式碼，好處就像 Bob 大叔說的其他人可以看到盲點、提供不同意見、每個人都可以接替其他人的位置等等。</p>\n<p>我好像除非完全是自己的 project，不然不怎麼在意別人看或改我寫的 code（只要別把結構愈改愈爛就好）。而且我也不怎麼喜歡讓自己成為「唯一能修改或看得懂某一塊程式的人」，因為……這樣放假還可能被找很煩，呃，咳咳，我只是覺得工作的時候就專心工作、放假的時候就好好放假。另外，東西其他人能接手代表我可以再去做其他東西。</p>\n","tags":["Reading"]},{"title":"Shared Library Versioning","url":"/Shared-Library-Versioning/","content":"<h2 id=\"相容性問題\"><a href=\"#相容性問題\" class=\"headerlink\" title=\"相容性問題\"></a>相容性問題</h2><p>使用 library 其中一個目標是不需要重新 compile 就能方便的升級程式的部份功能或者修正 bug。理想上，升級 library 只需要用新的檔案取代舊的。但是事情沒那麼美好，舊程式不見得能正常使用新 library，新舊程式間會有相容性問題。</p>\n<p>依據舊程式能不能使用新 library，library 的更新分為相容更新與不相容更新。相容更新通常不修改 interface，可能只是修正 bug 或者加點新東西。不相容更新則改變了 interface，這時舊版程式無法正常使用新版 library。</p>\n<p>library 以 binary 的形式發佈，代表 interface 是 binary 層級，也就是 ABI（Application Binary Layer），包含 call function 的 stack 結構、symbol 命名、memory 配置、參數的結構等等。</p>\n<p>ABI 跟語言有很大關係，以 C 語言來說，只要跟 export 的 symbol（function 跟 variable）有關的修改，都會動到 ABI，例如增加 export 變數、增減 export 的 function 參數、修改 export 的資料結構（會改變 memory 配置，程式依舊配置使用新結構會踩壞記憶體）等等。至於 C++ <del>基本上是場災難</del>，因為各家 compiler 甚至相同 compiler 的不同版本可能都對 C++ 的各種特性諸如 virtual function 等有不同實作方式，這會造成 ABI 不相容。C++ 有一些避免改到 interface 的原則及作法，例如 pimpl。</p>\n<h2 id=\"版號\"><a href=\"#版號\" class=\"headerlink\" title=\"版號\"></a>版號</h2><p>既然有相容性問題，程式如何知道能不能使用新 library？系統必須有方法確保相容性、讓程式能正常執行，其中一個方法是以版號區分不同版本的 library，並讓程式指定它相容於哪些版本的 library。</p>\n<p>在 Linux 系統中，shared library 的檔案命名規則為 <code>libname.so.x.y.z</code>。最前面是字首 <code>lib</code>，中間是 library 名稱，接著 <code>.so</code>，最後跟著三個版號數字。<code>x</code> 表示 major versison number，<code>y</code> 是 minor version number，<code>z</code> 為 release version number。</p>\n<p>major version number 代表 library 有重大升級，不同 major version number 的 library 是不相容的。使用舊版的程式必須要經過修改及重新 compile 才能使用新版 library。系統中需要保留舊版 library 以讓未更新至使用新版 library 的程式依然能正常執行。</p>\n<p>minor version number 表示 library 是增量升級，也就是加一些新的 interface 並且保持原本的 symbol 在名稱與語意上皆不變，例如增加一個 function。在 major version number 相同的狀況下，高 minor version number 的 library 向後相容低 minor version number 的 library，使用舊版 library 的程式可以使用新版 library，例如使用 <code>1.1.z</code> libary 的程式可以在 <code>1.2.z</code> library 上正常執行。</p>\n<p>release version number 是 library 的 bug 修正、效能改進等等，不添加新 interface 也不改動舊 interface。因此相同 major version number 以及 minor version number 的不同 release version 之間的 library 完全相容，依賴某個 release version 的程式可以使用其他任一 release version。</p>\n<h3 id=\"SO-NAME\"><a href=\"#SO-NAME\" class=\"headerlink\" title=\"SO-NAME\"></a>SO-NAME</h3><p>library 有版號之後，程式如何指定使用的 library 版本？</p>\n<p>在 Solaris 跟 Linux 裡採用 SO-NAME 命名機制，SO-NAME 是 library 版號只保留 major version number，去掉 minor version 以及 release version，例如 <code>libfoo.so.3.2.1</code> 的 SO-NAME 是 <code>libfoo.so.3</code>。</p>\n<p>Linux 系統會建立檔名為 SO-NAME 並指向 major version 相同、最新 minor 及 release version 的 library 實體檔案的 soft link，例如 <code>/usr/lib/libcln.so.6</code> 指向 <code>/usr/lib/libcln.so.6.0.4</code>。這麼做的好處是系統中的程式只需要記錄 library 的 SO-NAME，再藉由 soft link 就能使用該 major version 最新的 library。</p>\n<p>記錄 SO-NAME 提供了一些彈性，讓 library 有一定的升級空間，不會讓程式只限定於某版本的 library。同時又能知道何種狀況是大幅度的更新，系統不應該自動使用新 major version 的 library，需保留舊版 library 讓使用的程式可以正常執行。當然，話是這麼說，版號只是個規則，還是需要由開發者判斷新版是否向後相容以決定如何升版號。</p>\n<p>ELF 在 <code>.dynamic</code> 以 SO-NAME 記錄所需的 shared library：</p>\n<figure class=\"highlight routeros\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ readelf -d main</span><br><span class=\"line\">Dynamic section at offset 0x868 contains 26 entries:</span><br><span class=\"line\">  Tag       <span class=\"built_in\"> Type </span>                        Name/Value</span><br><span class=\"line\"><span class=\"built_in\">..</span>.</span><br><span class=\"line\"> 0x0000000000000001 (NEEDED)             Shared library: [libc.so.6]</span><br></pre></td></tr></table></figure>\n\n<p>Linux 指令 <code>ldconfig</code> 用來更新上述 library 的 soft link，它會掃過所有預設 shared library directory，例如 <code>/lib</code>、<code>/usr/lib</code> 等，更新所有 soft link，將其指向目前系統中最新的 library 或為新 library 建立 soft link。安裝或更新 library 需要執行 <code>ldconfig</code>。</p>\n<h3 id=\"link-name\"><a href=\"#link-name\" class=\"headerlink\" title=\"link name\"></a>link name</h3><p>compile 時我們以 <code>-lXXX</code> 指定要 link 的 library，這個 <code>XXX</code> 稱為 link name。指定 link name 時省略了版號，compiler 會到系統相關的搜尋路徑中尋找最新版本的 <code>XXX</code> library。</p>\n<h2 id=\"Symbol-Versioning\"><a href=\"#Symbol-Versioning\" class=\"headerlink\" title=\"Symbol Versioning\"></a>Symbol Versioning</h2><p>SO-NAME 有升級彈性，但仍有問題──假設依賴的 library 是 <code>libfoo.2.3.1</code>，SO-NAME 是 <code>libfoo.2</code>，但執行環境中只有 <code>libfoo.2.2.1</code>，以 SO-NAME 來看是正確的，但卻可能不相容，因為程式可能使用 <code>libfoo.2.3.1</code> 才有的 interface，這在 <code>libfoo.2.2.1</code> 中找不到，因而執行錯誤。這個問題稱為 Minor-revision Rendezvous Problem。</p>\n<p>為解決 Minor-revision Rendezvous Problem，Solaris 2.5 發展出 symbol versioning 機制，提供 versioning 以及 scoping 機制。</p>\n<h3 id=\"Versioning\"><a href=\"#Versioning\" class=\"headerlink\" title=\"Versioning\"></a>Versioning</h3><p>基本概念是在每個 import 及 export symbol 加上版號，例如 <code>libfoo.1.3</code> 要更新為 <code>libfoo.1.4</code> 時，就把 <code>libfoo.1.4</code> 增加的 symbol 加上 <code>VERS_1.4</code> 的標記。如此 SO-NAME 是 <code>libfoo.1</code> 各版 library 裡會有 <code>VERS_1.2</code>、<code>VERS_1.3</code>、<code>VERS_1.4</code> 等等擁有不同版號標記的 symbol，就能區別 symbol 的版本了。</p>\n<p>versioning 定義了一些 symbol 集合。symbol 集合有名稱，例如 <code>VERS_1.2</code>，每個集合包含一些 symbol，一個集合能包含另一個集合，例如 <code>VERS_1.2</code> 包含 <code>VERS_1.1</code>，這種包含關係也像是繼承，<code>VERS_1.2</code> 繼承 <code>VERS_1.1</code> 的 symbol。symbol 集合由 symbol version script 指定，在 <code>gcc</code> 可以用 <code>-Xlinker --version-script &lt;script file&gt;</code> 指定。</p>\n<p>versioning 機制讓 symbol 可以標上版號，build 執行檔時會記錄它需要的 symbol 及其版號。因為 symbol 只能有一個 version，在相同 major version 的 library 中，同一個 symbol 的 version 是固定的，否則會導致向後不相容。因此，執行檔執行時可以用 SO-NAME 找到系統中最新的 library，接著看它是不是有所需要版本的 symbol，如果有就能正常執行，以此解決 Minor-revision Rendezvous Problem。</p>\n<p>但 Solaris 2.5 的 symbol versioning 有個限制：在一個 shared library 中每個 symbol 只能有一個 version，也就是如果 symbol 是 <code>VERS_1.1</code> 就不能再是 <code>VERS_1.2</code>。這造成如果 interface 只有小修改，例如只加一個參數、依然向後相容（只是擴充，舊有功能不變），由於無法讓新版 library 標示該 symbol 為新版，只能透過增加 major version 來表示 interface 改變，有點小題大作。</p>\n<h4 id=\"Example\"><a href=\"#Example\" class=\"headerlink\" title=\"Example\"></a>Example</h4><p>source code</p>\n<figure class=\"highlight h\"><figcaption><span>foo-1.0.h</span></figcaption><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">foo</span><span class=\"params\">(<span class=\"keyword\">int</span> x, <span class=\"keyword\">int</span> y)</span></span>;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight c\"><figcaption><span>foo-1.0.c</span></figcaption><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">foo</span><span class=\"params\">(<span class=\"keyword\">int</span> x, <span class=\"keyword\">int</span> y)</span> </span>&#123; <span class=\"keyword\">return</span> (x + y); &#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight h\"><figcaption><span>foo-1.1.h </span></figcaption><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">foo</span><span class=\"params\">(<span class=\"keyword\">int</span> x, <span class=\"keyword\">int</span> y)</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">foo2</span><span class=\"params\">(<span class=\"keyword\">int</span> x)</span></span>;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight c\"><figcaption><span>foo-1.1.c</span></figcaption><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">foo</span><span class=\"params\">(<span class=\"keyword\">int</span> x, <span class=\"keyword\">int</span> y)</span> </span>&#123; <span class=\"keyword\">return</span> (x + y); &#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">foo2</span><span class=\"params\">(<span class=\"keyword\">int</span> x)</span> </span>&#123; <span class=\"keyword\">return</span> (x + x); &#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight c\"><figcaption><span>main1.c</span></figcaption><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">\"foo-1.0.h\"</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"%d\\n\"</span>, foo(<span class=\"number\">2</span>, <span class=\"number\">3</span>));</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight c\"><figcaption><span>main2.c</span></figcaption><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">\"foo-1.1.h\"</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"%d\\n\"</span>, foo(<span class=\"number\">2</span>, <span class=\"number\">3</span>));</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"%d\\n\"</span>, foo2(<span class=\"number\">12</span>));</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plain\"><figcaption><span>foo.1.0.ver </span></figcaption><table><tr><td class=\"code\"><pre><span class=\"line\">VERS_1.0 &#123;</span><br><span class=\"line\">    global:</span><br><span class=\"line\">        foo;</span><br><span class=\"line\">    local:</span><br><span class=\"line\">        *;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plain\"><figcaption><span>foo.1.1.ver </span></figcaption><table><tr><td class=\"code\"><pre><span class=\"line\">VERS_1.0 &#123;</span><br><span class=\"line\">    global:</span><br><span class=\"line\">        foo;</span><br><span class=\"line\">    local:</span><br><span class=\"line\">        *;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">VERS_1.1 &#123;</span><br><span class=\"line\">    global:</span><br><span class=\"line\">        foo2;</span><br><span class=\"line\">&#125; VERS_1.0;</span><br></pre></td></tr></table></figure>\n\n<p>library 版本更新的時候，可由新的 symbol 集合看出它的 interface 改動，例如上面 <code>1.1</code> 版繼承了 <code>1.0</code> 版、增加了 symbol <code>foo2</code>。</p>\n<figure class=\"highlight makefile\"><figcaption><span>Makefile</span></figcaption><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"section\">1.0:</span></span><br><span class=\"line\">        gcc -shared -fPIC foo-1.0.c -Xlinker --version-script foo.1.0.ver -o libfoo.1.0.so</span><br><span class=\"line\">        rm -f libfoo.so</span><br><span class=\"line\">        ln -s libfoo.1.0.so libfoo.so</span><br><span class=\"line\">        gcc main1.c ./libfoo.so -o main1</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"section\">1.1:</span></span><br><span class=\"line\">        gcc -shared -fPIC foo-1.1.c -Xlinker --version-script foo.1.1.ver -o libfoo.1.1.so</span><br><span class=\"line\">        rm -f libfoo.so</span><br><span class=\"line\">        ln -s libfoo.1.1.so libfoo.so</span><br><span class=\"line\">        gcc main2.c ./libfoo.so -o main2</span><br></pre></td></tr></table></figure>\n\n<p>看看 library 的 export symbol：</p>\n<figure class=\"highlight routeros\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ readelf --dyn-syms libfoo.1.0.so </span><br><span class=\"line\"></span><br><span class=\"line\">Symbol table <span class=\"string\">'.dynsym'</span> contains 9 entries:</span><br><span class=\"line\">   Num:    Value          Size<span class=\"built_in\"> Type </span>   Bind   Vis      Ndx Name</span><br><span class=\"line\">     0: 0000000000000000     0 NOTYPE  LOCAL <span class=\"built_in\"> DEFAULT </span> UND </span><br><span class=\"line\">     1: 00000000000004b0     0 SECTION LOCAL <span class=\"built_in\"> DEFAULT </span>  10 </span><br><span class=\"line\">     2: 0000000000000000     0 NOTYPE  WEAK  <span class=\"built_in\"> DEFAULT </span> UND _ITM_deregisterTMCloneTab</span><br><span class=\"line\">     3: 0000000000000000     0 NOTYPE  WEAK  <span class=\"built_in\"> DEFAULT </span> UND __gmon_start__</span><br><span class=\"line\">     4: 0000000000000000     0 NOTYPE  WEAK  <span class=\"built_in\"> DEFAULT </span> UND _Jv_RegisterClasses</span><br><span class=\"line\">     5: 0000000000000000     0 NOTYPE  WEAK  <span class=\"built_in\"> DEFAULT </span> UND _ITM_registerTMCloneTable</span><br><span class=\"line\">     6: 0000000000000000     0 FUNC    WEAK  <span class=\"built_in\"> DEFAULT </span> UND __cxa_finalize@GLIBC_2.2.5 (3)</span><br><span class=\"line\">     7: 0000000000000600    20 FUNC    GLOBAL<span class=\"built_in\"> DEFAULT </span>  12 foo@@VERS_1.0</span><br><span class=\"line\">     8: 0000000000000000     0 OBJECT  GLOBAL<span class=\"built_in\"> DEFAULT </span> ABS VERS_1.0</span><br><span class=\"line\"></span><br><span class=\"line\">$ readelf --dyn-syms libfoo.1.1.so </span><br><span class=\"line\"></span><br><span class=\"line\">Symbol table <span class=\"string\">'.dynsym'</span> contains 11 entries:</span><br><span class=\"line\">   Num:    Value          Size<span class=\"built_in\"> Type </span>   Bind   Vis      Ndx Name</span><br><span class=\"line\">     0: 0000000000000000     0 NOTYPE  LOCAL <span class=\"built_in\"> DEFAULT </span> UND </span><br><span class=\"line\">     1: 0000000000000528     0 SECTION LOCAL <span class=\"built_in\"> DEFAULT </span>  10 </span><br><span class=\"line\">     2: 0000000000000000     0 NOTYPE  WEAK  <span class=\"built_in\"> DEFAULT </span> UND _ITM_deregisterTMCloneTab</span><br><span class=\"line\">     3: 0000000000000000     0 NOTYPE  WEAK  <span class=\"built_in\"> DEFAULT </span> UND __gmon_start__</span><br><span class=\"line\">     4: 0000000000000000     0 NOTYPE  WEAK  <span class=\"built_in\"> DEFAULT </span> UND _Jv_RegisterClasses</span><br><span class=\"line\">     5: 0000000000000000     0 NOTYPE  WEAK  <span class=\"built_in\"> DEFAULT </span> UND _ITM_registerTMCloneTable</span><br><span class=\"line\">     6: 0000000000000000     0 FUNC    WEAK  <span class=\"built_in\"> DEFAULT </span> UND __cxa_finalize@GLIBC_2.2.5 (4)</span><br><span class=\"line\">     7: 0000000000000680    20 FUNC    GLOBAL<span class=\"built_in\"> DEFAULT </span>  12 foo@@VERS_1.0</span><br><span class=\"line\">     8: 0000000000000694    14 FUNC    GLOBAL<span class=\"built_in\"> DEFAULT </span>  12 foo2@@VERS_1.1</span><br><span class=\"line\">     9: 0000000000000000     0 OBJECT  GLOBAL<span class=\"built_in\"> DEFAULT </span> ABS VERS_1.0</span><br><span class=\"line\">    10: 0000000000000000     0 OBJECT  GLOBAL<span class=\"built_in\"> DEFAULT </span> ABS VERS_1.1</span><br></pre></td></tr></table></figure>\n\n<p>兩個 library 的 symbol <code>foo</code> 後面加上 <code>VERS</code> 資訊。如果多個 symbol 集合裡有相同 symbol，第一次出現 symbol 的集合是該 symbol 的 version。另外，會被包含的集合必須先寫。也就是說 symbol version 的前後關係是由 version script 指定的，通常遵照數字順序寫（不然會誤導別人啦）。</p>\n<p>執行檔可以看到使用的 symbol 版本：</p>\n<figure class=\"highlight routeros\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ readelf --dyn-syms main1</span><br><span class=\"line\"></span><br><span class=\"line\">Symbol table <span class=\"string\">'.dynsym'</span> contains 8 entries:</span><br><span class=\"line\">   Num:    Value          Size<span class=\"built_in\"> Type </span>   Bind   Vis      Ndx Name</span><br><span class=\"line\">     0: 0000000000000000     0 NOTYPE  LOCAL <span class=\"built_in\"> DEFAULT </span> UND </span><br><span class=\"line\">     1: 0000000000000000     0 NOTYPE  WEAK  <span class=\"built_in\"> DEFAULT </span> UND _ITM_deregisterTMCloneTab</span><br><span class=\"line\">     2: 0000000000000000     0 FUNC    GLOBAL<span class=\"built_in\"> DEFAULT </span> UND foo@VERS_1.0 (2)</span><br><span class=\"line\">     3: 0000000000000000     0 FUNC    GLOBAL<span class=\"built_in\"> DEFAULT </span> UND printf@GLIBC_2.2.5 (3)</span><br><span class=\"line\">     4: 0000000000000000     0 FUNC    GLOBAL<span class=\"built_in\"> DEFAULT </span> UND __libc_start_main@GLIBC_2.2.5 (3)</span><br><span class=\"line\">     5: 0000000000000000     0 NOTYPE  WEAK  <span class=\"built_in\"> DEFAULT </span> UND __gmon_start__</span><br><span class=\"line\">     6: 0000000000000000     0 NOTYPE  WEAK  <span class=\"built_in\"> DEFAULT </span> UND _Jv_RegisterClasses</span><br><span class=\"line\">     7: 0000000000000000     0 NOTYPE  WEAK  <span class=\"built_in\"> DEFAULT </span> UND _ITM_registerTMCloneTable</span><br><span class=\"line\"></span><br><span class=\"line\">$ readelf --dyn-syms main2</span><br><span class=\"line\"></span><br><span class=\"line\">Symbol table <span class=\"string\">'.dynsym'</span> contains 9 entries:</span><br><span class=\"line\">   Num:    Value          Size<span class=\"built_in\"> Type </span>   Bind   Vis      Ndx Name</span><br><span class=\"line\">     0: 0000000000000000     0 NOTYPE  LOCAL <span class=\"built_in\"> DEFAULT </span> UND </span><br><span class=\"line\">     1: 0000000000000000     0 FUNC    GLOBAL<span class=\"built_in\"> DEFAULT </span> UND foo2@VERS_1.1 (2)</span><br><span class=\"line\">     2: 0000000000000000     0 NOTYPE  WEAK  <span class=\"built_in\"> DEFAULT </span> UND _ITM_deregisterTMCloneTab</span><br><span class=\"line\">     3: 0000000000000000     0 FUNC    GLOBAL<span class=\"built_in\"> DEFAULT </span> UND foo@VERS_1.0 (3)</span><br><span class=\"line\">     4: 0000000000000000     0 FUNC    GLOBAL<span class=\"built_in\"> DEFAULT </span> UND printf@GLIBC_2.2.5 (4)</span><br><span class=\"line\">     5: 0000000000000000     0 FUNC    GLOBAL<span class=\"built_in\"> DEFAULT </span> UND __libc_start_main@GLIBC_2.2.5 (4)</span><br><span class=\"line\">     6: 0000000000000000     0 NOTYPE  WEAK  <span class=\"built_in\"> DEFAULT </span> UND __gmon_start__</span><br><span class=\"line\">     7: 0000000000000000     0 NOTYPE  WEAK  <span class=\"built_in\"> DEFAULT </span> UND _Jv_RegisterClasses</span><br><span class=\"line\">     8: 0000000000000000     0 NOTYPE  WEAK  <span class=\"built_in\"> DEFAULT </span> UND _ITM_registerTMCloneTable</span><br></pre></td></tr></table></figure>\n\n<p>修改 soft link <code>libfoo.so</code> 指向的 library，<code>main1</code> 依然可以正常使用 <code>1.1</code> 版的 library，但 <code>main2</code> 無法使用 <code>1.0</code> 版的 library，會跳 <code>./main2: ./libfoo.so: version &#39;VERS_1.1&#39; not found (required by ./main2)</code> 找不到 symbol 的 error。</p>\n<h3 id=\"Scoping\"><a href=\"#Scoping\" class=\"headerlink\" title=\"Scoping\"></a>Scoping</h3><p>在 symbol 集合裡，<code>local:</code> 的設置會將原本 global 的 symbol 變成 local 的，程式以及其他 shared library 無法使用到這些 symbol。這稱為 scoping 機制，算是補強 ELF 處理 C 的 global symbol scoping，因為 ELF 把所有 global symbol 當作 export symbol，這也是為什麼 Linux 下不需要特別指定哪些 global symbol 要 export 就能 export symbol（windows 就需要）。</p>\n<p>上面的例子裡如果把 <code>foo.1.0.ver</code> 裡 <code>local: *;</code> 拿掉，原本其他的 export symbol 就不會被設成 local：</p>\n<figure class=\"highlight routeros\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ readelf --dyn-syms libfoo.1.0.so</span><br><span class=\"line\"></span><br><span class=\"line\">Symbol table <span class=\"string\">'.dynsym'</span> contains 14 entries:</span><br><span class=\"line\">   Num:    Value          Size<span class=\"built_in\"> Type </span>   Bind   Vis      Ndx Name</span><br><span class=\"line\">     0: 0000000000000000     0 NOTYPE  LOCAL <span class=\"built_in\"> DEFAULT </span> UND</span><br><span class=\"line\">     1: 0000000000000570     0 SECTION LOCAL <span class=\"built_in\"> DEFAULT </span>  10</span><br><span class=\"line\">     2: 0000000000000000     0 NOTYPE  WEAK  <span class=\"built_in\"> DEFAULT </span> UND _ITM_deregisterTMCloneTab</span><br><span class=\"line\">     3: 0000000000000000     0 NOTYPE  WEAK  <span class=\"built_in\"> DEFAULT </span> UND __gmon_start__</span><br><span class=\"line\">     4: 0000000000000000     0 NOTYPE  WEAK  <span class=\"built_in\"> DEFAULT </span> UND _Jv_RegisterClasses</span><br><span class=\"line\">     5: 0000000000000000     0 NOTYPE  WEAK  <span class=\"built_in\"> DEFAULT </span> UND _ITM_registerTMCloneTable</span><br><span class=\"line\">     6: 0000000000000000     0 FUNC    WEAK  <span class=\"built_in\"> DEFAULT </span> UND __cxa_finalize@GLIBC_2.2.5 (3)</span><br><span class=\"line\">     7: 00000000002009b8     0 NOTYPE  GLOBAL<span class=\"built_in\"> DEFAULT </span>  22 _edata</span><br><span class=\"line\">     8: 00000000000006c0    20 FUNC    GLOBAL<span class=\"built_in\"> DEFAULT </span>  12 foo@@VERS_1.0</span><br><span class=\"line\">     9: 00000000002009c0     0 NOTYPE  GLOBAL<span class=\"built_in\"> DEFAULT </span>  23 _end</span><br><span class=\"line\">    10: 0000000000000000     0 OBJECT  GLOBAL<span class=\"built_in\"> DEFAULT </span> ABS VERS_1.0</span><br><span class=\"line\">    11: 00000000002009b8     0 NOTYPE  GLOBAL<span class=\"built_in\"> DEFAULT </span>  23 __bss_start</span><br><span class=\"line\">    12: 0000000000000570     0 FUNC    GLOBAL<span class=\"built_in\"> DEFAULT </span>  10 _init</span><br><span class=\"line\">    13: 00000000000006d4     0 FUNC    GLOBAL<span class=\"built_in\"> DEFAULT </span>  13 _fini</span><br></pre></td></tr></table></figure>\n\n\n<h3 id=\"GCC-對-symbol-version-的擴充\"><a href=\"#GCC-對-symbol-version-的擴充\" class=\"headerlink\" title=\"GCC 對 symbol version 的擴充\"></a>GCC 對 symbol version 的擴充</h3><p>GCC 對於 symbol version 提供兩個擴充。第一個是可以指定 symbol 的 version，例如 <code>asm(&quot;.symver foo_new, foo@VERS_1.1&quot;);</code> 指定 <code>foo_new</code> 是 symbol <code>foo</code> 的 <code>1.1</code> 版。</p>\n<p>第二個擴充是允許同個 symbol 有多個版本，這補充了 Solaris 版本機制的限制。例如上面例子裡想在 1.1 版的 <code>foo()</code> 增加一個參數，但希望仍保留舊版功能好能向後相容，這時候就能以指定不同版本來達到。</p>\n<figure class=\"highlight c\"><figcaption><span>foo-1.1.c</span></figcaption><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">asm</span>(<span class=\"string\">\".symver foo_old, foo@VERS_1.0\"</span>);</span><br><span class=\"line\"><span class=\"keyword\">asm</span>(<span class=\"string\">\".symver foo_new, foo@@VERS_1.1\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">foo_old</span><span class=\"params\">(<span class=\"keyword\">int</span> x, <span class=\"keyword\">int</span> y)</span> </span>&#123; <span class=\"keyword\">return</span> x + y; &#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">foo_new</span><span class=\"params\">(<span class=\"keyword\">int</span> x, <span class=\"keyword\">int</span> y, <span class=\"keyword\">int</span> z)</span> </span>&#123; <span class=\"keyword\">return</span> (x + y + z); &#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">foo2</span><span class=\"params\">(<span class=\"keyword\">int</span> x)</span> </span>&#123; <span class=\"keyword\">return</span> (x + x); &#125;</span><br></pre></td></tr></table></figure>\n\n<p>兩個 <code>.symver</code> 分別指定 <code>foo_old()</code> 是 <code>foo</code> 的版本 <code>1.0</code>，<code>foo_new()</code> 是版本 <code>1.1</code>。因為已經用 <code>.symver</code> 自訂 <code>foo</code> 這個 symbol，如果又寫 <code>foo()</code> link 時會有 <code>multiple definition</code> 錯誤。<code>foo@@VERS_1.1</code> 表示 <code>foo</code> 預設版本是 <code>1.1</code>，一個 symbol 的預設版號只能有一個，實驗看起來預設版號會影響 compile 執行檔時記錄的 symbol。由於仍然有 <code>1.0</code> 的 <code>foo</code>，<code>main1</code> 用新版 library 仍能正常執行。</p>\n<figure class=\"highlight h\"><figcaption><span>foo-1.1.h</span></figcaption><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">foo</span><span class=\"params\">(<span class=\"keyword\">int</span> x, <span class=\"keyword\">int</span> y, <span class=\"keyword\">int</span> z)</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">foo2</span><span class=\"params\">(<span class=\"keyword\">int</span> x)</span></span>;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight c\"><figcaption><span>main2.c </span></figcaption><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">\"foo-1.1.h\"</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"%d\\n\"</span>, foo(<span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">5</span>));</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"%d\\n\"</span>, foo2(<span class=\"number\">12</span>));</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>header 跟 library 檔一起發佈，在 compile 執行檔時讓執行檔知道有什麼 symbol，所以必須要是新版 <code>foo</code> 的 prototype，而且 function name 也要是 <code>foo</code>，而非 <code>foo_new</code>。（我想還是有別的方式可以做到同樣的事情，甚至可以刻意使用舊版 symbol，這只是我認為合理的 library 發佈以及使用方式）</p>\n<figure class=\"highlight routeros\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ readelf --dyn-syms libfoo.1.1.so </span><br><span class=\"line\"></span><br><span class=\"line\">Symbol table <span class=\"string\">'.dynsym'</span> contains 12 entries:</span><br><span class=\"line\">   Num:    Value          Size<span class=\"built_in\"> Type </span>   Bind   Vis      Ndx Name</span><br><span class=\"line\">     7: 0000000000000690    20 FUNC    GLOBAL<span class=\"built_in\"> DEFAULT </span>  12 foo@VERS_1.0</span><br><span class=\"line\">     8: 00000000000006a4    28 FUNC    GLOBAL<span class=\"built_in\"> DEFAULT </span>  12 foo@@VERS_1.1</span><br><span class=\"line\">     9: 00000000000006c0    14 FUNC    GLOBAL<span class=\"built_in\"> DEFAULT </span>  12 foo2@@VERS_1.1</span><br><span class=\"line\">    10: 0000000000000000     0 OBJECT  GLOBAL<span class=\"built_in\"> DEFAULT </span> ABS VERS_1.0</span><br><span class=\"line\">    11: 0000000000000000     0 OBJECT  GLOBAL<span class=\"built_in\"> DEFAULT </span> ABS VERS_1.1</span><br><span class=\"line\"></span><br><span class=\"line\">$ readelf --dyn-syms main2</span><br><span class=\"line\"></span><br><span class=\"line\">Symbol table <span class=\"string\">'.dynsym'</span> contains 9 entries:</span><br><span class=\"line\">   Num:    Value          Size<span class=\"built_in\"> Type </span>   Bind   Vis      Ndx Name</span><br><span class=\"line\">     1: 0000000000000000     0 FUNC    GLOBAL<span class=\"built_in\"> DEFAULT </span> UND foo2@VERS_1.1 (2)</span><br><span class=\"line\">     6: 0000000000000000     0 FUNC    GLOBAL<span class=\"built_in\"> DEFAULT </span> UND foo@VERS_1.1 (2)</span><br></pre></td></tr></table></figure>\n\n\n<h2 id=\"Semantic-Versioning\"><a href=\"#Semantic-Versioning\" class=\"headerlink\" title=\"Semantic Versioning\"></a>Semantic Versioning</h2><p>由 <a href=\"http://tom.preston-werner.com/\" target=\"_blank\" rel=\"noopener\">Tom Preston-Werner</a> 提出的 <a href=\"http://semver.org/\" target=\"_blank\" rel=\"noopener\">Semantic Versioning</a> 以 spec 的形式提供了版號規範，例如每個數字代表的意義、何時該增加版號、如何增加版號以及如何區分版本的新舊等等。它定義的版號包含 <code>MAJOR.MINOR.PATCH</code> 三個數字，並且可以加上如 <code>-alpha</code>、<code>-beta</code> 等 pre-release 資訊。概念與上面說的 library 版號類似，interface 有變更時需增加 major verion，增加向後相容的功能時要增加 minor version，修 bug 則增加 patch version，只是它以精準定義的方式描述這些規則。</p>\n<p>當然，它只定義了版號本身的規則，至於「什麼改變是有向後相容？是否更改的 interface？」等問題仍然要由開發者判斷。</p>\n<h2 id=\"Related-posts-amp-Ref\"><a href=\"#Related-posts-amp-Ref\" class=\"headerlink\" title=\"Related posts &amp; Ref\"></a>Related posts &amp; Ref</h2><ul>\n<li><a href=\"https://www.usenix.org/legacy/publications/library/proceedings/als00/2000papers/papers/full_papers/browndavid/browndavid_html/\" target=\"_blank\" rel=\"noopener\">Library Interface Versioning in Solaris and Linux</a> / <a href=\"https://www.usenix.org/legacy/publications/library/proceedings/als00/2000papers/papers/full_papers/browndavid/browndavid.pdf\" target=\"_blank\" rel=\"noopener\">pdf</a></li>\n<li>《程式設計師的自我修養》ch8</li>\n<li><a href=\"ftp://ftp.gnu.org/old-gnu/Manuals/ld-2.9.1/html_node/ld_25.html\">Using LD, the GNU linker - Version Script</a></li>\n<li><a href=\"http://semver.org/\" target=\"_blank\" rel=\"noopener\">Semantic Versioning</a></li>\n<li><a href=\"/Dynamic-Linking-Basic/\">Dynamic Linking Basic</a></li>\n<li><a href=\"/Dynamic-Linking-PIC/\">Dynamic Linking PIC</a></li>\n<li><a href=\"/Dynamic-Linking-Relocation/\">Dynamic Linking Relocation</a></li>\n<li><a href=\"/Use-Shared-Library-in-Linux/\">Use Shared Library in Linux</a></li>\n<li><a href=\"/Explicit-Runtime-Linking/\">Explicit Runtime Linking</a></li>\n</ul>\n","tags":["Linux","System Software"]},{"title":"Static Link","url":"/Static-Link/","content":"<p><strong>所謂 Static Link（靜態連結）──在 linking 階段針對未知 address 的 symbol 填入 address，把一堆 object file 黏在一起變成可執行檔。</strong></p>\n<p>沒了。(誤)</p>\n<p>object file 是 compile 後的 binary 中間檔，它有多種 format，ELF 是其中之一。linking 主要是將其他 object file 中 symbol 的正確 address 填進 reference 到它的指令中，例如 object file A 的指令 reference 到 object file B 的 symbol x，link 前 object A 無法得知 x 的 address，link 時才會知道 x 正確的 address 並將之填進 object file A 的指令中。</p>\n<h2 id=\"Two-pass-linking\"><a href=\"#Two-pass-linking\" class=\"headerlink\" title=\"Two-pass linking\"></a>Two-pass linking</h2><p>Static link 的流程是 two-pass linking，將 linking 分為兩個步驟：</p>\n<ol>\n<li>分配 virtual address space</li>\n<li>symbol resolution and relocation</li>\n</ol>\n<h3 id=\"1-分配-virtual-address-space\"><a href=\"#1-分配-virtual-address-space\" class=\"headerlink\" title=\"1. 分配 virtual address space\"></a>1. 分配 virtual address space</h3><p>合併多個 object file 成一個檔案。</p>\n<ul>\n<li>掃描所有 object file，合併相同的 section，例如合併 <code>a.o</code> 跟 <code>b.o</code> 的 <code>.text</code> section。</li>\n<li>linker 透過 object file 中的各種 table 得知各 section 的長度、屬性以及位置。</li>\n<li>收集所有 object file symbol table 中的 symbol definition 跟 symbol reference 放到 global symbol table。</li>\n<li>合併完 object file，各 symbol 的 virtual address 已經確定，linker 會計算 symbol 的 virtual address。<ul>\n<li>symbol 的 virtual address = 所在 section 合併後的 address + symbol 的 offset</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"2-symbol-relocation-and-resolution\"><a href=\"#2-symbol-relocation-and-resolution\" class=\"headerlink\" title=\"2. symbol relocation and resolution\"></a>2. symbol relocation and resolution</h3><p>static link 的重點。</p>\n<p>compiler 不知道 reference 到別的 object file 中 variable 或 function 的 address，所以遇到其他 object file 的 symbol 時會塞假的 address 進 instruction。</p>\n<p>利用 relocation table 將真正的 virtual address 填進 instruction 即為 symbol relocation。relocation table 記錄需要調整的 instruction 所在位置以及如何調整。每個需要 relocate 的 section 都有一個 relocation table，relocation table 也是 ELF 檔中的一個 section，如 <code>.rel.text</code> section 是 <code>.text</code> 的 relocation table。可以利用 <code>objdump -r xxx.o</code> 看 relocation table。</p>\n<p>linker 由 global symbol table 得知 symbol 的 address，接著依據不同定址模式將 address 填進 instruction。所有 object file 中原本 undefined 的 symbol 經過 relocate 及 resolve 後應該要能在 global symbol table 中找到對應的 address，否則會出現 undefined reference 的 error。</p>\n<h2 id=\"Example\"><a href=\"#Example\" class=\"headerlink\" title=\"Example\"></a>Example</h2><p>來點例子比較有 fu。</p>\n<h3 id=\"source\"><a href=\"#source\" class=\"headerlink\" title=\"source\"></a>source</h3><figure class=\"highlight c\"><figcaption><span>foo.c</span></figcaption><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">extern</span> <span class=\"keyword\">int</span> sum;</span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">int</span> globalvar = <span class=\"number\">2</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">foo</span><span class=\"params\">(<span class=\"keyword\">int</span> a, <span class=\"keyword\">int</span> b)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> staticvar = <span class=\"number\">1</span>;</span><br><span class=\"line\">    sum = a + b;</span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">int</span>* p = &amp;staticvar;</span><br><span class=\"line\">    p = &amp;sum;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><code>sum</code> 宣告成 <code>extern</code>，表示是其他檔案的 symbol，在 <code>foo()</code> 裡使用就是跨 object file 的 reference。</p>\n<p>static 的 global 變數 <code>globalvar</code> 是只在這個 file 裡才看得到的變數。</p>\n<figure class=\"highlight c\"><figcaption><span>main.c</span></figcaption><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">extern</span> <span class=\"keyword\">int</span> <span class=\"title\">foo</span><span class=\"params\">(<span class=\"keyword\">int</span>, <span class=\"keyword\">int</span>)</span></span>;</span><br><span class=\"line\"><span class=\"keyword\">int</span> sum = <span class=\"number\">1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    foo(<span class=\"number\">5</span>, <span class=\"number\">3</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>宣告 <code>foo()</code> 在別的檔案。</p>\n<p><code>$ gcc -c foo.c main.c</code> compile 成 object file。</p>\n<p><code>$ ld foo.o main.o -e main -o foo</code> link 兩個 object file，以 <code>-e</code> 指定 entry point。</p>\n<p><em>PS：以上述簡化的 compile 及 link，程式會在跑到要結束的時候發生 segmentation fault，可能跟自己指定 entry point、未使用 C Runtime 處理開始及結束 process 有關。</em></p>\n<h3 id=\"分配空間及-address\"><a href=\"#分配空間及-address\" class=\"headerlink\" title=\"分配空間及 address\"></a>分配空間及 address</h3><p>首先分配空間及 address，將多個 object file 裡相同的 section 放在一起並分配空間及 address，觀察三個檔案的 section：</p>\n<figure class=\"highlight angelscript\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ readelf -S foo.o</span><br><span class=\"line\"></span><br><span class=\"line\">There are <span class=\"number\">13</span> section headers, starting at offset <span class=\"number\">0x318</span>:</span><br><span class=\"line\"></span><br><span class=\"line\">Section Headers:</span><br><span class=\"line\">  [Nr] Name              Type             Address           Offset</span><br><span class=\"line\">       Size              EntSize          Flags  Link  Info  Align</span><br><span class=\"line\">  [ <span class=\"number\">0</span>]                   NULL             <span class=\"number\">0000000000000000</span>  <span class=\"number\">00000000</span></span><br><span class=\"line\">       <span class=\"number\">0000000000000000</span>  <span class=\"number\">0000000000000000</span>           <span class=\"number\">0</span>     <span class=\"number\">0</span>     <span class=\"number\">0</span></span><br><span class=\"line\">  [ <span class=\"number\">1</span>] .text             PROGBITS         <span class=\"number\">0000000000000000</span>  <span class=\"number\">00000040</span></span><br><span class=\"line\">       <span class=\"number\">0000000000000025</span>  <span class=\"number\">0000000000000000</span>  AX       <span class=\"number\">0</span>     <span class=\"number\">0</span>     <span class=\"number\">1</span></span><br><span class=\"line\">  [ <span class=\"number\">2</span>] .rela.text        RELA             <span class=\"number\">0000000000000000</span>  <span class=\"number\">000002</span>a0</span><br><span class=\"line\">       <span class=\"number\">0000000000000048</span>  <span class=\"number\">0000000000000018</span>   I      <span class=\"number\">11</span>     <span class=\"number\">1</span>     <span class=\"number\">8</span></span><br><span class=\"line\">  [ <span class=\"number\">3</span>] .data             PROGBITS         <span class=\"number\">0000000000000000</span>  <span class=\"number\">00000068</span></span><br><span class=\"line\">       <span class=\"number\">0000000000000014</span>  <span class=\"number\">0000000000000000</span>  WA       <span class=\"number\">0</span>     <span class=\"number\">0</span>     <span class=\"number\">8</span></span><br><span class=\"line\">  [ <span class=\"number\">4</span>] .rela.data        RELA             <span class=\"number\">0000000000000000</span>  <span class=\"number\">000002e8</span></span><br><span class=\"line\">       <span class=\"number\">0000000000000018</span>  <span class=\"number\">0000000000000018</span>   I      <span class=\"number\">11</span>     <span class=\"number\">3</span>     <span class=\"number\">8</span></span><br><span class=\"line\">  [ <span class=\"number\">5</span>] .bss              NOBITS           <span class=\"number\">0000000000000000</span>  <span class=\"number\">0000007</span>c</span><br><span class=\"line\">       <span class=\"number\">0000000000000000</span>  <span class=\"number\">0000000000000000</span>  WA       <span class=\"number\">0</span>     <span class=\"number\">0</span>     <span class=\"number\">1</span></span><br><span class=\"line\">  [ <span class=\"number\">6</span>] .comment          PROGBITS         <span class=\"number\">0000000000000000</span>  <span class=\"number\">0000007</span>c</span><br><span class=\"line\">       <span class=\"number\">000000000000001</span>e  <span class=\"number\">0000000000000001</span>  MS       <span class=\"number\">0</span>     <span class=\"number\">0</span>     <span class=\"number\">1</span></span><br><span class=\"line\">  [ <span class=\"number\">7</span>] .note.GNU-stack   PROGBITS         <span class=\"number\">0000000000000000</span>  <span class=\"number\">0000009</span>a</span><br><span class=\"line\">       <span class=\"number\">0000000000000000</span>  <span class=\"number\">0000000000000000</span>           <span class=\"number\">0</span>     <span class=\"number\">0</span>     <span class=\"number\">1</span></span><br><span class=\"line\">  [ <span class=\"number\">8</span>] .eh_frame         PROGBITS         <span class=\"number\">0000000000000000</span>  <span class=\"number\">000000</span>a0</span><br><span class=\"line\">       <span class=\"number\">0000000000000038</span>  <span class=\"number\">0000000000000000</span>   A       <span class=\"number\">0</span>     <span class=\"number\">0</span>     <span class=\"number\">8</span></span><br><span class=\"line\">  [ <span class=\"number\">9</span>] .rela.eh_frame    RELA             <span class=\"number\">0000000000000000</span>  <span class=\"number\">00000300</span></span><br><span class=\"line\">       <span class=\"number\">0000000000000018</span>  <span class=\"number\">0000000000000018</span>   I      <span class=\"number\">11</span>     <span class=\"number\">8</span>     <span class=\"number\">8</span></span><br><span class=\"line\">  [<span class=\"number\">10</span>] .shstrtab         STRTAB           <span class=\"number\">0000000000000000</span>  <span class=\"number\">000000</span>d8</span><br><span class=\"line\">       <span class=\"number\">000000000000005</span>e  <span class=\"number\">0000000000000000</span>           <span class=\"number\">0</span>     <span class=\"number\">0</span>     <span class=\"number\">1</span></span><br><span class=\"line\">  [<span class=\"number\">11</span>] .symtab           SYMTAB           <span class=\"number\">0000000000000000</span>  <span class=\"number\">00000138</span></span><br><span class=\"line\">       <span class=\"number\">0000000000000138</span>  <span class=\"number\">0000000000000018</span>          <span class=\"number\">12</span>    <span class=\"number\">11</span>     <span class=\"number\">8</span></span><br><span class=\"line\">  [<span class=\"number\">12</span>] .strtab           STRTAB           <span class=\"number\">0000000000000000</span>  <span class=\"number\">00000270</span></span><br><span class=\"line\">       <span class=\"number\">000000000000002f</span>  <span class=\"number\">0000000000000000</span>           <span class=\"number\">0</span>     <span class=\"number\">0</span>     <span class=\"number\">1</span></span><br><span class=\"line\"></span><br><span class=\"line\">$ readelf -S main.o</span><br><span class=\"line\"></span><br><span class=\"line\">There are <span class=\"number\">12</span> section headers, starting at offset <span class=\"number\">0x268</span>:</span><br><span class=\"line\"></span><br><span class=\"line\">Section Headers:</span><br><span class=\"line\">  [Nr] Name              Type             Address           Offset</span><br><span class=\"line\">       Size              EntSize          Flags  Link  Info  Align</span><br><span class=\"line\">  [ <span class=\"number\">0</span>]                   NULL             <span class=\"number\">0000000000000000</span>  <span class=\"number\">00000000</span></span><br><span class=\"line\">       <span class=\"number\">0000000000000000</span>  <span class=\"number\">0000000000000000</span>           <span class=\"number\">0</span>     <span class=\"number\">0</span>     <span class=\"number\">0</span></span><br><span class=\"line\">  [ <span class=\"number\">1</span>] .text             PROGBITS         <span class=\"number\">0000000000000000</span>  <span class=\"number\">00000040</span></span><br><span class=\"line\">       <span class=\"number\">000000000000001</span>a  <span class=\"number\">0000000000000000</span>  AX       <span class=\"number\">0</span>     <span class=\"number\">0</span>     <span class=\"number\">1</span></span><br><span class=\"line\">  [ <span class=\"number\">2</span>] .rela.text        RELA             <span class=\"number\">0000000000000000</span>  <span class=\"number\">00000238</span></span><br><span class=\"line\">       <span class=\"number\">0000000000000018</span>  <span class=\"number\">0000000000000018</span>   I      <span class=\"number\">10</span>     <span class=\"number\">1</span>     <span class=\"number\">8</span></span><br><span class=\"line\">  [ <span class=\"number\">3</span>] .data             PROGBITS         <span class=\"number\">0000000000000000</span>  <span class=\"number\">0000005</span>c</span><br><span class=\"line\">       <span class=\"number\">0000000000000004</span>  <span class=\"number\">0000000000000000</span>  WA       <span class=\"number\">0</span>     <span class=\"number\">0</span>     <span class=\"number\">4</span></span><br><span class=\"line\">  [ <span class=\"number\">4</span>] .bss              NOBITS           <span class=\"number\">0000000000000000</span>  <span class=\"number\">00000060</span></span><br><span class=\"line\">       <span class=\"number\">0000000000000000</span>  <span class=\"number\">0000000000000000</span>  WA       <span class=\"number\">0</span>     <span class=\"number\">0</span>     <span class=\"number\">1</span></span><br><span class=\"line\">  [ <span class=\"number\">5</span>] .comment          PROGBITS         <span class=\"number\">0000000000000000</span>  <span class=\"number\">00000060</span></span><br><span class=\"line\">       <span class=\"number\">000000000000001</span>e  <span class=\"number\">0000000000000001</span>  MS       <span class=\"number\">0</span>     <span class=\"number\">0</span>     <span class=\"number\">1</span></span><br><span class=\"line\">  [ <span class=\"number\">6</span>] .note.GNU-stack   PROGBITS         <span class=\"number\">0000000000000000</span>  <span class=\"number\">0000007</span>e</span><br><span class=\"line\">       <span class=\"number\">0000000000000000</span>  <span class=\"number\">0000000000000000</span>           <span class=\"number\">0</span>     <span class=\"number\">0</span>     <span class=\"number\">1</span></span><br><span class=\"line\">  [ <span class=\"number\">7</span>] .eh_frame         PROGBITS         <span class=\"number\">0000000000000000</span>  <span class=\"number\">00000080</span></span><br><span class=\"line\">       <span class=\"number\">0000000000000038</span>  <span class=\"number\">0000000000000000</span>   A       <span class=\"number\">0</span>     <span class=\"number\">0</span>     <span class=\"number\">8</span></span><br><span class=\"line\">  [ <span class=\"number\">8</span>] .rela.eh_frame    RELA             <span class=\"number\">0000000000000000</span>  <span class=\"number\">00000250</span></span><br><span class=\"line\">       <span class=\"number\">0000000000000018</span>  <span class=\"number\">0000000000000018</span>   I      <span class=\"number\">10</span>     <span class=\"number\">7</span>     <span class=\"number\">8</span></span><br><span class=\"line\">  [ <span class=\"number\">9</span>] .shstrtab         STRTAB           <span class=\"number\">0000000000000000</span>  <span class=\"number\">000000</span>b8</span><br><span class=\"line\">       <span class=\"number\">0000000000000059</span>  <span class=\"number\">0000000000000000</span>           <span class=\"number\">0</span>     <span class=\"number\">0</span>     <span class=\"number\">1</span></span><br><span class=\"line\">  [<span class=\"number\">10</span>] .symtab           SYMTAB           <span class=\"number\">0000000000000000</span>  <span class=\"number\">00000118</span></span><br><span class=\"line\">       <span class=\"number\">0000000000000108</span>  <span class=\"number\">0000000000000018</span>          <span class=\"number\">11</span>     <span class=\"number\">8</span>     <span class=\"number\">8</span></span><br><span class=\"line\">  [<span class=\"number\">11</span>] .strtab           STRTAB           <span class=\"number\">0000000000000000</span>  <span class=\"number\">00000220</span></span><br><span class=\"line\">       <span class=\"number\">0000000000000015</span>  <span class=\"number\">0000000000000000</span>           <span class=\"number\">0</span>     <span class=\"number\">0</span>     <span class=\"number\">1</span></span><br><span class=\"line\"></span><br><span class=\"line\">$ readelf -S foo</span><br><span class=\"line\"></span><br><span class=\"line\">There are <span class=\"number\">8</span> section headers, starting at offset <span class=\"number\">0x3c8</span>:</span><br><span class=\"line\"></span><br><span class=\"line\">Section Headers:</span><br><span class=\"line\">  [Nr] Name              Type             Address           Offset</span><br><span class=\"line\">       Size              EntSize          Flags  Link  Info  Align</span><br><span class=\"line\">  [ <span class=\"number\">0</span>]                   NULL             <span class=\"number\">0000000000000000</span>  <span class=\"number\">00000000</span></span><br><span class=\"line\">       <span class=\"number\">0000000000000000</span>  <span class=\"number\">0000000000000000</span>           <span class=\"number\">0</span>     <span class=\"number\">0</span>     <span class=\"number\">0</span></span><br><span class=\"line\">  [ <span class=\"number\">1</span>] .text             PROGBITS         <span class=\"number\">00000000004000e8</span>  <span class=\"number\">000000e8</span></span><br><span class=\"line\">       <span class=\"number\">000000000000003f</span>  <span class=\"number\">0000000000000000</span>  AX       <span class=\"number\">0</span>     <span class=\"number\">0</span>     <span class=\"number\">1</span></span><br><span class=\"line\">  [ <span class=\"number\">2</span>] .eh_frame         PROGBITS         <span class=\"number\">0000000000400128</span>  <span class=\"number\">00000128</span></span><br><span class=\"line\">       <span class=\"number\">0000000000000058</span>  <span class=\"number\">0000000000000000</span>   A       <span class=\"number\">0</span>     <span class=\"number\">0</span>     <span class=\"number\">8</span></span><br><span class=\"line\">  [ <span class=\"number\">3</span>] .data             PROGBITS         <span class=\"number\">0000000000600180</span>  <span class=\"number\">00000180</span></span><br><span class=\"line\">       <span class=\"number\">0000000000000018</span>  <span class=\"number\">0000000000000000</span>  WA       <span class=\"number\">0</span>     <span class=\"number\">0</span>     <span class=\"number\">8</span></span><br><span class=\"line\">  [ <span class=\"number\">4</span>] .comment          PROGBITS         <span class=\"number\">0000000000000000</span>  <span class=\"number\">00000198</span></span><br><span class=\"line\">       <span class=\"number\">000000000000001</span>d  <span class=\"number\">0000000000000001</span>  MS       <span class=\"number\">0</span>     <span class=\"number\">0</span>     <span class=\"number\">1</span></span><br><span class=\"line\">  [ <span class=\"number\">5</span>] .shstrtab         STRTAB           <span class=\"number\">0000000000000000</span>  <span class=\"number\">000001</span>b5</span><br><span class=\"line\">       <span class=\"number\">000000000000003</span>a  <span class=\"number\">0000000000000000</span>           <span class=\"number\">0</span>     <span class=\"number\">0</span>     <span class=\"number\">1</span></span><br><span class=\"line\">  [ <span class=\"number\">6</span>] .symtab           SYMTAB           <span class=\"number\">0000000000000000</span>  <span class=\"number\">000001f</span>0</span><br><span class=\"line\">       <span class=\"number\">0000000000000180</span>  <span class=\"number\">0000000000000018</span>           <span class=\"number\">7</span>    <span class=\"number\">10</span>     <span class=\"number\">8</span></span><br><span class=\"line\">  [ <span class=\"number\">7</span>] .strtab           STRTAB           <span class=\"number\">0000000000000000</span>  <span class=\"number\">00000370</span></span><br><span class=\"line\">       <span class=\"number\">0000000000000053</span>  <span class=\"number\">0000000000000000</span>           <span class=\"number\">0</span>     <span class=\"number\">0</span>     <span class=\"number\">1</span></span><br></pre></td></tr></table></figure>\n\n<p><img src=\"/images/static_link_step1.png\" alt=\"Static link step1\"></p>\n<p><code>foo.o</code> 跟 <code>main.o</code> 的 <code>.text</code> 以及 <code>.data</code> section 在 <code>foo</code> 合在一起啦！</p>\n<h3 id=\"relocation\"><a href=\"#relocation\" class=\"headerlink\" title=\"relocation\"></a>relocation</h3><p>section 合併之後就能計算出 symbol 的 address，進入 static link 的重頭戲 relocation。</p>\n<p>先看還沒 relocate 的 <code>foo.o</code> 的 symbol：</p>\n<figure class=\"highlight routeros\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ readelf -s foo.o</span><br><span class=\"line\"></span><br><span class=\"line\">Symbol table <span class=\"string\">'.symtab'</span> contains 13 entries:</span><br><span class=\"line\">   Num:    Value          Size<span class=\"built_in\"> Type </span>   Bind   Vis      Ndx Name</span><br><span class=\"line\">     0: 0000000000000000     0 NOTYPE  LOCAL <span class=\"built_in\"> DEFAULT </span> UND </span><br><span class=\"line\">     1: 0000000000000000     0 FILE    LOCAL <span class=\"built_in\"> DEFAULT </span> ABS foo.c</span><br><span class=\"line\">     2: 0000000000000000     0 SECTION LOCAL <span class=\"built_in\"> DEFAULT </span>   1 </span><br><span class=\"line\">     3: 0000000000000000     0 SECTION LOCAL <span class=\"built_in\"> DEFAULT </span>   3 </span><br><span class=\"line\">     4: 0000000000000000     0 SECTION LOCAL <span class=\"built_in\"> DEFAULT </span>   5 </span><br><span class=\"line\">     5: 0000000000000000     4 OBJECT  LOCAL <span class=\"built_in\"> DEFAULT </span>   3 globalvar</span><br><span class=\"line\">     6: 0000000000000008     8 OBJECT  LOCAL <span class=\"built_in\"> DEFAULT </span>   3 p.1749</span><br><span class=\"line\">     7: 0000000000000010     4 OBJECT  LOCAL <span class=\"built_in\"> DEFAULT </span>   3 staticvar.1748</span><br><span class=\"line\">     8: 0000000000000000     0 SECTION LOCAL <span class=\"built_in\"> DEFAULT </span>   7 </span><br><span class=\"line\">     9: 0000000000000000     0 SECTION LOCAL <span class=\"built_in\"> DEFAULT </span>   8 </span><br><span class=\"line\">    10: 0000000000000000     0 SECTION LOCAL <span class=\"built_in\"> DEFAULT </span>   6 </span><br><span class=\"line\">    11: 0000000000000000    37 FUNC    GLOBAL<span class=\"built_in\"> DEFAULT </span>   1 foo</span><br><span class=\"line\">    12: 0000000000000000     0 NOTYPE  GLOBAL<span class=\"built_in\"> DEFAULT </span> UND sum</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>Num：symbol table array 的 index。</li>\n<li>Name：<code>st_name</code>，symbol name。</li>\n<li>Value：<code>st_value</code>，symbol value，該 symbol 的 address。</li>\n<li>Size：<code>st_size</code>，表示所佔的大小。如果 symbol 是變數且在這個 object file 內，size 會有值，再根據有沒有 initialized 決定放在 <code>.data</code> 或 <code>.bss</code> section。global 跟 local static 有 initialized 的變數會在 compile 階段挖好空間、決定好 address，也就會在 executable file 中佔有空間。</li>\n<li>Type 及 Bind 對應 <code>st_info</code>，<code>GLOBAL</code> 表示 global 可見，<code>LOCAL</code> 則表示在這個 compile unit 中可見。</li>\n<li>Ndx：<code>st_shndx</code>，屬於哪個 section，<code>UND</code> 表示這個 symbol 還是 undefined。</li>\n</ul>\n<p><code>globalvar</code> 跟 <code>staticvar</code> 兩個變數都放在 <code>.data</code> section，<code>foo</code> 在 code section <code>.text</code>，<code>sum</code> 被宣告成 <code>extern</code> 則是 undefined 要等 link 的時候才知道在哪。</p>\n<p><code>main.o</code> 的 symbol：</p>\n<figure class=\"highlight routeros\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ readelf -s main.o</span><br><span class=\"line\"></span><br><span class=\"line\">Symbol table <span class=\"string\">'.symtab'</span> contains 11 entries:</span><br><span class=\"line\">   Num:    Value          Size<span class=\"built_in\"> Type </span>   Bind   Vis      Ndx Name</span><br><span class=\"line\">     0: 0000000000000000     0 NOTYPE  LOCAL <span class=\"built_in\"> DEFAULT </span> UND </span><br><span class=\"line\">     1: 0000000000000000     0 FILE    LOCAL <span class=\"built_in\"> DEFAULT </span> ABS main.c</span><br><span class=\"line\">     2: 0000000000000000     0 SECTION LOCAL <span class=\"built_in\"> DEFAULT </span>   1 </span><br><span class=\"line\">     3: 0000000000000000     0 SECTION LOCAL <span class=\"built_in\"> DEFAULT </span>   3 </span><br><span class=\"line\">     4: 0000000000000000     0 SECTION LOCAL <span class=\"built_in\"> DEFAULT </span>   4 </span><br><span class=\"line\">     5: 0000000000000000     0 SECTION LOCAL <span class=\"built_in\"> DEFAULT </span>   6 </span><br><span class=\"line\">     6: 0000000000000000     0 SECTION LOCAL <span class=\"built_in\"> DEFAULT </span>   7 </span><br><span class=\"line\">     7: 0000000000000000     0 SECTION LOCAL <span class=\"built_in\"> DEFAULT </span>   5 </span><br><span class=\"line\">     8: 0000000000000000     4 OBJECT  GLOBAL<span class=\"built_in\"> DEFAULT </span>   3 sum</span><br><span class=\"line\">     9: 0000000000000000    26 FUNC    GLOBAL<span class=\"built_in\"> DEFAULT </span>   1 main</span><br><span class=\"line\">    10: 0000000000000000     0 NOTYPE  GLOBAL<span class=\"built_in\"> DEFAULT </span> UND foo</span><br></pre></td></tr></table></figure>\n\n<p><code>sum</code> 定義在 <code>main.o</code> 裡，<code>foo</code> 在 <code>main.o</code> 則是 undefined。</p>\n<p><code>foo</code> 的 symbol：</p>\n<figure class=\"highlight routeros\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ readelf -s foo</span><br><span class=\"line\"></span><br><span class=\"line\">Symbol table <span class=\"string\">'.symtab'</span> contains 16 entries:</span><br><span class=\"line\">   Num:    Value          Size<span class=\"built_in\"> Type </span>   Bind   Vis      Ndx Name</span><br><span class=\"line\">     0: 0000000000000000     0 NOTYPE  LOCAL <span class=\"built_in\"> DEFAULT </span> UND </span><br><span class=\"line\">     1: 00000000004000e8     0 SECTION LOCAL <span class=\"built_in\"> DEFAULT </span>   1 </span><br><span class=\"line\">     2: 0000000000400128     0 SECTION LOCAL <span class=\"built_in\"> DEFAULT </span>   2 </span><br><span class=\"line\">     3: 0000000000600180     0 SECTION LOCAL <span class=\"built_in\"> DEFAULT </span>   3 </span><br><span class=\"line\">     4: 0000000000000000     0 SECTION LOCAL <span class=\"built_in\"> DEFAULT </span>   4 </span><br><span class=\"line\">     5: 0000000000000000     0 FILE    LOCAL <span class=\"built_in\"> DEFAULT </span> ABS foo.c</span><br><span class=\"line\">     6: 0000000000600180     4 OBJECT  LOCAL <span class=\"built_in\"> DEFAULT </span>   3 globalvar</span><br><span class=\"line\">     7: 0000000000600188     8 OBJECT  LOCAL <span class=\"built_in\"> DEFAULT </span>   3 p.1749</span><br><span class=\"line\">     8: 0000000000600190     4 OBJECT  LOCAL <span class=\"built_in\"> DEFAULT </span>   3 staticvar.1748</span><br><span class=\"line\">     9: 0000000000000000     0 FILE    LOCAL <span class=\"built_in\"> DEFAULT </span> ABS main.c</span><br><span class=\"line\">    10: 0000000000600194     4 OBJECT  GLOBAL<span class=\"built_in\"> DEFAULT </span>   3 sum</span><br><span class=\"line\">    11: 0000000000600198     0 NOTYPE  GLOBAL<span class=\"built_in\"> DEFAULT </span>   3 __bss_start</span><br><span class=\"line\">    12: 000000000040010d    26 FUNC    GLOBAL<span class=\"built_in\"> DEFAULT </span>   1 main</span><br><span class=\"line\">    13: 00000000004000e8    37 FUNC    GLOBAL<span class=\"built_in\"> DEFAULT </span>   1 foo</span><br><span class=\"line\">    14: 0000000000600198     0 NOTYPE  GLOBAL<span class=\"built_in\"> DEFAULT </span>   3 _edata</span><br><span class=\"line\">    15: 0000000000600198     0 NOTYPE  GLOBAL<span class=\"built_in\"> DEFAULT </span>   3 _end</span><br></pre></td></tr></table></figure>\n\n<p>link 後 symbol 填上 value，原本是 undefined 的 <code>sum</code> 跟 <code>foo</code> 都有各自的 address 跟所屬的 section。這個合併後的 symbol table 就是 global symbol table。</p>\n<p>接著，linker 從 global symbol table 知道 symbol 的 address，並依據 relocation table 知道哪些幾個指令要改以及怎麼改。<code>main.o</code> 跟 <code>foo.o</code> 的 relocation table：</p>\n<figure class=\"highlight routeros\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ readelf -r foo.o</span><br><span class=\"line\"></span><br><span class=\"line\">Relocation section <span class=\"string\">'.rela.text'</span> at offset 0x2a0 contains 3 entries:</span><br><span class=\"line\">  Offset          <span class=\"builtin-name\">Info</span>          <span class=\"built_in\"> Type </span>          Sym. Value    Sym. Name + Addend</span><br><span class=\"line\">000000000014  000c00000002 R_X86_64_PC32     0000000000000000 sum - 4</span><br><span class=\"line\">00000000001b  000300000002 R_X86_64_PC32     0000000000000000 .data + 0</span><br><span class=\"line\">00000000001f  000c0000000b R_X86_64_32S      0000000000000000 sum + 0</span><br><span class=\"line\"></span><br><span class=\"line\">Relocation section <span class=\"string\">'.rela.data'</span> at offset 0x2e8 contains 1 entries:</span><br><span class=\"line\">  Offset          <span class=\"builtin-name\">Info</span>          <span class=\"built_in\"> Type </span>          Sym. Value    Sym. Name + Addend</span><br><span class=\"line\">000000000008  000300000001 R_X86_64_64       0000000000000000 .data + 10</span><br><span class=\"line\"></span><br><span class=\"line\">Relocation section <span class=\"string\">'.rela.eh_frame'</span> at offset 0x300 contains 1 entries:</span><br><span class=\"line\">  Offset          <span class=\"builtin-name\">Info</span>          <span class=\"built_in\"> Type </span>          Sym. Value    Sym. Name + Addend</span><br><span class=\"line\">000000000020  000200000002 R_X86_64_PC32     0000000000000000 .text + 0</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">$ readelf -r main.o</span><br><span class=\"line\"></span><br><span class=\"line\">Relocation section <span class=\"string\">'.rela.text'</span> at offset 0x238 contains 1 entries:</span><br><span class=\"line\">  Offset          <span class=\"builtin-name\">Info</span>          <span class=\"built_in\"> Type </span>          Sym. Value    Sym. Name + Addend</span><br><span class=\"line\">00000000000f  000a00000002 R_X86_64_PC32     0000000000000000 foo - 4</span><br><span class=\"line\"></span><br><span class=\"line\">Relocation section <span class=\"string\">'.rela.eh_frame'</span> at offset 0x250 contains 1 entries:</span><br><span class=\"line\">  Offset          <span class=\"builtin-name\">Info</span>          <span class=\"built_in\"> Type </span>          Sym. Value    Sym. Name + Addend</span><br><span class=\"line\">000000000020  000200000002 R_X86_64_PC32     0000000000000000 .text + 0</span><br></pre></td></tr></table></figure>\n\n<p>offset 欄位表示需要 relocate 的 instrcution 所在位置，如 <code>foo.o</code> 的 <code>0x14</code> 是需要 <code>sum</code> address 的位置。</p>\n<p>修正 address 的方式依據 instruction 而定。簡單分成<strong>相對定址</strong>跟<strong>絕對定址</strong>，可由 relocation entry 的 type 知道是哪種定址模式。相對定址填入相對下一個指令 address 的 offset，絕對定址填入 symbol 的絕對 address，所以執行檔中有以 offset 跟絕對 address 得到 symbol address 的 instruction。<code>R_X86_64_PC32</code> 屬於相對定址，<code>R_X86_64_32S</code> 屬於絕對定址。看看 link 後會 instruction 怎麼改變：</p>\n<figure class=\"highlight angelscript\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ objdump -d foo.o</span><br><span class=\"line\"></span><br><span class=\"line\">Disassembly of section .text:</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"number\">0000000000000000</span> &lt;foo&gt;:</span><br><span class=\"line\">   <span class=\"number\">0</span>:   <span class=\"number\">55</span>                      push   %rbp</span><br><span class=\"line\">   <span class=\"number\">1</span>:   <span class=\"number\">48</span> <span class=\"number\">89</span> e5                mov    %rsp,%rbp</span><br><span class=\"line\">   <span class=\"number\">4</span>:   <span class=\"number\">89</span> <span class=\"number\">7</span>d fc                mov    %edi,<span class=\"number\">-0x4</span>(%rbp)</span><br><span class=\"line\">   <span class=\"number\">7</span>:   <span class=\"number\">89</span> <span class=\"number\">75</span> f8                mov    %esi,<span class=\"number\">-0x8</span>(%rbp)</span><br><span class=\"line\">   a:   <span class=\"number\">8</span>b <span class=\"number\">55</span> fc                mov    <span class=\"number\">-0x4</span>(%rbp),%edx</span><br><span class=\"line\">   d:   <span class=\"number\">8</span>b <span class=\"number\">45</span> f8                mov    <span class=\"number\">-0x8</span>(%rbp),%eax</span><br><span class=\"line\">  <span class=\"number\">10</span>:   <span class=\"number\">01</span> d0                   add    %edx,%eax</span><br><span class=\"line\">  <span class=\"number\">12</span>:   <span class=\"number\">89</span> <span class=\"number\">05</span> <span class=\"number\">00</span> <span class=\"number\">00</span> <span class=\"number\">00</span> <span class=\"number\">00</span>       mov    %eax,<span class=\"number\">0x0</span>(%rip)        # <span class=\"number\">18</span> &lt;foo+<span class=\"number\">0x18</span>&gt;</span><br><span class=\"line\">  <span class=\"number\">18</span>:   <span class=\"number\">48</span> c7 <span class=\"number\">05</span> <span class=\"number\">00</span> <span class=\"number\">00</span> <span class=\"number\">00</span> <span class=\"number\">00</span>    movq   $<span class=\"number\">0x0</span>,<span class=\"number\">0x0</span>(%rip)        # <span class=\"number\">23</span> &lt;foo+<span class=\"number\">0x23</span>&gt;</span><br><span class=\"line\">  <span class=\"number\">1f</span>:   <span class=\"number\">00</span> <span class=\"number\">00</span> <span class=\"number\">00</span> <span class=\"number\">00</span> </span><br><span class=\"line\">  <span class=\"number\">23</span>:   <span class=\"number\">5</span>d                      pop    %rbp</span><br><span class=\"line\">  <span class=\"number\">24</span>:   c3                      retq   </span><br><span class=\"line\">  </span><br><span class=\"line\"></span><br><span class=\"line\">$ objdump -d main.o</span><br><span class=\"line\"></span><br><span class=\"line\">Disassembly of section .text:</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"number\">0000000000000000</span> &lt;main&gt;:</span><br><span class=\"line\">   <span class=\"number\">0</span>:   <span class=\"number\">55</span>                      push   %rbp</span><br><span class=\"line\">   <span class=\"number\">1</span>:   <span class=\"number\">48</span> <span class=\"number\">89</span> e5                mov    %rsp,%rbp</span><br><span class=\"line\">   <span class=\"number\">4</span>:   be <span class=\"number\">03</span> <span class=\"number\">00</span> <span class=\"number\">00</span> <span class=\"number\">00</span>          mov    $<span class=\"number\">0x3</span>,%esi</span><br><span class=\"line\">   <span class=\"number\">9</span>:   bf <span class=\"number\">05</span> <span class=\"number\">00</span> <span class=\"number\">00</span> <span class=\"number\">00</span>          mov    $<span class=\"number\">0x5</span>,%edi</span><br><span class=\"line\">   e:   e8 <span class=\"number\">00</span> <span class=\"number\">00</span> <span class=\"number\">00</span> <span class=\"number\">00</span>          callq  <span class=\"number\">13</span> &lt;main+<span class=\"number\">0x13</span>&gt;</span><br><span class=\"line\">  <span class=\"number\">13</span>:   b8 <span class=\"number\">00</span> <span class=\"number\">00</span> <span class=\"number\">00</span> <span class=\"number\">00</span>          mov    $<span class=\"number\">0x0</span>,%eax</span><br><span class=\"line\">  <span class=\"number\">18</span>:   <span class=\"number\">5</span>d                      pop    %rbp</span><br><span class=\"line\">  <span class=\"number\">19</span>:   c3                      retq   </span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">$ objdump -d foo</span><br><span class=\"line\"></span><br><span class=\"line\">Disassembly of section .text:</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"number\">00000000004000e8</span> &lt;foo&gt;:</span><br><span class=\"line\">  <span class=\"number\">4000e8</span>:       <span class=\"number\">55</span>                      push   %rbp</span><br><span class=\"line\">  <span class=\"number\">4000e9</span>:       <span class=\"number\">48</span> <span class=\"number\">89</span> e5                mov    %rsp,%rbp</span><br><span class=\"line\">  <span class=\"number\">4000</span>ec:       <span class=\"number\">89</span> <span class=\"number\">7</span>d fc                mov    %edi,<span class=\"number\">-0x4</span>(%rbp)</span><br><span class=\"line\">  <span class=\"number\">4000</span>ef:       <span class=\"number\">89</span> <span class=\"number\">75</span> f8                mov    %esi,<span class=\"number\">-0x8</span>(%rbp)</span><br><span class=\"line\">  <span class=\"number\">4000f</span>2:       <span class=\"number\">8</span>b <span class=\"number\">55</span> fc                mov    <span class=\"number\">-0x4</span>(%rbp),%edx</span><br><span class=\"line\">  <span class=\"number\">4000f</span>5:       <span class=\"number\">8</span>b <span class=\"number\">45</span> f8                mov    <span class=\"number\">-0x8</span>(%rbp),%eax</span><br><span class=\"line\">  <span class=\"number\">4000f</span>8:       <span class=\"number\">01</span> d0                   add    %edx,%eax</span><br><span class=\"line\">  <span class=\"number\">4000f</span>a:       <span class=\"number\">89</span> <span class=\"number\">05</span> <span class=\"number\">94</span> <span class=\"number\">00</span> <span class=\"number\">20</span> <span class=\"number\">00</span>       mov    %eax,<span class=\"number\">0x200094</span>(%rip)        # <span class=\"number\">600194</span> &lt;sum&gt;</span><br><span class=\"line\">  <span class=\"number\">400100</span>:       <span class=\"number\">48</span> c7 <span class=\"number\">05</span> <span class=\"number\">7</span>d <span class=\"number\">00</span> <span class=\"number\">20</span> <span class=\"number\">00</span>    movq   $<span class=\"number\">0x600194</span>,<span class=\"number\">0x20007d</span>(%rip)        # <span class=\"number\">600188</span> &lt;p<span class=\"number\">.1749</span>&gt;</span><br><span class=\"line\">  <span class=\"number\">400107</span>:       <span class=\"number\">94</span> <span class=\"number\">01</span> <span class=\"number\">60</span> <span class=\"number\">00</span> </span><br><span class=\"line\">  <span class=\"number\">40010</span>b:       <span class=\"number\">5</span>d                      pop    %rbp</span><br><span class=\"line\">  <span class=\"number\">40010</span>c:       c3                      retq   </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"number\">000000000040010</span>d &lt;main&gt;:</span><br><span class=\"line\">  <span class=\"number\">40010</span>d:       <span class=\"number\">55</span>                      push   %rbp</span><br><span class=\"line\">  <span class=\"number\">40010</span>e:       <span class=\"number\">48</span> <span class=\"number\">89</span> e5                mov    %rsp,%rbp</span><br><span class=\"line\">  <span class=\"number\">400111</span>:       be <span class=\"number\">03</span> <span class=\"number\">00</span> <span class=\"number\">00</span> <span class=\"number\">00</span>          mov    $<span class=\"number\">0x3</span>,%esi</span><br><span class=\"line\">  <span class=\"number\">400116</span>:       bf <span class=\"number\">05</span> <span class=\"number\">00</span> <span class=\"number\">00</span> <span class=\"number\">00</span>          mov    $<span class=\"number\">0x5</span>,%edi</span><br><span class=\"line\">  <span class=\"number\">40011</span>b:       e8 c8 ff ff ff          callq  <span class=\"number\">4000e8</span> &lt;foo&gt;</span><br><span class=\"line\">  <span class=\"number\">400120</span>:       b8 <span class=\"number\">00</span> <span class=\"number\">00</span> <span class=\"number\">00</span> <span class=\"number\">00</span>          mov    $<span class=\"number\">0x0</span>,%eax</span><br><span class=\"line\">  <span class=\"number\">400125</span>:       <span class=\"number\">5</span>d                      pop    %rbp</span><br><span class=\"line\">  <span class=\"number\">400126</span>:       c3                      retq</span><br></pre></td></tr></table></figure>\n\n<p>compile <code>foo.c</code> 跟 <code>main.c</code> 時 compiler 不知道 reference 到外部 symbol 的 address，在 instruction 中填入 0，link 才填入真正的 address。</p>\n<p><code>foo.o</code> 的 instruction 從</p>\n<figure class=\"highlight angelscript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">12</span>:   <span class=\"number\">89</span> <span class=\"number\">05</span> <span class=\"number\">00</span> <span class=\"number\">00</span> <span class=\"number\">00</span> <span class=\"number\">00</span>       mov    %eax,<span class=\"number\">0x0</span>(%rip)        # <span class=\"number\">18</span> &lt;foo+<span class=\"number\">0x18</span>&gt;</span><br><span class=\"line\"><span class=\"number\">18</span>:   <span class=\"number\">48</span> c7 <span class=\"number\">05</span> <span class=\"number\">00</span> <span class=\"number\">00</span> <span class=\"number\">00</span> <span class=\"number\">00</span>    movq   $<span class=\"number\">0x0</span>,<span class=\"number\">0x0</span>(%rip)        # <span class=\"number\">23</span> &lt;foo+<span class=\"number\">0x23</span>&gt;</span><br><span class=\"line\"><span class=\"number\">1f</span>:   <span class=\"number\">00</span> <span class=\"number\">00</span> <span class=\"number\">00</span> <span class=\"number\">00</span></span><br></pre></td></tr></table></figure>\n\n<p>變成</p>\n<figure class=\"highlight angelscript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">4000f</span>a:       <span class=\"number\">89</span> <span class=\"number\">05</span> <span class=\"number\">94</span> <span class=\"number\">00</span> <span class=\"number\">20</span> <span class=\"number\">00</span>       mov    %eax,<span class=\"number\">0x200094</span>(%rip)        # <span class=\"number\">600194</span> &lt;sum&gt;</span><br><span class=\"line\"><span class=\"number\">400100</span>:       <span class=\"number\">48</span> c7 <span class=\"number\">05</span> <span class=\"number\">7</span>d <span class=\"number\">00</span> <span class=\"number\">20</span> <span class=\"number\">00</span>    movq   $<span class=\"number\">0x600194</span>,<span class=\"number\">0x20007d</span>(%rip)        # <span class=\"number\">600188</span> &lt;p<span class=\"number\">.1749</span>&gt;</span><br><span class=\"line\"><span class=\"number\">400107</span>:       <span class=\"number\">94</span> <span class=\"number\">01</span> <span class=\"number\">60</span> <span class=\"number\">00</span></span><br></pre></td></tr></table></figure>\n\n<p><code>mov</code> 使用相對定址 access <code>sum (0x600194)</code>，將下一個 instruction 的 address <code>0x400100</code> 加上 <code>0x200094</code> 得到 <code>sum</code> 的 address，可從 symbol table 驗證。<code>movq</code> 使用絕對定址，由上 <code>0x400107</code> 可以看到 <code>sum</code> 的 address 直接寫進 instruction 了。之所以在 instruction 中數值看起來是反過來的，是因為 intel x86 CPU 使用 little-endian（<a href=\"https://en.wikipedia.org/wiki/Endianness\" target=\"_blank\" rel=\"noopener\">Endianness wiki</a>）。</p>\n<p><code>main.o</code> 則是</p>\n<figure class=\"highlight angelscript\"><table><tr><td class=\"code\"><pre><span class=\"line\">e:   e8 <span class=\"number\">00</span> <span class=\"number\">00</span> <span class=\"number\">00</span> <span class=\"number\">00</span>          callq  <span class=\"number\">13</span> &lt;main+<span class=\"number\">0x13</span>&gt;</span><br></pre></td></tr></table></figure>\n\n<p>變成</p>\n<figure class=\"highlight angelscript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">40011</span>b:       e8 c8 ff ff ff          callq  <span class=\"number\">4000e8</span> &lt;foo&gt;</span><br></pre></td></tr></table></figure>\n\n<p><code>callq</code> 指令要 call <code>foo()</code>，其中 <code>e8</code> 是指令本身，<code>ffffffc8</code> 是 offset，以二的補數來看是十進位 <code>-56</code>，所以 <code>0x400120 - 0x38 = 0x4000e8</code>，就是 <code>foo()</code> 的 address 啦。</p>\n<h2 id=\"Ref\"><a href=\"#Ref\" class=\"headerlink\" title=\"Ref\"></a>Ref</h2><ul>\n<li>《程式設計師的自我修養》 ch 4</li>\n<li><a href=\"https://en.wikipedia.org/wiki/Endianness\" target=\"_blank\" rel=\"noopener\">Endianness wiki</a></li>\n</ul>\n","tags":["System Software"]},{"title":"Day 1 從計算機結構到組合語言程式入門","url":"/30dayos/day1/","content":"<p>開始看買來放了一陣的<a href=\"https://www.tenlong.com.tw/products/9787115287960\" target=\"_blank\" rel=\"noopener\">《30 天自制操作系統》</a>（簡中翻譯日文書），原本以為是本很硬很難啃的 OS 書，沒想到意外有趣！作者有各種各樣的 murmur 跟吐槽滿點。翻譯除了專有名詞，語句上蠻通順的。</p>\n<p>Day 1 直接用 binary editor 幹出一個 hello world OS。</p>\n<p>本書使用的組譯器是作者自己開發的 nask，其中很多語法模仿 NASM。</p>\n<h2 id=\"nask-指令-amp-符號\"><a href=\"#nask-指令-amp-符號\" class=\"headerlink\" title=\"nask 指令 &amp; 符號\"></a>nask 指令 &amp; 符號</h2><ul>\n<li>DB：define byte，直接在 file 裡輸入一個 byte 的內容</li>\n<li>RESB：reserve byte，從現在的位置空出幾個 byte<ul>\n<li>nask 會幫空出來的 byte 填上 <code>0x00</code></li>\n</ul>\n</li>\n<li>DW：define word<ul>\n<li>word 在這邊是 16 bit，2 byte。</li>\n<li>word 長度應該是因機器架構而異。</li>\n</ul>\n</li>\n<li>DD：define double word<ul>\n<li>double word 則是 32 bit，4 byte。</li>\n</ul>\n</li>\n</ul>\n<p>指令中符號 <code>$</code> 代表 file 到目前這行所在的 byte 數。</p>\n<h2 id=\"術語解釋\"><a href=\"#術語解釋\" class=\"headerlink\" title=\"術語解釋\"></a>術語解釋</h2><ul>\n<li>boot sector（啟動區）<ul>\n<li>電腦讀寫磁碟不是一個個 byte 讀寫，而是以 512 byte 為一個單位讀寫。512 byte 稱為一個 sector。</li>\n<li>floppy disk 第一個 sector 稱為 boot sector。<ul>\n<li><em>我猜對硬碟也適用</em></li>\n</ul>\n</li>\n<li>電腦啟動時，會從第一個 sector 讀起，檢查這個 sector 最後兩個 byte 的內容。如果最後兩 byte 是 <code>0x55 AA</code> 則認為這個 sector 的開頭是啟動程序，接著開始執行這個程序。反之，則是沒有啟動程序，會出現啟動錯誤。<ul>\n<li>至於為什麼是 <code>0x55 AA</code> ，就當初的人亂訂的吧……(爆</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>IPL：initial program loader 的縮寫<ul>\n<li>boot sector 只有 512 byte，通常 OS 都放不進去，所以 boot sector 通常是放 load OS 的 loader 程式。</li>\n<li>有時也將 boot sector 稱為 IPL</li>\n</ul>\n</li>\n<li>boot<ul>\n<li>是 bootstrap 的縮寫</li>\n<li>有「自力更生完成任務」的意思（來源是德國《吹牛大王歷險記》）</li>\n</ul>\n</li>\n</ul>\n","categories":["30 天自製作業系統"],"tags":["OS"]},{"title":"Day 2 組合語言學習與 Makefile 入門","url":"/30dayos/day2/","content":"<p>來解釋這段組語在幹嘛~</p>\n<figure class=\"highlight x86asm\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">; hello-os</span></span><br><span class=\"line\"><span class=\"comment\">; TAB=4</span></span><br><span class=\"line\"></span><br><span class=\"line\">        ORG\t\t<span class=\"number\">0x7c00</span>\t\t\t<span class=\"comment\">; 指明程式的 load 位置</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">; 以下的記述用於標準 FAT12 格式的磁片</span></span><br><span class=\"line\">        <span class=\"keyword\">JMP</span>\t\tentry</span><br><span class=\"line\">        <span class=\"built_in\">DB</span>\t\t<span class=\"number\">0x90</span></span><br><span class=\"line\"></span><br><span class=\"line\">--- (中略) ---</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">; 程式核心</span></span><br><span class=\"line\"><span class=\"symbol\">entry:</span>\t\t\t\t\t\t\t<span class=\"comment\">; label</span></span><br><span class=\"line\">        <span class=\"keyword\">MOV</span>\t\t<span class=\"built_in\">AX</span>,<span class=\"number\">0</span>\t\t\t<span class=\"comment\">; initialize register</span></span><br><span class=\"line\">        <span class=\"keyword\">MOV</span>\t\t<span class=\"built_in\">SS</span>,<span class=\"built_in\">AX</span></span><br><span class=\"line\">        <span class=\"keyword\">MOV</span>\t\t<span class=\"built_in\">SP</span>,<span class=\"number\">0x7c00</span></span><br><span class=\"line\">        <span class=\"keyword\">MOV</span>\t\t<span class=\"built_in\">DS</span>,<span class=\"built_in\">AX</span></span><br><span class=\"line\">        <span class=\"keyword\">MOV</span>\t\t<span class=\"built_in\">ES</span>,<span class=\"built_in\">AX</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">MOV</span>\t\t<span class=\"built_in\">SI</span>,msg\t\t\t<span class=\"comment\">; SI = msg 的 address</span></span><br><span class=\"line\"><span class=\"symbol\">putloop:</span></span><br><span class=\"line\">        <span class=\"comment\">; 將 memory address 為 SI register 值的資料 assign 給 AL</span></span><br><span class=\"line\">        <span class=\"keyword\">MOV</span>\t\t<span class=\"built_in\">AL</span>,[<span class=\"built_in\">SI</span>]\t\t\t</span><br><span class=\"line\">        <span class=\"keyword\">ADD</span>\t\t<span class=\"built_in\">SI</span>,<span class=\"number\">1</span>\t\t\t<span class=\"comment\">; SI + 1</span></span><br><span class=\"line\">        <span class=\"keyword\">CMP</span>\t\t<span class=\"built_in\">AL</span>,<span class=\"number\">0</span>\t\t\t<span class=\"comment\">; 比較 AL 的值是否為 0</span></span><br><span class=\"line\">        <span class=\"keyword\">JE</span>\t\tfin</span><br><span class=\"line\">        <span class=\"keyword\">MOV</span>\t\t<span class=\"number\">AH</span>,<span class=\"number\">0x0e</span>\t\t\t<span class=\"comment\">; 顯示一個文字</span></span><br><span class=\"line\">        <span class=\"keyword\">MOV</span>\t\t<span class=\"built_in\">BX</span>,<span class=\"number\">15</span>\t\t\t<span class=\"comment\">; 指定文字顏色</span></span><br><span class=\"line\">        <span class=\"keyword\">INT</span>\t\t<span class=\"number\">0x10</span>\t\t\t<span class=\"comment\">; call 顯卡 BIOS</span></span><br><span class=\"line\">        <span class=\"keyword\">JMP</span>\t\tputloop</span><br><span class=\"line\"><span class=\"symbol\">fin:</span></span><br><span class=\"line\">        <span class=\"keyword\">HLT</span>\t\t\t\t\t<span class=\"comment\">; 讓 CPU 停止，等待指令</span></span><br><span class=\"line\">        <span class=\"keyword\">JMP</span>\t\tfin\t\t\t<span class=\"comment\">; infinite loop</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"symbol\">msg:</span></span><br><span class=\"line\">        <span class=\"built_in\">DB</span>\t\t<span class=\"number\">0x0a</span>, <span class=\"number\">0x0a</span>\t\t<span class=\"comment\">; 換行兩次</span></span><br><span class=\"line\">        <span class=\"built_in\">DB</span>\t\t<span class=\"string\">\"hello, world\"</span></span><br><span class=\"line\">        <span class=\"built_in\">DB</span>\t\t<span class=\"number\">0x0a</span>\t\t\t<span class=\"comment\">; 換行</span></span><br><span class=\"line\">        <span class=\"built_in\">DB</span>\t\t<span class=\"number\">0</span></span><br></pre></td></tr></table></figure>\n\n<p><code>ORG</code> 指令告訴 nask 程式要從指定的 address 開始，即要把程式 load 到 memory 中指定的 address <em>（這裡總有點半懂不懂）</em>。有這個指令時，<a href=\"30dayos/day1/\">Day 1 從計算機結構到組合語言程式入門</a> 提到的 <code>$</code> 不再是 output file 的第幾個 byte，而是代表將要 read 的 memory address。</p>\n<p><code>entry:</code> 是 label，每個 label 都代表一個 address。位置的值是由 assembler 根據 ORG 計算出「label 所在的地方對應的 address」。</p>\n<p><code>MOV</code> 基本上就是 assignment，source 跟 destination 可以是 register、常數或者 memory address。</p>\n<p>CPU 裡比較重要的 register 及其完整名稱：</p>\n<ul>\n<li>AX：accumulator</li>\n<li>CX：counter</li>\n<li>DX：data</li>\n<li>BX：base</li>\n<li>SP：stack pointer</li>\n<li>BP：base pointer</li>\n<li>SI：source index</li>\n<li>DI：destination index</li>\n</ul>\n<p>這些 register 都是 16 bit。</p>\n<p>另外 CPU 還有 8 個 8 bit register：</p>\n<ul>\n<li>AL：accumulator low</li>\n<li>CL：counter low</li>\n<li>DL：data low</li>\n<li>BL：base low</li>\n<li>AH：accumulator high</li>\n<li>CH：counter high</li>\n<li>DH：data high</li>\n<li>BH：base high</li>\n</ul>\n<p>這些 register 是上面其中幾個 16 bit register 的高位跟低位而已，不是額外的 register。</p>\n<p>那 32 bit register 呢？就是 EAX、ECX、EDX、EBX、ESP、EBP、ESI 跟 EDI 啦～也就是 16 bit register 再擴展一倍，實際上 EAX 有一部分是跟 AX 共用的，跟 8 bit register 與 16 bit register 的關係一樣。</p>\n<p><code>MOV</code> 中，以方括號 <code>[ ]</code> 包起來，表示 memory address。</p>\n<p><code>MOV WORD [678], 123</code> 表示把 123 以 WORD 的大小（16 bit）放到 memory address 678 的地方。數字 123 的二進位表示成 16 bit 是 <code>0000000001111011</code> ，低位 byte <code>01111011</code> 會放在 address 678（memory address 小），高位 byte <code>00000000</code> 則會放在 address 679（memory address 大）。</p>\n<p>位元組順序（Endianness）是指資料在 memory 或傳輸過程中 byte 的擺放順序。將資料的低位 byte 放在 memory address 小、高位 byte 放在 memory address 大的擺放方式稱為 Little-Endian。反之，資料低位 byte 放在 memory address 大、高位 byte 放在 memory address 小，稱為 Big-Endian。一般 x86 的機器是使用 Little-Endian。</p>\n<p>指定 address 的方式，除了用常數，也可以用 register 的值。不過不是所有 register 都可以拿來做這件事，只有 BX、BP、SI 跟 DI 可以。所以 <code>MOV AL, BYTE [SI]</code> 是將 SI register 裡的值當作 address 去 memory 取得一個 byte 的資料並將 assign 給 register AL。另外，<code>MOV</code> 指令有個規則：source 跟 destination 的 byte 數必須相同。能放進 AL 的只有 BYTE，所以上面的指令可以省略 <code>BYTE</code> 變成 <code>MOV AL, [SI]</code>。</p>\n<p><code>JE</code>：如果比較結果相等，則 jump 到特定的 address；若不等，則不 jump，繼續做下一個指令。</p>\n<p>BIOS 是讓 OS 開發人員可以使用的各種 function 的集合。可以用指令 <code>INT</code> call 這些 function，它後面是個數字，不同數字代表不同 function，<code>0x10</code> 的功能是控制顯卡。</p>\n<p>使用 BIOS 的 function 跟其他 level 的程式 call function 一樣，查要的功能是用哪個數字（像 function name），接著照 function 定義在各 register 放值（像 function 參數），register 設好後用 <code>INT</code> call function。</p>\n<p><code>HLT</code> 是讓 CPU 進入待機狀態的指令，才不會 infinite loop 瞎跑。</p>\n<p>在整個 memory 裡，有些區域是有特定用途、不能隨便用的。其中 <code>0x00007c00</code> 到 <code>0x00007dff</code> 這段是 boot sector 的 loading address。所以 <code>ORG</code> 指令才要寫 <code>0x00007c00</code> ，把這份程式 load 到那個 address 才會被當作 boot sector 來 run～（至於為什麼要是這個 address……不知道又是誰訂的XD）</p>\n<p>電腦開機時 BIOS 會在可開機 device 中找 boot signature──在 boot sector 裡最後兩個 byte <code>0x55 AA</code>。BIOS 找到這樣的 boot sector，便將 boot sector load 到 memory address <code>0x00007c00</code> 的位置。接著便開始執行剛 load 進來的 boot record。floppy disk 的整個 boot sector 都是可執行 code（除了最後兩個 byte）。hard disk 的 MBR（Master Boot Record）在（硬碟 boot sector）位置 <code>0x0000</code> ~ <code>0x01bd</code> 是可執行 code，接著後面是 parition table（<code>0x01be</code> ~ <code>0x01fd</code>）以及 boot signature（<code>0x01fe</code> ~ <code>0x01ff</code>）。</p>\n<p>因為 BIOS 會把 boot sector load 到 memory address <code>0x00007c00</code>，所以用 <code>ORG</code> 指令就要寫 <code>0x00007c00</code>。這樣組譯出來的 machine code 裡的各個 memory address 才會是對的。</p>\n<h2 id=\"Ref\"><a href=\"#Ref\" class=\"headerlink\" title=\"Ref\"></a>Ref</h2><ul>\n<li><a href=\"https://wiki.osdev.org/Boot_Sequence#Master_Boot_Record\" target=\"_blank\" rel=\"noopener\">Boot Sequence - Master Boot Record</a></li>\n</ul>\n","categories":["30 天自製作業系統"],"tags":["OS"]},{"title":"Day 4 C 語言與畫面顯示的練習","url":"/30dayos/day4/","content":"<p>這天很多在介紹 C，尤其是 pointer，作者用組語的角度去看 C，很有趣。這邊只寫些簡單的筆記。</p>\n<p>組語跟 C 一起使用時，只有 <code>EAX</code>、<code>ECX</code>、<code>EDX</code> 三個 register 可以使用，其他 register 只能 read 不能 write，因為它們存著 C 語言程式的相關資料。</p>\n<p>C 語言中，普通數值跟表示 memory address 的數值被當作兩種不同的東西。</p>\n<p>根據 C 語言規定，組語執行 <code>RET</code> 指令時， <code>EAX</code> 中的值就被看作是 function return value。</p>\n<h2 id=\"調色盤設定顏色\"><a href=\"#調色盤設定顏色\" class=\"headerlink\" title=\"調色盤設定顏色\"></a>調色盤設定顏色</h2><p>在 8 bit 彩色模式下，顏色以 8 個 bit 表示，也就是 0~255。</p>\n<p>每個數字表示什麼顏色，是由 developer 來決定的，不像 RGB 的 <code>#ffffff</code> 固定代表某個顏色。使用 0~255 表示顏色前，developer 要先幫這些數字指定好對應的顏色，例如 25 對應 <code>#ffffff</code> 等等。這種方式稱為「調色盤」。</p>\n<p>設定調色盤的步驟如下：</p>\n<ol>\n<li>先 block interrupt</li>\n<li>依據設定調色盤的方式，對 IO device 的某些 port 寫入資料</li>\n<li>恢復對 interrupt 的處理</li>\n</ol>\n<h3 id=\"向-IO-Device-read-write\"><a href=\"#向-IO-Device-read-write\" class=\"headerlink\" title=\"向 IO Device read/write\"></a>向 IO Device read/write</h3><p>先來看怎麼對 IO device 讀寫。</p>\n<p>CPU 與 IO device 相連，CPU 要能控制 IO device 當然有向 device 發送訊號與從 device 接收訊號的指令。</p>\n<p>向 device 發送訊號的指令是 <code>OUT</code>，反之從 device 接收訊號的指令是 <code>IN</code>。就像 memory 用 memory address 區分不同位置，device 以 device port 區分不同 device。組語實作從 device read 與 write 到 device 的 function 們：</p>\n<figure class=\"highlight routeros\"><table><tr><td class=\"code\"><pre><span class=\"line\">; read 8 bit</span><br><span class=\"line\">_io_in8:\t; int io_in8(int port);</span><br><span class=\"line\">        MOV\t\tEDX,[ESP+4]\t;<span class=\"built_in\"> port </span>(port number 只有 16 bit)</span><br><span class=\"line\">        MOV\t\tEAX,0           ; 把 return value 清成 0</span><br><span class=\"line\">        <span class=\"keyword\">IN</span>\t\tAL,DX           ; read 8 bit (AL)</span><br><span class=\"line\">        RET                             ; EAX 的值是 return value</span><br><span class=\"line\"></span><br><span class=\"line\">_io_in16:\t; int io_in16(int port);</span><br><span class=\"line\">        MOV\t\tEDX,[ESP+4]\t; port</span><br><span class=\"line\">        MOV\t\tEAX,0</span><br><span class=\"line\">        <span class=\"keyword\">IN</span>\t\tAX,DX           ; read 16 bit (AX)</span><br><span class=\"line\">        RET</span><br><span class=\"line\"></span><br><span class=\"line\">_io_in32:\t; int io_in32(int port);</span><br><span class=\"line\">        MOV\t\tEDX,[ESP+4]\t; port</span><br><span class=\"line\">        <span class=\"keyword\">IN</span>\t\tEAX,DX          ; read 32 bit (EAX)</span><br><span class=\"line\">        RET</span><br><span class=\"line\"></span><br><span class=\"line\">; write 8 bit</span><br><span class=\"line\">_io_out8:\t; void io_out8(int port, int data);</span><br><span class=\"line\">        MOV\t\tEDX,[ESP+4]\t\t; port</span><br><span class=\"line\">        MOV\t\tAL,[ESP+8]\t\t; data</span><br><span class=\"line\">        OUT\t\tDX,AL</span><br><span class=\"line\">        RET</span><br><span class=\"line\"></span><br><span class=\"line\">_io_out16:\t; void io_out16(int port, int data);</span><br><span class=\"line\">        MOV\t\tEDX,[ESP+4]\t\t; port</span><br><span class=\"line\">        MOV\t\tEAX,[ESP+8]\t\t; data</span><br><span class=\"line\">        OUT\t\tDX,AX</span><br><span class=\"line\">        RET</span><br><span class=\"line\"></span><br><span class=\"line\">_io_out32:\t; void io_out32(int port, int data);</span><br><span class=\"line\">        MOV\t\tEDX,[ESP+4]\t\t; port</span><br><span class=\"line\">        MOV\t\tEAX,[ESP+8]\t\t; data</span><br><span class=\"line\">        OUT\t\tDX,EAX</span><br><span class=\"line\">        RET</span><br></pre></td></tr></table></figure>\n\n<p>我們要設定調色板，就是找出對應 device 設定調色板的指令，然後照著做～</p>\n<h3 id=\"CLI-與-STI\"><a href=\"#CLI-與-STI\" class=\"headerlink\" title=\"CLI 與 STI\"></a>CLI 與 STI</h3><p><code>CLI</code> 是將 interrupt flag clear 為 0 的指令， <code>STI</code> 則是將 interrupt flag set 為 1 的指令。</p>\n<p>interrupt flag 為 0 時，CPU 遇到 interrupt 會忽略它、不處理，flag 為 1 時 CPU 就會處理 interrupt。</p>\n<h3 id=\"EFLAGS-register\"><a href=\"#EFLAGS-register\" class=\"headerlink\" title=\"EFLAGS register\"></a>EFLAGS register</h3><p><code>EFLAGS</code> 是由 <code>FLAGS</code> 16 bit 的 register 擴展而來的 32 bit register。</p>\n<p><code>FLAGS</code> 儲存 carry flag（進位 flag）與 interrupt flag 等 flag，不同 bit 代表不同 flag（有 1 個 bit 表示一個 flag 也有 2 個 bit），如下所示：</p>\n<table>\n<thead>\n<tr>\n<th>15</th>\n<th>14</th>\n<th>13</th>\n<th>12</th>\n<th>11</th>\n<th>10</th>\n<th>9</th>\n<th>8</th>\n<th>7</th>\n<th>6</th>\n<th>5</th>\n<th>4</th>\n<th>3</th>\n<th>2</th>\n<th>1</th>\n<th>0</th>\n</tr>\n</thead>\n<tbody><tr>\n<td></td>\n<td>NT</td>\n<td>IOPL</td>\n<td>IOPL</td>\n<td>OF</td>\n<td>DF</td>\n<td>IF</td>\n<td>TF</td>\n<td>SF</td>\n<td>ZF</td>\n<td></td>\n<td>AF</td>\n<td></td>\n<td>PF</td>\n<td></td>\n<td>CF</td>\n</tr>\n</tbody></table>\n<p><code>IOPL</code> 是第 12 跟 13 bit 放在一起處理。</p>\n<p>EFLAGS 沒有 <code>MOV</code> 指令，只能使用 <code>PUSHFD</code> 跟 <code>POPFD</code> 來讀寫。</p>\n<p><code>PUSHFD</code> 是 push flags double-word 的縮寫，以 double word 的長度（32 bit）將 flag 的值 push 進 stack，等同 <code>PUSH EFLAGS</code>。<code>POPFD</code> 是 pop flags double-word，將 double word 長度的值從 stack pop 出來到 flag，等同 <code>POP EFLAGS</code>。</p>\n<p>如果想把 <code>EFLAGS</code> 內的資料放到 <code>EAX</code> 裡，不能用 <code>MOV</code>，而要先 <code>PUSHFD</code> 再 <code>POP EAX</code>。反過來想把 <code>EAX</code> 的資料放進 <code>EFLAGS</code> 裡則是 <code>PUSH EAX</code> 再 <code>POPFD</code>。操作 <code>EFLAGS</code> 的組語 code 如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">_io_load_eflags:\t; int io_load_eflags(void);</span><br><span class=\"line\">        PUSHFD\t\t; PUSH EFLAGS</span><br><span class=\"line\">        POP\t\tEAX</span><br><span class=\"line\">        RET</span><br><span class=\"line\"></span><br><span class=\"line\">_io_store_eflags:\t; void io_store_eflags(int eflags);</span><br><span class=\"line\">        MOV\t\tEAX,[ESP+4]</span><br><span class=\"line\">        PUSH\tEAX</span><br><span class=\"line\">        POPFD\t\t; POP EFLAGS</span><br><span class=\"line\">        RET</span><br></pre></td></tr></table></figure>\n\n<p>設定調色盤要先執行 <code>CLI</code>，為了在設定完後恢復 interrupt flag 的值，要先把原本的值記下來。我們可以直接把整個 eflags 記下來、執行 <code>CLI</code>、設定調色盤，最後直接把整個 eflags 的值再存回去，達到恢復 interrupt flag 的效果。</p>\n<h2 id=\"在螢幕上畫圖\"><a href=\"#在螢幕上畫圖\" class=\"headerlink\" title=\"在螢幕上畫圖\"></a>在螢幕上畫圖</h2><p>螢幕上每個像素都對應到 VRAM 中的一個 address。向 VRAM 指定值，便能指定螢幕上像素的顏色。</p>\n","categories":["30 天自製作業系統"],"tags":["OS"]},{"title":"ch2 Working with Feedback","url":"/Working-Effectively-with-Legacy-Code/ch2-Working-with-Feedback/","content":"<p>《Working Effectively with Legacy Code》對 unit test 跟更高層的 test 概念跟《單元測試》差不多，只是沒特別用 integration test 這個詞而已。</p>\n<h1 id=\"Chapter-Summary\"><a href=\"#Chapter-Summary\" class=\"headerlink\" title=\"Chapter Summary\"></a>Chapter Summary</h1><ul>\n<li>要用 unit test 保護修改<ul>\n<li>才知道新修改有沒有改對，以及有沒有改壞原本的東西</li>\n<li>跑測試的速度：需要 0.1s 才能跑完的 unit test 就算慢了</li>\n</ul>\n</li>\n<li>修改 legacy code 步驟 overview<ol>\n<li>確定變動點：ch 16、17</li>\n<li>找出測試點：ch 11、12</li>\n<li>解依賴：ch 23</li>\n<li>編寫測試：ch 13</li>\n<li>修改、refactor：ch 20 ~ 22</li>\n</ol>\n</li>\n</ul>\n","categories":["Working Effectively with Legacy Code"],"tags":["Refactor"]},{"title":"ch3 Sensing and Separation","url":"/Working-Effectively-with-Legacy-Code/ch3-Sensing-and-Separation/","content":"<h1 id=\"Chapter-Summary\"><a href=\"#Chapter-Summary\" class=\"headerlink\" title=\"Chapter Summary\"></a>Chapter Summary</h1><p>為了能夠測試，有兩個進行解依賴的理由：</p>\n<ul>\n<li>Sense（感測）是指「得知執行某一塊 code 後會有什麼樣的結果、產生什麼影響」<ul>\n<li>著重在「不是簡單可以透過 return value 得知執行結果」的結果類型</li>\n<li>《單元測試》的互動測試</li>\n</ul>\n</li>\n<li>Separation（分離）是想把某段程式邏輯從它所在的地方分離出來，好能夠在測試裡使用</li>\n</ul>\n<h1 id=\"與《單元測試》比對\"><a href=\"#與《單元測試》比對\" class=\"headerlink\" title=\"與《單元測試》比對\"></a>與《單元測試》比對</h1><ul>\n<li>fake object<ul>\n<li>《單元測試》中是各種假物件的通稱，包含 stub、mock object 都是 fake object。</li>\n<li>本書用來 sense 執行某段 code 的影響，比較像《單元測試》裡簡易的 mock object。</li>\n</ul>\n</li>\n<li>mock object<ul>\n<li>兩書的概念一樣，都是互動測試用的。</li>\n</ul>\n</li>\n</ul>\n<h1 id=\"Murmur\"><a href=\"#Murmur\" class=\"headerlink\" title=\"Murmur\"></a>Murmur</h1><p>用不同方式看同一個東西的感覺真有趣～可以互相比較異同～</p>\n","categories":["Working Effectively with Legacy Code"],"tags":["Refactor"]},{"title":"ch5 Tool","url":"/Working-Effectively-with-Legacy-Code/ch5-Tool/","content":"<h1 id=\"Summary\"><a href=\"#Summary\" class=\"headerlink\" title=\"Summary\"></a>Summary</h1><ul>\n<li>自動化重構工具<ul>\n<li>像 JetBrains、Visual Studio 等 IDE 的 refactor 功能。</li>\n<li>在工具夠好的情況下，可以在沒有為 code 寫測試的情況下用工具進行自動化 refactor。但有時工具可能有問題，refactor 卻會修改到程式行為，所以使用工具進行 refactor 前，如果能先寫測試還是比較好的。</li>\n<li>要注意工具在 refactor 時會跟不會進行哪些檢查<ul>\n<li>例如 extract method，如果將新 method 命名為已存在 method 的名字，工具會不會顯示錯誤？</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>Unit Test 工具<ul>\n<li>xUnit framework<br>  這類型 framework 執行測試大致的作法：找到 test class 裡所有 test method（依據語言不同有不同作法，有些語言可以用 reflection），為每個 test method 產生一個單獨的 object，該 object 的任務是去執行那個 test method。利用不同 object 隔離 test case，讓 test case 不會互相影響。</li>\n</ul>\n</li>\n<li>一般測試控制工具<ul>\n<li>FIT (Framework for Integration Test）</li>\n<li>Fitnesse</li>\n<li>Selenium</li>\n<li><em>……等等其他</em></li>\n</ul>\n</li>\n</ul>\n","categories":["Working Effectively with Legacy Code"],"tags":["Refactor"]},{"title":"ch4 The Seam Model","url":"/Working-Effectively-with-Legacy-Code/ch4-The-Seam-Model/","content":"<h1 id=\"Seam-amp-Enabling-Point\"><a href=\"#Seam-amp-Enabling-Point\" class=\"headerlink\" title=\"Seam &amp; Enabling Point\"></a>Seam &amp; Enabling Point</h1><p>seam（接縫）是指程式中一些特殊的點，在這些點上你不需要修改它本身就可以變動程式行為。</p>\n<p>例如某段程式 call 了一個 function 來計算商品價格，現在想改變計算價格的 strategy。想在不改變 call 計價 function 的情況下，改變計價結果（程式行為）。</p>\n<p>又例如程式 call 到牽連龐大子系統的 function，我們希望在 test 中避免執行到那些複雜的 code（不然很難測或無法測），又要在 prodcution code 裡照常執行到。如果這段 code 有 seam，便能在不改動到原本 call function 的情況下，換掉該 function 的行為來避免在 test 中碰到子系統。</p>\n<p>每個 seam 都有一個 enabling point，在這裡你可以決定使用哪種行為。</p>\n<p>seam 是可以讓你改變程式行為的「縫隙」，enabling point 則是決定那個 seam 要是什麼行為。在 enabling point 給不同的值，可以讓 seam 有不同的行為。例如物件 seam，物件 method 的參數列表是 enabling point，因為我們可以傳入不同的物件來改變程式行為。</p>\n<p>為一團亂的 code 測試時，最好別去修改它本身，盡可能透過 seam 去解開 dependency 來測試。</p>\n<h1 id=\"Seam-Types\"><a href=\"#Seam-Types\" class=\"headerlink\" title=\"Seam Types\"></a>Seam Types</h1><p>seam 有很多種類型。不同的語言，可以使用的類型也不同。一個語言從程式碼轉換到 machine code 的各個階段，擁有不同種類的 seam。</p>\n<ul>\n<li>preprocess 時期 seam<ul>\n<li>在 C/C++ 裡可以用 macro 直接把字換掉來達到改變行為，例如直接把有 dependency 的 function call 用 <code>#define</code> 在 <code>#ifdef TESTING</code> 時換成空的 function。</li>\n<li>enabling point 是 <code>#define TESTING</code></li>\n</ul>\n</li>\n<li>link 時期 seam：在將多個 object file link 起來時的 seam<ul>\n<li>dynamic link：直接換掉 dynamic link 要去找的 library 或 object file。</li>\n<li>static link：透過 build script（像 Makefile），在測試環境去 link 抽換的 object file 而非原本 production code 的 object file。</li>\n<li>enabling point 通常在 build 或 deploy script 裡，因為這時候才決定 link 誰。</li>\n</ul>\n</li>\n<li>object seam<ul>\n<li>一般用 interface、polymorphism 來做 dependency injection，以及 extract and override。</li>\n</ul>\n</li>\n</ul>\n","categories":["Working Effectively with Legacy Code"],"tags":["Refactor"]},{"title":"Get started with Docker Part 1 & 2","url":"/get-started-with-docker/part-1-2/","content":"<p><a href=\"https://docs.docker.com/get-started/\" target=\"_blank\" rel=\"noopener\">Dodkcer Get Started</a> 隨手記。</p>\n<h2 id=\"Part-1-Orientation-and-setup\"><a href=\"#Part-1-Orientation-and-setup\" class=\"headerlink\" title=\"Part 1: Orientation and setup\"></a><a href=\"https://docs.docker.com/get-started/\" target=\"_blank\" rel=\"noopener\">Part 1: Orientation and setup</a></h2><blockquote>\n<p>Docker is a platform for developers and sysadmins to <strong>develop, deploy, and run</strong> applications with containers.</p>\n</blockquote>\n<blockquote>\n<p>The use of Linux containers to deploy applications is called <em>containerization</em>.</p>\n</blockquote>\n<h3 id=\"Images-and-containers\"><a href=\"#Images-and-containers\" class=\"headerlink\" title=\"Images and containers\"></a>Images and containers</h3><blockquote>\n<p>An <strong>image</strong> is an executable package that includes everything needed to run an application–the code, a runtime, libraries, environment variables, and configuration files.</p>\n</blockquote>\n<blockquote>\n<p>A <strong>container</strong> is a runtime instance of an image–what the image becomes in memory when executed (that is, an image with state, or a user process).</p>\n</blockquote>\n<h3 id=\"Container-vs-VM\"><a href=\"#Container-vs-VM\" class=\"headerlink\" title=\"Container vs VM\"></a>Container vs VM</h3><blockquote>\n<p>A <strong>container</strong> runs natively on Linux and shares the kernel of the host machine with other containers. It runs a discrete process, taking no more memory than any other executable, making it lightweight.</p>\n</blockquote>\n<p>看起來 container 是 process level 的。</p>\n<blockquote>\n<p>a <strong>virtual machine</strong> (VM) runs a full-blown “guest” operating system with <em>virtual access</em> to host resources through a hypervisor. In general, VMs provide an environment with more resources than most applications need.</p>\n</blockquote>\n<p>用 Docker 可以把 application 需要的環境跟 code 等等包在 image 裡，以此 image 來開發跟 deploy，解決 application 的 system dependency 問題。因為整個環境都包在 Docker 裡了，application 可以在任何有 Docker 環境的地方執行（從 local 到 cloud 等等）。相較 VM，container 比較 light-weight 而且只有 application 需要的環境。</p>\n<h2 id=\"Part-2-Containers\"><a href=\"#Part-2-Containers\" class=\"headerlink\" title=\"Part 2: Containers\"></a><a href=\"https://docs.docker.com/get-started/part2/\" target=\"_blank\" rel=\"noopener\">Part 2: Containers</a></h2><p>hierarchy 由高到低：</p>\n<ul>\n<li>Stack：define the interactions of all the services</li>\n<li>Services：defines how containers behave in production</li>\n<li>Container：a runtime instance of an image</li>\n</ul>\n<h3 id=\"Dockerfile\"><a href=\"#Dockerfile\" class=\"headerlink\" title=\"Dockerfile\"></a>Dockerfile</h3><blockquote>\n<p><strong><code>Dockerfile</code></strong> defines what goes on in the environment inside your container.</p>\n</blockquote>\n<p>container 的網路跟 disk drive 是 virtualized、跟外界隔開的，所以要做 port mapping 以及指定哪些檔案要 copy 進 container。</p>\n<p>Dockerfile 指令 [<a href=\"https://docs.docker.com/engine/reference/builder/\" target=\"_blank\" rel=\"noopener\">Ref</a>]：</p>\n<ul>\n<li><code>FROM</code> 指定 parent image</li>\n<li><code>WORKDIP</code> 指定 container 內的 working dir</li>\n<li><code>COPY</code> copy 檔案到 container 裡</li>\n<li><code>RUN</code> 執行指令<ul>\n<li><blockquote>\n<p>The RUN instruction will execute any commands in a new layer on top of the current image and commit the results.</p>\n</blockquote>\n</li>\n</ul>\n</li>\n<li><code>EXPOSE</code> 表示 container 會 listen 哪些 port<ul>\n<li>跟 <code>docker run -p</code> 做 port mapping 不同，不會真的 publish port</li>\n<li><blockquote>\n<p>The <code>EXPOSE</code> instruction does not actually publish the port. It functions as a type of documentation between the person who builds the image and the person who runs the container, about which ports are intended to be published.</p>\n</blockquote>\n</li>\n<li>寫不寫 <code>EXPOSE</code> 都可以 publish port，<code>EXPOSE</code> 是讓使用 image 的人知道 container 會 listen 哪個 port，好知道怎麼 publish port。</li>\n</ul>\n</li>\n<li><code>ENV</code> 設定環境變數</li>\n<li><code>CMD</code> container 開起來時要執行的指令</li>\n</ul>\n<h4 id=\"Tips\"><a href=\"#Tips\" class=\"headerlink\" title=\"Tips\"></a>Tips</h4><ul>\n<li>在 container 裡拿 hostname 會拿到 container ID</li>\n</ul>\n<h3 id=\"更多-docker-run\"><a href=\"#更多-docker-run\" class=\"headerlink\" title=\"更多 docker run\"></a>更多 <code>docker run</code></h3><ul>\n<li><code>-p &lt;host port&gt;:&lt;container port&gt;</code> publish port，做 host port 跟 container port 的 mapping。[<a href=\"https://docs.docker.com/engine/reference/run/#expose-incoming-ports\" target=\"_blank\" rel=\"noopener\">Ref</a>]</li>\n<li><code>-d</code> 以 detach mode 執行 container，就是背景執行啦～</li>\n</ul>\n<p><a href=\"http://127.0.0.1:4000/PhpStorm-Docker-in-Win10/#Docker-Command-Line-Usage\" target=\"_blank\" rel=\"noopener\">基本 docker run 使用 Ref</a></p>\n<h3 id=\"Share-image\"><a href=\"#Share-image\" class=\"headerlink\" title=\"Share image\"></a>Share image</h3><blockquote>\n<p>A registry is a collection of repositories, and a repository is a collection of images</p>\n</blockquote>\n<p><code>docker</code> 預設使用的 registry 是 <a href=\"https://hub.docker.com/\" target=\"_blank\" rel=\"noopener\">Docker Hub</a>。</p>\n<p>tag 是用來給 image 版本的方式。</p>\n<ol>\n<li>幫 image 加上 registry 的 repository tag：</li>\n</ol>\n<figure class=\"highlight pf\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ docker <span class=\"keyword\">tag</span> <span class=\"variable\">&lt;image&gt;</span> <span class=\"variable\">&lt;username&gt;</span>/<span class=\"variable\">&lt;repository&gt;</span>:<span class=\"variable\">&lt;tag&gt;</span></span><br></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li>publish image：</li>\n</ol>\n<figure class=\"highlight xml\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ docker push <span class=\"tag\">&lt;<span class=\"name\">username</span>&gt;</span>/<span class=\"tag\">&lt;<span class=\"name\">repository</span>&gt;</span>:<span class=\"tag\">&lt;<span class=\"name\">tag</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<ol start=\"3\">\n<li>pull and run image from remote repository：</li>\n</ol>\n<figure class=\"highlight xml\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ docker run <span class=\"tag\">&lt;<span class=\"name\">username</span>&gt;</span>/<span class=\"tag\">&lt;<span class=\"name\">repository</span>&gt;</span>:<span class=\"tag\">&lt;<span class=\"name\">tag</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>如果 local 不存在 image，Docker 會從 repository pull image 下來再執行。</p>\n","categories":["Get started with Docker"],"tags":["Docker"]},{"title":"Get started with Docker Part 3: Services","url":"/get-started-with-docker/part-3/","content":"<p><a href=\"https://docs.docker.com/get-started/\" target=\"_blank\" rel=\"noopener\">Dodkcer Get Started</a> 隨手記。</p>\n<h2 id=\"Part-3-Services\"><a href=\"#Part-3-Services\" class=\"headerlink\" title=\"Part 3: Services\"></a><a href=\"https://docs.docker.com/get-started/part3/\" target=\"_blank\" rel=\"noopener\">Part 3: Services</a></h2><p>Linux 要先<a href=\"https://docs.docker.com/compose/install/\" target=\"_blank\" rel=\"noopener\">安裝 Docker Compose</a>，Windows 的 Docker Desktop 已經包含 Docker Compose。</p>\n<h3 id=\"Service\"><a href=\"#Service\" class=\"headerlink\" title=\"Service\"></a>Service</h3><p>分散式系統中各 app 都可稱為一個 “service”，儲存資料到 DB、處理 video transcoding 等等都可以是個 “service”。</p>\n<p>Docker 的 services 是一堆在 production 的 containers。一個 service run 一個 image，service 會指定這個 image 要怎麼執行──使用哪些 port、會跑多少 container 等等。只要改變執行的 container instance 數量就能 scale service。透過 <code>docker-compose.yml</code> 定義、執行跟 scale services。</p>\n<h3 id=\"docker-compose-yml\"><a href=\"#docker-compose-yml\" class=\"headerlink\" title=\"docker-compose.yml\"></a><code>docker-compose.yml</code></h3><p><code>docker-compose.yml</code> 定義 container 在 production 該有什麼行為。</p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">version:</span> <span class=\"string\">\"3\"</span></span><br><span class=\"line\"><span class=\"attr\">services:</span></span><br><span class=\"line\">  <span class=\"comment\"># 這個 service 叫作 web</span></span><br><span class=\"line\">  <span class=\"attr\">web:</span></span><br><span class=\"line\">    <span class=\"comment\"># 從 registry pull image</span></span><br><span class=\"line\">    <span class=\"attr\">image:</span> <span class=\"string\">cjwind/get-started:part2</span></span><br><span class=\"line\">    <span class=\"attr\">deploy:</span></span><br><span class=\"line\">      <span class=\"comment\"># run 5 instances</span></span><br><span class=\"line\">      <span class=\"attr\">replicas:</span> <span class=\"number\">5</span></span><br><span class=\"line\">      <span class=\"attr\">resources:</span></span><br><span class=\"line\">        <span class=\"attr\">limits:</span></span><br><span class=\"line\">          <span class=\"comment\"># 一個 instance 最多只能使用一個 single core CPU 10% 的 CPU time</span></span><br><span class=\"line\">          <span class=\"attr\">cpus:</span> <span class=\"string\">\"0.1\"</span></span><br><span class=\"line\">          <span class=\"comment\"># 一個 instance 最多只能用 50MB memory</span></span><br><span class=\"line\">          <span class=\"attr\">memory:</span> <span class=\"string\">50M</span></span><br><span class=\"line\">      <span class=\"attr\">restart_policy:</span></span><br><span class=\"line\">        <span class=\"comment\"># container fail 會立刻 restart</span></span><br><span class=\"line\">        <span class=\"attr\">condition:</span> <span class=\"string\">on-failure</span></span><br><span class=\"line\">    <span class=\"attr\">ports:</span></span><br><span class=\"line\">      <span class=\"comment\"># map host port 4000 到 service web 的 port 80</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">\"4000:80\"</span></span><br><span class=\"line\">    <span class=\"attr\">networks:</span></span><br><span class=\"line\">      <span class=\"comment\"># 讓 containers 透過 webnet 這個 load-balanced network 共用 host 的 port 80</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">webnet</span></span><br><span class=\"line\"><span class=\"attr\">networks:</span></span><br><span class=\"line\">  <span class=\"comment\"># 以預設值（load-balanced overlay network）定義 webnet</span></span><br><span class=\"line\">  <span class=\"attr\">webnet:</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"執行-service\"><a href=\"#執行-service\" class=\"headerlink\" title=\"執行 service\"></a>執行 service</h3><p>跑 service 前要先：</p>\n<figure class=\"highlight elixir\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"variable\">$ </span>docker swarm init</span><br></pre></td></tr></table></figure>\n\n<p>接著執行：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ docker <span class=\"built_in\">stack</span> deploy -c docker-compose.yml &lt;stack_name&gt;</span><br><span class=\"line\">$ docker <span class=\"built_in\">stack</span> deploy -c docker-compose.yml getstartedlab</span><br></pre></td></tr></table></figure>\n\n<p>可以用以下兩個 command 看執行的 service：</p>\n<figure class=\"highlight routeros\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ docker<span class=\"built_in\"> service </span>ls</span><br><span class=\"line\">$ docker stack services &lt;stack_name&gt;</span><br></pre></td></tr></table></figure>\n\n<p>兩個 command 的結果都是：</p>\n<figure class=\"highlight dsconfig\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">ID </span>                 <span class=\"string\">NAME </span>               <span class=\"string\">MODE </span>               <span class=\"string\">REPLICAS </span>           <span class=\"string\">IMAGE </span>                     <span class=\"string\">PORTS</span></span><br><span class=\"line\"><span class=\"string\">ylewu1idwhp0 </span>       <span class=\"string\">getstartedlab_web </span>  <span class=\"string\">replicated </span>         5/5                 <span class=\"string\">cjwind/</span><span class=\"built_in\">get-started:part2</span>   *:<span class=\"string\">4000-</span>&gt;<span class=\"string\">80/</span><span class=\"string\">tcp</span></span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>A single container running in a service is called a <strong>task</strong>.</p>\n</blockquote>\n<p>列出 service 的 task：</p>\n<figure class=\"highlight routeros\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ docker<span class=\"built_in\"> service </span>ps &lt;service_name&gt;</span><br><span class=\"line\">$ docker<span class=\"built_in\"> service </span>ps getstartedlab_web</span><br></pre></td></tr></table></figure>\n\n<p>當然也可以用 <code>docker container ls</code> 看 service 的 running container。</p>\n<p>列出 stack 所有 task：</p>\n<figure class=\"highlight vim\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ docker stack <span class=\"keyword\">ps</span> <span class=\"symbol\">&lt;stack_name&gt;</span></span><br><span class=\"line\">$ docker stack <span class=\"keyword\">ps</span> getstartedlab</span><br></pre></td></tr></table></figure>\n\n<p>service 執行時如果想修改 task 數量，只要修改 <code>docker-compose.yml</code> 的 <code>replicas</code> 設定，再執行一次 <code>docker stack deploy -c docker-compose.yml &lt;stack_name&gt;</code> 就可以了！</p>\n<p>要結束 service，首先關掉 app：</p>\n<figure class=\"highlight stata\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ docker <span class=\"keyword\">stack</span> <span class=\"keyword\">rm</span> getstartedlab</span><br></pre></td></tr></table></figure>\n\n<p>離開 swarm：</p>\n<figure class=\"highlight powershell\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"variable\">$</span> docker swarm leave <span class=\"operator\">-f</span></span><br></pre></td></tr></table></figure>\n","categories":["Get started with Docker"],"tags":["Docker"]},{"title":"Get started with Docker Part 4: Swarms","url":"/get-started-with-docker/part-4/","content":"<p><a href=\"https://docs.docker.com/get-started/\" target=\"_blank\" rel=\"noopener\">Dodkcer Get Started</a> 隨手記。</p>\n<h2 id=\"Part-4-Swarms\"><a href=\"#Part-4-Swarms\" class=\"headerlink\" title=\"Part 4: Swarms\"></a><a href=\"https://docs.docker.com/get-started/part4/\" target=\"_blank\" rel=\"noopener\">Part 4: Swarms</a></h2><p>這個 part 會 deploy app 到 cluster 並執行在多個 machine 上。</p>\n<p>Linux 要先<a href=\"https://docs.docker.com/machine/install-machine/#installing-machine-directly\" target=\"_blank\" rel=\"noopener\">安裝 Docker Machine</a>。</p>\n<h3 id=\"Swarm\"><a href=\"#Swarm\" class=\"headerlink\" title=\"Swarm\"></a>Swarm</h3><blockquote>\n<p>A swarm is a group of machines that are running Docker and joined into a cluster.</p>\n</blockquote>\n<p>swarm 是一群 cluster 中跑著 Docker 的機器。機器加入 cluster 後，在上面執行的 Docker command 由 swarm manager 在 cluster 中執行。</p>\n<blockquote>\n<p>The machines in a swarm can be physical or virtual. After joining a swarm, they are referred to as <strong>nodes</strong>.</p>\n</blockquote>\n<p>一台加入 swarm 的機器稱為 node。</p>\n<p>swarm 中只有 swarm manager 可以執行 command、讓其他機器加入 swarm 當 <strong>worker</strong>。worker 就只是執行，不能叫其他人做事或讓其他機器加入 swarm。swarm manager 可以用多種策略來執行 container。</p>\n<p>平常 Docker 是在 single-host mode 執行，轉成 swarm mode 才能使用 swarm 相關功能。讓一台機器變成 swarm manager 後，Docker 會將 command 執行在它管理的 swarm 上，而非只在目前的機器。</p>\n<h3 id=\"Set-up-swarm\"><a href=\"#Set-up-swarm\" class=\"headerlink\" title=\"Set up swarm\"></a>Set up swarm</h3><p>用 <code>docker swarm init</code> 把一台機器變成 swarm manager，再到其他要當 worker 的機器上執行 <code>docker swarm join</code>。</p>\n<p>接下來用 VM 建個 cluster。</p>\n<p>因為用 VM，Linux 上要先裝 <a href=\"https://www.virtualbox.org/wiki/Downloads\" target=\"_blank\" rel=\"noopener\">VirtualBox</a>。</p>\n<p>使用 <code>docker-machine</code> 產生兩台 VM：</p>\n<figure class=\"highlight livecodeserver\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ docker-machine <span class=\"built_in\">create</span> <span class=\"comment\">--driver virtualbox myvm1</span></span><br><span class=\"line\">$ docker-machine <span class=\"built_in\">create</span> <span class=\"comment\">--driver virtualbox myvm2</span></span><br></pre></td></tr></table></figure>\n\n<p>列出 VM：</p>\n<figure class=\"highlight groovy\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ docker-machine ls</span><br><span class=\"line\">NAME    ACTIVE   DRIVER       STATE     URL                         SWARM   DOCKER     ERRORS</span><br><span class=\"line\">myvm1   -        virtualbox   Running   <span class=\"string\">tcp:</span><span class=\"comment\">//192.168.99.100:2376           v19.03.1</span></span><br><span class=\"line\">myvm2   -        virtualbox   Running   <span class=\"string\">tcp:</span><span class=\"comment\">//192.168.99.101:2376           v19.03.1</span></span><br></pre></td></tr></table></figure>\n\n<p>接下來讓 <code>myvm1</code> 當 swarm manager、<code>myvm2</code> 當 worker。</p>\n<p>透過 <code>docker-machine ssh &lt;vm&gt; &quot;&lt;command&gt;&quot;</code> 可以在 VM 上執行指令：</p>\n<figure class=\"highlight elixir\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"variable\">$ </span>docker-machine ssh myvm1 <span class=\"string\">\"docker swarm init --advertise-addr &lt;myvm1 ip&gt;\"</span></span><br></pre></td></tr></table></figure>\n\n<p>上面指令會得到將 worker 加入此 swarm 的 command，到 <code>myvm2</code> 上執行：</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ docker-machine ssh myvm2 \"docker swarm join --token <span class=\"tag\">&lt;<span class=\"name\">token</span>&gt;</span> <span class=\"tag\">&lt;<span class=\"name\">swarm</span> <span class=\"attr\">manager</span> <span class=\"attr\">ip</span>&gt;</span>:<span class=\"tag\">&lt;<span class=\"name\">port</span>&gt;</span>\"</span><br></pre></td></tr></table></figure>\n\n<p>port 預設是 2377。</p>\n<p>從 <code>myvm1</code> 看 node：</p>\n<figure class=\"highlight elixir\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"variable\">$ </span>docker-machine ssh myvm1 <span class=\"string\">\"docker node ls\"</span></span><br></pre></td></tr></table></figure>\n\n<p>最後 node 離開 swarm：</p>\n<figure class=\"highlight elixir\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"variable\">$ </span>docker-machine ssh myvm2 <span class=\"string\">\"docker swarm leave\"</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"docker-machine-shell\"><a href=\"#docker-machine-shell\" class=\"headerlink\" title=\"docker-machine shell\"></a><code>docker-machine</code> shell</h3><p><code>docker-machine ssh</code> 打起來很長，VM 也無法 access VM host 的檔案。用 <code>docker-machine env &lt;machine&gt;</code> 設定可以讓 shell 直接跟 VM 溝通：</p>\n<figure class=\"highlight routeros\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ docker-machine env myvm1</span><br><span class=\"line\"><span class=\"builtin-name\">export</span> <span class=\"attribute\">DOCKER_TLS_VERIFY</span>=<span class=\"string\">\"1\"</span></span><br><span class=\"line\"><span class=\"builtin-name\">export</span> <span class=\"attribute\">DOCKER_HOST</span>=<span class=\"string\">\"tcp://192.168.99.100:2376\"</span></span><br><span class=\"line\"><span class=\"builtin-name\">export</span> <span class=\"attribute\">DOCKER_CERT_PATH</span>=<span class=\"string\">\"/home/cjw/.docker/machine/machines/myvm1\"</span></span><br><span class=\"line\"><span class=\"builtin-name\">export</span> <span class=\"attribute\">DOCKER_MACHINE_NAME</span>=<span class=\"string\">\"myvm1\"</span></span><br><span class=\"line\"><span class=\"comment\"># Run this command to configure your shell:</span></span><br><span class=\"line\"><span class=\"comment\"># eval $(docker-machine env myvm1)</span></span><br></pre></td></tr></table></figure>\n\n<p>執行 <code>eval $(docker-machine env myvm1)</code>，接著用 <code>docker-machine ls</code> 確認目前 shell active 的 machine（<code>ACTIVE</code> column）：</p>\n<figure class=\"highlight groovy\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ docker-machine ls</span><br><span class=\"line\">NAME    ACTIVE   DRIVER       STATE     URL                         SWARM   DOCKER     ERRORS</span><br><span class=\"line\">myvm1   *        virtualbox   Running   <span class=\"string\">tcp:</span><span class=\"comment\">//192.168.99.100:2376           v19.03.1</span></span><br><span class=\"line\">myvm2   -        virtualbox   Running   <span class=\"string\">tcp:</span><span class=\"comment\">//192.168.99.101:2376           v19.03.1</span></span><br></pre></td></tr></table></figure>\n\n<p>之後執行 docker 指令都是在 <code>myvm1</code> 上執行囉！比較方便而且可以 access 到 VM host 的檔案。要換到別的 machine 就再執行一次 <code>docker-machine env &lt;machine&gt;</code> 把 <code>&lt;machine&gt;</code> 換掉即可。</p>\n<h3 id=\"在-swarm-manager-上-deploy-app\"><a href=\"#在-swarm-manager-上-deploy-app\" class=\"headerlink\" title=\"在 swarm manager 上 deploy app\"></a>在 swarm manager 上 deploy app</h3><p>跟 part 3 一樣，只是 part 3 是把本機直接變成 swarm manager，現在 swarm manager 是 <code>myvm1</code>（把它當作遠端）。</p>\n<p>一樣用 <code>docker stack deploy -c docker-compose.yml &lt;stack_name&gt;</code> 來 deploy app。跟 part 3 不同的是現在 service 會分別開在 <code>myvm1</code> 跟 <code>myvm2</code> 上：</p>\n<figure class=\"highlight dsconfig\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ <span class=\"string\">docker </span><span class=\"string\">service </span><span class=\"string\">ps </span><span class=\"string\">getstartedlab_web</span></span><br><span class=\"line\"><span class=\"string\">ID </span>                 <span class=\"string\">NAME </span>                 <span class=\"string\">IMAGE </span>                     <span class=\"string\">NODE </span>               <span class=\"string\">DESIRED </span><span class=\"string\">STATE </span>      <span class=\"string\">CURRENT </span><span class=\"string\">STATE </span>           <span class=\"string\">ERROR </span>              <span class=\"string\">PORTS</span></span><br><span class=\"line\"><span class=\"string\">hprga9r6s5se </span>       <span class=\"string\">getstartedlab_web.</span>1   <span class=\"string\">cjwind/</span><span class=\"built_in\">get-started:part2</span>   <span class=\"string\">myvm2 </span>              <span class=\"string\">Running </span>            <span class=\"string\">Running </span><span class=\"string\">18 </span><span class=\"string\">minutes </span><span class=\"string\">ago</span></span><br><span class=\"line\"><span class=\"string\">n1bc2c2xosal </span>       <span class=\"string\">getstartedlab_web.</span>2   <span class=\"string\">cjwind/</span><span class=\"built_in\">get-started:part2</span>   <span class=\"string\">myvm1 </span>              <span class=\"string\">Running </span>            <span class=\"string\">Running </span><span class=\"string\">18 </span><span class=\"string\">minutes </span><span class=\"string\">ago</span></span><br><span class=\"line\"><span class=\"string\">rbkv7bctikfq </span>       <span class=\"string\">getstartedlab_web.</span>3   <span class=\"string\">cjwind/</span><span class=\"built_in\">get-started:part2</span>   <span class=\"string\">myvm2 </span>              <span class=\"string\">Running </span>            <span class=\"string\">Running </span><span class=\"string\">18 </span><span class=\"string\">minutes </span><span class=\"string\">ago</span></span><br><span class=\"line\"><span class=\"string\">mr1o60i52f6u </span>       <span class=\"string\">getstartedlab_web.</span>4   <span class=\"string\">cjwind/</span><span class=\"built_in\">get-started:part2</span>   <span class=\"string\">myvm2 </span>              <span class=\"string\">Running </span>            <span class=\"string\">Running </span><span class=\"string\">18 </span><span class=\"string\">minutes </span><span class=\"string\">ago</span></span><br><span class=\"line\"><span class=\"string\">4k7ehhz2nzl3 </span>       <span class=\"string\">getstartedlab_web.</span>5   <span class=\"string\">cjwind/</span><span class=\"built_in\">get-started:part2</span>   <span class=\"string\">myvm1 </span>              <span class=\"string\">Running </span>            <span class=\"string\">Running </span><span class=\"string\">18 </span><span class=\"string\">minutes </span><span class=\"string\">ago</span></span><br></pre></td></tr></table></figure>\n\n<p>到這裡完成了將 app deploy 到 cluster 上，並且 service 有 load-balanced！</p>\n<h3 id=\"access-swarm-上的-app\"><a href=\"#access-swarm-上的-app\" class=\"headerlink\" title=\"access swarm 上的 app\"></a>access swarm 上的 app</h3><p>可以透過 swarm 中任何一個 node 的 IP 去 access app。這是藉由讓 node 在 ingress routing mesh 裡達到。</p>\n<img src=\"https://i.imgur.com/UPiyTkX.png\" width=\"800\">\n\n<p>[<a href=\"https://docs.docker.com/get-started/part4/\" target=\"_blank\" rel=\"noopener\">source</a>]</p>\n<p>在 swarm mode 打開前，swarm node 間的 port 7946 TCP/UDP 以及 port 4789 UDP 要開啟，ingress network 才能運作，所以要注意 app 不能佔用這些 port。</p>\n<h3 id=\"scale-up-in-cluster\"><a href=\"#scale-up-in-cluster\" class=\"headerlink\" title=\"scale up in cluster\"></a>scale up in cluster</h3><p>要讓 service 使用更多 node，只要先用 <code>docker swarm join</code> 增加 node，再 <code>docker stack deploy</code>，service 就能使用增加的 node。</p>\n<h3 id=\"Cleanup\"><a href=\"#Cleanup\" class=\"headerlink\" title=\"Cleanup\"></a>Cleanup</h3><p>清掉 <code>docker-machine</code> 的環境變數：</p>\n<figure class=\"highlight reasonml\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ eval <span class=\"constructor\">$(<span class=\"params\">docker</span>-<span class=\"params\">machine</span> <span class=\"params\">env</span> -<span class=\"params\">u</span>)</span></span><br></pre></td></tr></table></figure>\n\n<p>結束 stack 的所有 service、刪掉 stack：</p>\n<figure class=\"highlight stata\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ docker <span class=\"keyword\">stack</span> <span class=\"keyword\">rm</span> &lt;stack_name&gt;</span><br></pre></td></tr></table></figure>\n","categories":["Get started with Docker"],"tags":["Docker"]},{"title":"Get started with Docker Part 5 & 6","url":"/get-started-with-docker/part-5-6/","content":"<p><a href=\"https://docs.docker.com/get-started/\" target=\"_blank\" rel=\"noopener\">Dodkcer Get Started</a> 隨手記。</p>\n<h2 id=\"Part-5-Stacks\"><a href=\"#Part-5-Stacks\" class=\"headerlink\" title=\"Part 5: Stacks\"></a><a href=\"https://docs.docker.com/get-started/part5/\" target=\"_blank\" rel=\"noopener\">Part 5: Stacks</a></h2><blockquote>\n<p>A stack is a group of interrelated services that share dependencies, and can be orchestrated and scaled together. A single stack is capable of defining and coordinating the functionality of an entire application (though very complex applications may want to use multiple stacks).</p>\n</blockquote>\n<p>stack 定義了一堆互相有關的 service，把 service 放在一個 stack 裡就可以一起操作、scale 等等。可以用一個 stack 來定義一個 application 的功能，比較複雜的 application 可能有多個 stack。</p>\n<p>也就是可以把 application 拆分成多個 service 來運作，這些 service 可以只跑在一台機器上，也可以在 swarm 中跑在不同機器上。原本要做到這件事，要嘛要在一台機器上裝各種 server，要分散就得在多台機器上裝各自需要的 server，再不然就得裝 VM 起來做這些事，而且也沒有個統一的地方記錄各 service 的版本等等資訊（工人智慧…）。Docker 把 setup 開發及 production 環境跟 scale up 變得簡單很多。</p>\n<h3 id=\"More-docker-compose-yml\"><a href=\"#More-docker-compose-yml\" class=\"headerlink\" title=\"More docker-compose.yml\"></a>More <code>docker-compose.yml</code></h3><p><a href=\"/Get-started-with-Docker-Part-3/\">part 3</a> 寫的 <code>docker-compose.yml</code> 是定義只有一個 service 的 stack。下面是有兩個 service 分別為 <code>visualizer</code> 跟 <code>redis</code> 的 stack：</p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">version:</span> <span class=\"string\">\"3\"</span>    <span class=\"comment\"># compose file format version</span></span><br><span class=\"line\"><span class=\"attr\">services:</span></span><br><span class=\"line\">  <span class=\"attr\">visualizer:</span></span><br><span class=\"line\">    <span class=\"attr\">image:</span> <span class=\"string\">dockersamples/visualizer:stable</span></span><br><span class=\"line\">    <span class=\"attr\">ports:</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">\"8080:8080\"</span></span><br><span class=\"line\">    <span class=\"comment\"># mapping host 的 file 到 container 裡</span></span><br><span class=\"line\">    <span class=\"attr\">volumes:</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">\"/var/run/docker.sock:/var/run/docker.sock\"</span></span><br><span class=\"line\">    <span class=\"attr\">deploy:</span></span><br><span class=\"line\">      <span class=\"comment\"># 指定 service 要 run 在哪個 node</span></span><br><span class=\"line\">      <span class=\"attr\">placement:</span></span><br><span class=\"line\">        <span class=\"attr\">constraints:</span> <span class=\"string\">[node.role</span> <span class=\"string\">==</span> <span class=\"string\">manager]</span>    <span class=\"comment\"># 只能 run 在 swarm manager</span></span><br><span class=\"line\">    <span class=\"attr\">networks:</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">webnet</span></span><br><span class=\"line\">  <span class=\"attr\">redis:</span></span><br><span class=\"line\">    <span class=\"attr\">image:</span> <span class=\"string\">redis</span></span><br><span class=\"line\">    <span class=\"attr\">ports:</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">\"6379:6379\"</span></span><br><span class=\"line\">    <span class=\"attr\">volumes:</span></span><br><span class=\"line\">      <span class=\"comment\"># mapping host 的 /home/docker/data 到 container 的 /data</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">\"/home/docker/data:/data\"</span></span><br><span class=\"line\">    <span class=\"attr\">deploy:</span></span><br><span class=\"line\">      <span class=\"attr\">placement:</span></span><br><span class=\"line\">        <span class=\"attr\">constraints:</span> <span class=\"string\">[node.role</span> <span class=\"string\">==</span> <span class=\"string\">manager]</span></span><br><span class=\"line\">    <span class=\"attr\">command:</span> <span class=\"string\">redis-server</span> <span class=\"string\">--appendonly</span> <span class=\"literal\">yes</span></span><br><span class=\"line\">    <span class=\"attr\">networks:</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">webnet</span></span><br><span class=\"line\"><span class=\"attr\">networks:</span></span><br><span class=\"line\">  <span class=\"attr\">webnet:</span></span><br></pre></td></tr></table></figure>\n\n<p>如果沒有做 volume mapping，container 的 disk 的 file 在 container 重開後會不見。</p>\n<p>其他 compose file 設定可參考：<a href=\"https://docs.docker.com/compose/compose-file/\" target=\"_blank\" rel=\"noopener\">Compose file reference</a>。</p>\n<p>修改 <code>docker-compose.yml</code> 後重新 deploy 只需 <code>docker stack deploy -c docker-compose.yml &lt;stack_name&gt;</code>。</p>\n<p>要結束整個 stack 的 service 則 <code>docker stack rm &lt;stack_name&gt;</code>。</p>\n<h2 id=\"Part-6-Deploy-your-app\"><a href=\"#Part-6-Deploy-your-app\" class=\"headerlink\" title=\"Part 6: Deploy your app\"></a><a href=\"https://docs.docker.com/get-started/part6/\" target=\"_blank\" rel=\"noopener\">Part 6: Deploy your app</a></h2><p>這篇是看你要用 Docker Enterprise 還是自己裝 <a href=\"https://docs.docker.com/install/\" target=\"_blank\" rel=\"noopener\">Docker Engine - Community</a> 進行開發及 deploy production。</p>\n<p>開發環境跟 production 環境的 Docker 操作都一樣（只是執行的地方不一樣。</p>\n","categories":["Get started with Docker"],"tags":["Docker"]},{"title":"Day 3 進入 32 bit 模式並導入 C 語言","url":"/30dayos/day3/","content":"<h2 id=\"製作真正的-IPL\"><a href=\"#製作真正的-IPL\" class=\"headerlink\" title=\"製作真正的 IPL\"></a>製作真正的 IPL</h2><p>IPL 是 Initial Program Loader，現在要開始做真正的 IPL──把磁碟上的東西 load 到 memory 裡！</p>\n<p>這部分書上是一點一點的增加 assembly code，從讀一個 sector 到讀多個 cylinder 的所有 sector。</p>\n<h3 id=\"floppy-disk-的-cylinder、sector\"><a href=\"#floppy-disk-的-cylinder、sector\" class=\"headerlink\" title=\"floppy disk 的 cylinder、sector\"></a>floppy disk 的 cylinder、sector</h3><p>floppy disk 的磁片由外而內的一個個同心圓稱為 cylinder（柱面），共有 80 個 cylinder。由圓心往外切（像切蛋糕），cylinder 切成一格格的稱為 sector，一個 cylinder 有 18 個 sector。磁片正反面都可以存放資料，因此磁頭有正反面，以 0 跟 1 表示。</p>\n<p>一張磁片共有 <code>2 * 80 * 18</code> 個 sector，每個 sector 是 512 byte，所以一張磁片的容量是 <code>2 * 80 * 18 * 512 = 1474560 byte = 1440 KB</code>。<em>就是古早時代的 3.5 磁片…現在應該有些人都不知道那是什麼了…</em></p>\n<p>指定某個 sector 需要指定磁頭、cylinder 編號以及 sector 編號。</p>\n<p><img src=\"/images/30dayos/floppy_disk.jpg\" alt=\"floppy disk\"></p>\n<h3 id=\"指令\"><a href=\"#指令\" class=\"headerlink\" title=\"指令\"></a>指令</h3><ul>\n<li>JC：jump if carry<ul>\n<li>如果 carry flag 是 1 就 jump</li>\n<li>carry flag 是個只能存一個 bit 的 register，通常用於表示計算有無進位，也會被一些 BIOS function 用來表示回傳值。</li>\n</ul>\n</li>\n<li>JNC：jump if not carry<ul>\n<li>JC 的相反囉</li>\n</ul>\n</li>\n<li>JAE：jump if above or equal<ul>\n<li>大於等於時 jump</li>\n</ul>\n</li>\n<li>JBE：jump if below or equal</li>\n<li>JB：jump if below</li>\n<li>EQU<ul>\n<li>相當於 C 的 <code>#define</code> ，可以用來宣告 const</li>\n<li><code>CYLS EQU 10</code> 就是 <code>CYLS = 10</code> 的意思</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"Segment-Register\"><a href=\"#Segment-Register\" class=\"headerlink\" title=\"Segment Register\"></a>Segment Register</h3><p>一個 16 bit register 的值的範圍是 0 ~ 65535，只能表示 64 KB 的 memory address。在還沒有 32 bit register 的時代用 segment register 來表示更多 memory address。</p>\n<p>使用 segment register 時，以 <code>ES:BX</code> 表示 <code>ES * 16 + BX</code> 的 memory address，在指令裡寫成 <code>MOV AL, [ES:BX]</code>。實際上指定 memory address 時都需要指定 segment register。省略 segment register 會預設使用 <code>DS</code> register，所以寫 <code>MOV CX, [1234]</code> 實際上是 <code>MOV CS, [DS:1234]</code> 。</p>\n<p>因為 <code>ES:BX</code> 表示 memory address <code>ES * 16 + BX</code>，如果想將 address 往前移動 512 byte，可以在 ES 加上 <code>512 / 16 = 32 = 0x20</code>。</p>\n<h3 id=\"IPL-主要-read-disk-的部分\"><a href=\"#IPL-主要-read-disk-的部分\" class=\"headerlink\" title=\"IPL 主要 read disk 的部分\"></a>IPL 主要 read disk 的部分</h3><figure class=\"highlight x86asm\"><table><tr><td class=\"code\"><pre><span class=\"line\">CYLS\t<span class=\"built_in\">EQU</span>\t\t<span class=\"number\">10</span>\t\t\t\t<span class=\"comment\">; 宣告常數 CYLS = 10</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">; (中略)</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">; read disk</span></span><br><span class=\"line\"><span class=\"keyword\">MOV</span>\t\t<span class=\"built_in\">AX</span>,<span class=\"number\">0x0820</span></span><br><span class=\"line\">        <span class=\"keyword\">MOV</span>\t\t<span class=\"built_in\">ES</span>,<span class=\"built_in\">AX</span></span><br><span class=\"line\">        <span class=\"keyword\">MOV</span>\t\t<span class=\"number\">CH</span>,<span class=\"number\">0</span>\t\t\t<span class=\"comment\">; cylinder 0</span></span><br><span class=\"line\">        <span class=\"keyword\">MOV</span>\t\t<span class=\"number\">DH</span>,<span class=\"number\">0</span>\t\t\t<span class=\"comment\">; 磁頭 0</span></span><br><span class=\"line\">        <span class=\"comment\">; sector 2, 因為 floppy disk 第一個 sector 是 boot sector, 所以從第二個 sector 開始 read</span></span><br><span class=\"line\">        <span class=\"keyword\">MOV</span>\t\t<span class=\"built_in\">CL</span>,<span class=\"number\">2</span></span><br><span class=\"line\"><span class=\"symbol\">readloop:</span></span><br><span class=\"line\">        <span class=\"keyword\">MOV</span>\t\t<span class=\"built_in\">SI</span>,<span class=\"number\">0</span>\t\t\t<span class=\"comment\">; 紀錄失敗次數的 register</span></span><br><span class=\"line\"><span class=\"symbol\">retry:</span></span><br><span class=\"line\">        <span class=\"keyword\">MOV</span>\t\t<span class=\"number\">AH</span>,<span class=\"number\">0x02</span>\t\t\t<span class=\"comment\">; AH=0x02 : read floppy disk</span></span><br><span class=\"line\">        <span class=\"keyword\">MOV</span>\t\t<span class=\"built_in\">AL</span>,<span class=\"number\">1</span>\t\t\t<span class=\"comment\">; 1 sector</span></span><br><span class=\"line\">        <span class=\"keyword\">MOV</span>\t\t<span class=\"built_in\">BX</span>,<span class=\"number\">0</span></span><br><span class=\"line\">        <span class=\"keyword\">MOV</span>\t\t<span class=\"built_in\">DL</span>,<span class=\"number\">0x00</span>\t\t\t<span class=\"comment\">; A 驅動器</span></span><br><span class=\"line\">        <span class=\"keyword\">INT</span>\t\t<span class=\"number\">0x13</span>\t\t\t<span class=\"comment\">; call BIOS</span></span><br><span class=\"line\">        <span class=\"keyword\">JNC</span>\t\tnext\t\t\t<span class=\"comment\">; 沒出錯就跳到 next</span></span><br><span class=\"line\">        <span class=\"keyword\">ADD</span>\t\t<span class=\"built_in\">SI</span>,<span class=\"number\">1</span>\t\t\t<span class=\"comment\">; SI + 1 (這段開始在做 retry)</span></span><br><span class=\"line\">        <span class=\"keyword\">CMP</span>\t\t<span class=\"built_in\">SI</span>,<span class=\"number\">5</span>\t\t\t<span class=\"comment\">; SI 跟 5 比較</span></span><br><span class=\"line\">        <span class=\"keyword\">JAE</span>\t\terror\t\t\t<span class=\"comment\">; SI &gt;= 5 就跳到 error</span></span><br><span class=\"line\">        <span class=\"keyword\">MOV</span>\t\t<span class=\"number\">AH</span>,<span class=\"number\">0x00</span></span><br><span class=\"line\">        <span class=\"keyword\">MOV</span>\t\t<span class=\"built_in\">DL</span>,<span class=\"number\">0x00</span>\t\t\t<span class=\"comment\">; A 驅動器</span></span><br><span class=\"line\">        <span class=\"keyword\">INT</span>\t\t<span class=\"number\">0x13</span>\t\t\t<span class=\"comment\">; 重置驅動器</span></span><br><span class=\"line\">        <span class=\"keyword\">JMP</span>\t\tretry\t\t\t<span class=\"comment\">; 回到 retry 再嘗試讀一次</span></span><br><span class=\"line\"><span class=\"symbol\">next:</span></span><br><span class=\"line\">        <span class=\"keyword\">MOV</span>\t\t<span class=\"built_in\">AX</span>,<span class=\"built_in\">ES</span>\t\t\t<span class=\"comment\">; 將 memory address 往後移 0x200 (512)</span></span><br><span class=\"line\">        <span class=\"keyword\">ADD</span>\t\t<span class=\"built_in\">AX</span>,<span class=\"number\">0x0020</span></span><br><span class=\"line\">        <span class=\"keyword\">MOV</span>\t\t<span class=\"built_in\">ES</span>,<span class=\"built_in\">AX</span>\t\t\t<span class=\"comment\">; 因為沒有 ADD ES,0x020 的指令所以用比較迂迴的方式做</span></span><br><span class=\"line\">        <span class=\"keyword\">ADD</span>\t\t<span class=\"built_in\">CL</span>,<span class=\"number\">1</span>\t\t\t<span class=\"comment\">; CL + 1 (sector)</span></span><br><span class=\"line\">        <span class=\"keyword\">CMP</span>\t\t<span class=\"built_in\">CL</span>,<span class=\"number\">18</span>\t\t\t<span class=\"comment\">; CL 跟 18 比較</span></span><br><span class=\"line\">        <span class=\"keyword\">JBE</span>\t\treadloop\t\t<span class=\"comment\">; CL &lt;= 18 則跳到 readloop (這邊就是 read 到 sector 18 的 loop)</span></span><br><span class=\"line\">        <span class=\"keyword\">MOV</span>\t\t<span class=\"built_in\">CL</span>,<span class=\"number\">1</span>\t\t\t<span class=\"comment\">; CL = 1</span></span><br><span class=\"line\">        <span class=\"keyword\">ADD</span>\t\t<span class=\"number\">DH</span>,<span class=\"number\">1</span>\t\t\t<span class=\"comment\">; DH + 1</span></span><br><span class=\"line\">        <span class=\"keyword\">CMP</span>\t\t<span class=\"number\">DH</span>,<span class=\"number\">2</span></span><br><span class=\"line\">        <span class=\"keyword\">JB</span>\t\treadloop\t\t<span class=\"comment\">; DH &lt; 2 則跳到 readloop (這邊是 read 另一個磁頭的 loop)</span></span><br><span class=\"line\">        <span class=\"keyword\">MOV</span>\t\t<span class=\"number\">DH</span>,<span class=\"number\">0</span>\t\t\t<span class=\"comment\">; 回到磁頭 0</span></span><br><span class=\"line\">        <span class=\"keyword\">ADD</span>\t\t<span class=\"number\">CH</span>,<span class=\"number\">1</span>\t\t\t<span class=\"comment\">; CH + 1 (cylinder + 1)</span></span><br><span class=\"line\">        <span class=\"keyword\">CMP</span>\t\t<span class=\"number\">CH</span>,CYLS</span><br><span class=\"line\">        <span class=\"keyword\">JB</span>\t\treadloop\t\t<span class=\"comment\">; CH &lt; CYLS 則跳到 readloop (這邊是 read cylinder 的 loop, CYLS 是常數)</span></span><br></pre></td></tr></table></figure>\n\n<p>到這裡，我們就有一個將 floppy disk 資料讀到 memory 的 IPL 了！</p>\n<h2 id=\"最簡單的-OS\"><a href=\"#最簡單的-OS\" class=\"headerlink\" title=\"最簡單的 OS\"></a>最簡單的 OS</h2><p>IPL 寫好，當然要來寫 OS 啦！</p>\n<p>在這個部分，無論是切換 video mode、從 BIOS 取得各種資料、把一些資訊保存在 memory 中等等，都是由組語寫成的 <code>haribote.nas</code> —— 我們最簡單的 OS 程式，像這樣一個什麼事也沒幹的 OS：</p>\n<figure class=\"highlight avrasm\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"symbol\">fin:</span></span><br><span class=\"line\">        HLT</span><br><span class=\"line\">        <span class=\"keyword\">JMP</span>\t\tfin</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"從-boot-sector-執行-OS\"><a href=\"#從-boot-sector-執行-OS\" class=\"headerlink\" title=\"從 boot sector 執行 OS\"></a>從 boot sector 執行 OS</h3><p>首先透過 image file 了解在 floppy disk 上檔案是怎麼被放置的（放在哪些位置）。image file 可以想成是把 disk 上的 data「原封不動」的一個個 bit 存下來而成的一個檔案。</p>\n<p>利用 image file 我們知道在 floppy disk 的一個檔案，檔名會寫在 <code>0x002600</code> 後（這裡的 address 是 disk 上的 address），檔案內容會在 <code>0x004200</code> 後。</p>\n<p>所以我們把 OS 內容寫到名為 <code>haribote.sys</code> 的檔案中並存到 floppy disk，它的內容會在 <code>0x004200</code> 之後，所以我們只要從 boot sector 去執行這個位置上的東西就行了！</p>\n<p>要怎麼去執行 disk 上 <code>0x004200</code> 後的程式呢？現在的程式是從 boot sector 開始，把 floppy disk 上的東西 load 到 memory address <code>0x8000</code> ，所以 disk 上 <code>0x4200</code> 的內容會位於 memory address <code>0x8000 + 0x4200 = 0xc200</code> 。</p>\n<p>所以我們在 OS 程式加上 <code>ORG 0xc200</code> ，並且在 IPL 的最後加上 <code>JMP 0xc200</code> ，讓 IPL 完成工作後跳到 OS 程式所在位置開始執行！</p>\n<h3 id=\"切換顯示模式（video-mode）\"><a href=\"#切換顯示模式（video-mode）\" class=\"headerlink\" title=\"切換顯示模式（video mode）\"></a>切換顯示模式（video mode）</h3><p>切換 video mode 的 BIOS 可以參考 <a href=\"http://oswiki.osask.jp/?(AT)BIOS\" target=\"_blank\" rel=\"noopener\">BIOS 網頁</a>知道要用哪些 register（雖然是日文的）。</p>\n<p>VRAM 是 video RAM，用來顯示畫面的 memory。它的每個 address 都對應畫面上的像素，在這塊 memory 裡填值就能在畫面上畫東西～VRAM 在 memory 中有好幾塊，分別給不同 video mode 使用。</p>\n<h3 id=\"進入-32-bit-mode-前的準備\"><a href=\"#進入-32-bit-mode-前的準備\" class=\"headerlink\" title=\"進入 32 bit mode 前的準備\"></a>進入 32 bit mode 前的準備</h3><p>32 bit mode 是 CPU 的 mode。不同 mode 有不同 instruction，所以 16 bit 跟 32 bit 的程式是不相容的。register 使用上的方便程度也不同（例如在 16 bit mode 可以方便使用 register AX，但 EAX 不好用）。另外 CPU 的保護功能（識別出可疑的 machine code 並屏蔽它）要在 32 bit mode 才能用。</p>\n<p>不過 32 bit mode 不能使用 BIOS 功能，因為 BIOS 是用 16 bit mode 的 instruction 寫的。如果有什麼是想用 BIOS 做，要一開始先做。</p>\n<p><em>後來出了想取代 BIOS 的 UEFI，又是另一回事了…</em></p>\n<h2 id=\"導入-C-語言\"><a href=\"#導入-C-語言\" class=\"headerlink\" title=\"導入 C 語言\"></a>導入 C 語言</h2><p>終於開始要用 C 語言啦～在這之前得在 <code>haribote.nas</code> 加入一些組語 code，好讓我們能 call C 程式，不過作者在這裡還不想解釋那段，所以也先略過。</p>\n<p>現在 OS 開始有組語跟 C 語言的部分，先將組語部分的 <code>haribote.nas</code> rename 成 <code>asmhead.has</code>。再加入一個很簡單的 C 程式叫 <code>bootpack.c</code>：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 程式是從這個 function 開始的，function name 不能更改，應該跟處理 C 語言的組語有關</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">HariMain</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">fin:</span><br><span class=\"line\">    <span class=\"keyword\">goto</span> fin;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>如何將它變成可以在我們自製 OS 上執行的 machine code？</p>\n<ol>\n<li>使用 <code>cc1.exe</code> 從 <code>bootpack.c</code> 產生 <code>bootpack.gas</code><br> <code>cc1.exe</code> 是作者用 gcc 改造而來的 C compiler。gcc 是以 gas 組語為基礎，它 output 的是 gas 的 source code。<a href=\"https://en.wikipedia.org/wiki/GNU_Assembler\" target=\"_blank\" rel=\"noopener\">gas</a> 是 GNU 的 assembler。</li>\n<li>用 <code>gas2nask.exe</code> 將 <code>bootpack.gas</code> 轉成 <code>bootpack.nas</code><br> 作者使用 nask 當 assembler，所以得把 gas 組語轉成 nask 組語。</li>\n<li>用 <code>nask.exe</code> 將 <code>bootpack.nas</code> 組譯為 <code>bootpack.obj</code></li>\n<li>用 <code>obi2bim.exe</code> 從 <code>bootpack.obj</code> 產生 <code>bootpack.bim</code><ul>\n<li><code>obi2bim.exe</code> 是 linker，這邊是將 object file <code>bootpack.obj</code> link 成完整的 machine code。</li>\n<li>雖然現在只有一個 object file，不是多個 object file 要 link 在一起。但即使只有一個 object file 也要幫它加些資訊才能成為完整可執行的 machine code，所以需要 link。</li>\n<li><code>bim</code> 是作者設計的一種格式，是種 binary image file。</li>\n</ul>\n</li>\n<li>最後用 <code>bim2hrb.exe</code> 從 <code>bootpack.bim</code> 產生 <code>bootpack.hrb</code><br> 這是將 <code>bootpack.bim</code> 依照我們自製 OS 的需要做點加工，成為最後的 <code>bootpack.hrb</code></li>\n</ol>\n<p>到這裡終於把 C 語言程式編譯成可以在自製 OS 上執行的 machine code，最後用 <code>copy</code> 指令將 <code>asmhead.nas</code> 組譯出來的 <code>asmhead.bin</code> 跟 <code>bootpack.hrb</code> 結合起來，成為最終的 <code>haribote.sys</code> 。（原本 <code>haribote.sys</code> 是直接由 <code>haribote.nas</code> 組譯而來，現在有了 C 語言的部分，要把兩個部分結合起來才是完整的 <code>haribote.sys</code> ）</p>\n<h3 id=\"Makefile\"><a href=\"#Makefile\" class=\"headerlink\" title=\"Makefile\"></a>Makefile</h3><figure class=\"highlight makefile\"><table><tr><td class=\"code\"><pre><span class=\"line\">TOOLPATH = ../z_tools/</span><br><span class=\"line\">INCPATH  = ../z_tools/haribote/</span><br><span class=\"line\"></span><br><span class=\"line\">MAKE     = <span class=\"variable\">$(TOOLPATH)</span>make.exe -r</span><br><span class=\"line\">NASK     = <span class=\"variable\">$(TOOLPATH)</span>nask.exe</span><br><span class=\"line\">CC1      = <span class=\"variable\">$(TOOLPATH)</span>cc1.exe -I<span class=\"variable\">$(INCPATH)</span> -Os -Wall -quiet</span><br><span class=\"line\">GAS2NASK = <span class=\"variable\">$(TOOLPATH)</span>gas2nask.exe -a</span><br><span class=\"line\">OBJ2BIM  = <span class=\"variable\">$(TOOLPATH)</span>obj2bim.exe</span><br><span class=\"line\">BIM2HRB  = <span class=\"variable\">$(TOOLPATH)</span>bim2hrb.exe</span><br><span class=\"line\">RULEFILE = <span class=\"variable\">$(TOOLPATH)</span>haribote/haribote.rul</span><br><span class=\"line\">EDIMG    = <span class=\"variable\">$(TOOLPATH)</span>edimg.exe</span><br><span class=\"line\">IMGTOL   = <span class=\"variable\">$(TOOLPATH)</span>imgtol.com</span><br><span class=\"line\">COPY     = copy</span><br><span class=\"line\">DEL      = del</span><br><span class=\"line\"></span><br><span class=\"line\">default :</span><br><span class=\"line\">    <span class=\"variable\">$(MAKE)</span> img</span><br><span class=\"line\"></span><br><span class=\"line\">; 組譯 IPL</span><br><span class=\"line\">ipl10.bin : ipl10.nas Makefile</span><br><span class=\"line\">    <span class=\"variable\">$(NASK)</span> ipl10.nas ipl10.bin ipl10.lst</span><br><span class=\"line\"></span><br><span class=\"line\">; 組譯 OS 前面的組語部分</span><br><span class=\"line\">asmhead.bin : asmhead.nas Makefile</span><br><span class=\"line\">    <span class=\"variable\">$(NASK)</span> asmhead.nas asmhead.bin asmhead.lst</span><br><span class=\"line\"></span><br><span class=\"line\">; 使用 cc1 compile bootpack.c 得到 gas 組語</span><br><span class=\"line\">bootpack.gas : bootpack.c Makefile</span><br><span class=\"line\">    <span class=\"variable\">$(CC1)</span> -o bootpack.gas bootpack.c</span><br><span class=\"line\"></span><br><span class=\"line\">; 將 gas 組語轉成 nask 組語</span><br><span class=\"line\">bootpack.nas : bootpack.gas Makefile</span><br><span class=\"line\">    <span class=\"variable\">$(GAS2NASK)</span> bootpack.gas bootpack.nas</span><br><span class=\"line\"></span><br><span class=\"line\">; nask 組譯</span><br><span class=\"line\">bootpack.obj : bootpack.nas Makefile</span><br><span class=\"line\">    <span class=\"variable\">$(NASK)</span> bootpack.nas bootpack.obj bootpack.lst</span><br><span class=\"line\"></span><br><span class=\"line\">; linking</span><br><span class=\"line\">bootpack.bim : bootpack.obj Makefile</span><br><span class=\"line\">    <span class=\"variable\">$(OBJ2BIM)</span> @<span class=\"variable\">$(RULEFILE)</span> out:bootpack.bim stack:3136k map:bootpack.map \\</span><br><span class=\"line\">        bootpack.obj</span><br><span class=\"line\"><span class=\"comment\"># 3MB+64KB=3136KB</span></span><br><span class=\"line\"></span><br><span class=\"line\">; 幫 bootpack.bim 做點加工好能在我們的 OS 上執行</span><br><span class=\"line\">bootpack.hrb : bootpack.bim Makefile</span><br><span class=\"line\">    <span class=\"variable\">$(BIM2HRB)</span> bootpack.bim bootpack.hrb 0</span><br><span class=\"line\"></span><br><span class=\"line\">; 將兩個部份的 machine code 結合在一起</span><br><span class=\"line\">haribote.sys : asmhead.bin bootpack.hrb Makefile</span><br><span class=\"line\">    copy /B asmhead.bin+bootpack.hrb haribote.sys</span><br><span class=\"line\"></span><br><span class=\"line\">; 將 IPL 跟 OS 的 machine code 做成 floopy disk 的 image file</span><br><span class=\"line\">haribote.img : ipl10.bin haribote.sys Makefile</span><br><span class=\"line\">    <span class=\"variable\">$(EDIMG)</span>   imgin:../z_tools/fdimg0at.tek \\</span><br><span class=\"line\">        wbinimg src:ipl10.bin len:512 from:0 to:0 \\</span><br><span class=\"line\">        copy from:haribote.sys to:@: \\</span><br><span class=\"line\">        imgout:haribote.img</span><br><span class=\"line\"></span><br><span class=\"line\">img :</span><br><span class=\"line\">    <span class=\"variable\">$(MAKE)</span> haribote.img</span><br><span class=\"line\"></span><br><span class=\"line\">run :</span><br><span class=\"line\">    <span class=\"variable\">$(MAKE)</span> img</span><br><span class=\"line\">    <span class=\"variable\">$(COPY)</span> haribote.img ..\\z_tools\\qemu\\fdimage0.bin</span><br><span class=\"line\">    <span class=\"variable\">$(MAKE)</span> -C ../z_tools/qemu</span><br><span class=\"line\"></span><br><span class=\"line\">install :</span><br><span class=\"line\">    <span class=\"variable\">$(MAKE)</span> img</span><br><span class=\"line\">    <span class=\"variable\">$(IMGTOL)</span> w a: haribote.img</span><br><span class=\"line\"></span><br><span class=\"line\">clean :</span><br><span class=\"line\">    -<span class=\"variable\">$(DEL)</span> *.bin</span><br><span class=\"line\">    -<span class=\"variable\">$(DEL)</span> *.lst</span><br><span class=\"line\">    -<span class=\"variable\">$(DEL)</span> *.gas</span><br><span class=\"line\">    -<span class=\"variable\">$(DEL)</span> *.obj</span><br><span class=\"line\">    -<span class=\"variable\">$(DEL)</span> bootpack.nas</span><br><span class=\"line\">    -<span class=\"variable\">$(DEL)</span> bootpack.map</span><br><span class=\"line\">    -<span class=\"variable\">$(DEL)</span> bootpack.bim</span><br><span class=\"line\">    -<span class=\"variable\">$(DEL)</span> bootpack.hrb</span><br><span class=\"line\">    -<span class=\"variable\">$(DEL)</span> haribote.sys</span><br><span class=\"line\"></span><br><span class=\"line\">src_only :</span><br><span class=\"line\">    <span class=\"variable\">$(MAKE)</span> clean</span><br><span class=\"line\">    -<span class=\"variable\">$(DEL)</span> haribote.img</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"在-C-語言程式-call-組語程式\"><a href=\"#在-C-語言程式-call-組語程式\" class=\"headerlink\" title=\"在 C 語言程式 call 組語程式\"></a>在 C 語言程式 call 組語程式</h2><p>如果想在 C 語言寫的程式 call 組語的程式該怎麼做呢？寫了個組語程式 <code>naskfunc.nas</code> 如下：</p>\n<figure class=\"highlight pgsql\"><table><tr><td class=\"code\"><pre><span class=\"line\">; naskfunc</span><br><span class=\"line\">; TAB=<span class=\"number\">4</span></span><br><span class=\"line\"></span><br><span class=\"line\">[<span class=\"keyword\">FORMAT</span> \"WCOFF\"]\t\t\t; 製作 <span class=\"keyword\">object</span> file 的模式</span><br><span class=\"line\">[BITS <span class=\"number\">32</span>]\t\t\t\t; 製作 <span class=\"number\">32</span> <span class=\"type\">bit</span> mode 用的 machine code</span><br><span class=\"line\"></span><br><span class=\"line\">; 製作 <span class=\"keyword\">object</span> file 的資訊</span><br><span class=\"line\"></span><br><span class=\"line\">[FILE \"naskfunc.nas\"]\t\t\t; source code file <span class=\"type\">name</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">GLOBAL</span>\t_io_hlt\t\t\t; 程式中包含的 <span class=\"keyword\">function</span> <span class=\"type\">name</span></span><br><span class=\"line\"></span><br><span class=\"line\">; 以下是實際 <span class=\"keyword\">function</span></span><br><span class=\"line\"></span><br><span class=\"line\">[SECTION .text]</span><br><span class=\"line\"></span><br><span class=\"line\">_io_hlt:\t; <span class=\"type\">void</span> io_hlt(<span class=\"type\">void</span>);</span><br><span class=\"line\">    HLT</span><br><span class=\"line\">    RET\t; 相當於 C 語言的 <span class=\"keyword\">return</span></span><br></pre></td></tr></table></figure>\n\n<p>這段組語包含一個 <code>_io_hlt</code> function。</p>\n<p>在 nask object file 模式下，要設定 file name 資訊並且寫清楚程式的 function name。function name 要在前面加上 <code>_</code> ，不然不能跟 C 語言 function link。需要 link 的 function name 都要用 <code>GLOBAL</code> 指令宣告。</p>\n<p>來看看在 C 語言裡要怎麼使用 <code>_io_hlt</code> function：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 告訴 C compiler，這個 function 在別的 file 裡</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">io_hlt</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">HariMain</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">fin:</span><br><span class=\"line\">    io_hlt();</span><br><span class=\"line\">    <span class=\"keyword\">goto</span> fin;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>這邊的 Makefile 跟前面的差異只有增加了 <code>naskfunc.obj</code> 的 target 跟修改 <code>bootpack.bim</code> target 的 link 內容：</p>\n<figure class=\"highlight makefile\"><table><tr><td class=\"code\"><pre><span class=\"line\">naskfunc.obj : naskfunc.nas Makefile</span><br><span class=\"line\">    <span class=\"variable\">$(NASK)</span> naskfunc.nas naskfunc.obj naskfunc.lst</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 多 link naskfunc.obj</span></span><br><span class=\"line\">bootpack.bim : bootpack.obj naskfunc.obj Makefile</span><br><span class=\"line\">    <span class=\"variable\">$(OBJ2BIM)</span> @<span class=\"variable\">$(RULEFILE)</span> out:bootpack.bim stack:3136k map:bootpack.map \\</span><br><span class=\"line\">        bootpack.obj naskfunc.obj</span><br></pre></td></tr></table></figure>\n\n<p>到這天結束，我們已經有以下 source code：</p>\n<ul>\n<li><code>ipl10.nas</code>：IPL 程式</li>\n<li><code>asmhead.nas</code>：OS 的組語部份</li>\n<li><code>bootpack.c</code>：OS 的 C 語言部份</li>\n<li><code>naskfunc.nas</code>：給 C 語言部份使用的組語 function</li>\n</ul>\n","categories":["30 天自製作業系統"],"tags":["OS"]}]